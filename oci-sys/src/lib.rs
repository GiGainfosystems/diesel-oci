/* automatically generated by rust-bindgen */
#![allow(non_upper_case_globals, non_camel_case_types, non_snake_case)]

pub const HDA_SIZE: ::std::os::raw::c_uint = 256;
pub const CDA_SIZE: ::std::os::raw::c_uint = 64;
pub const OCI_EV_DEF: ::std::os::raw::c_uint = 0;
pub const OCI_EV_TSF: ::std::os::raw::c_uint = 1;
pub const OCI_LM_DEF: ::std::os::raw::c_uint = 0;
pub const OCI_LM_NBL: ::std::os::raw::c_uint = 1;
pub const OCI_ONE_PIECE: ::std::os::raw::c_uint = 0;
pub const OCI_FIRST_PIECE: ::std::os::raw::c_uint = 1;
pub const OCI_NEXT_PIECE: ::std::os::raw::c_uint = 2;
pub const OCI_LAST_PIECE: ::std::os::raw::c_uint = 3;
pub const SQLT_CHR: ::std::os::raw::c_uint = 1;
pub const SQLT_NUM: ::std::os::raw::c_uint = 2;
pub const SQLT_INT: ::std::os::raw::c_uint = 3;
pub const SQLT_FLT: ::std::os::raw::c_uint = 4;
pub const SQLT_STR: ::std::os::raw::c_uint = 5;
pub const SQLT_VNU: ::std::os::raw::c_uint = 6;
pub const SQLT_PDN: ::std::os::raw::c_uint = 7;
pub const SQLT_LNG: ::std::os::raw::c_uint = 8;
pub const SQLT_VCS: ::std::os::raw::c_uint = 9;
pub const SQLT_NON: ::std::os::raw::c_uint = 10;
pub const SQLT_RID: ::std::os::raw::c_uint = 11;
pub const SQLT_DAT: ::std::os::raw::c_uint = 12;
pub const SQLT_VBI: ::std::os::raw::c_uint = 15;
pub const SQLT_BFLOAT: ::std::os::raw::c_uint = 21;
pub const SQLT_BDOUBLE: ::std::os::raw::c_uint = 22;
pub const SQLT_BIN: ::std::os::raw::c_uint = 23;
pub const SQLT_LBI: ::std::os::raw::c_uint = 24;
pub const SQLT_UIN: ::std::os::raw::c_uint = 68;
pub const SQLT_SLS: ::std::os::raw::c_uint = 91;
pub const SQLT_LVC: ::std::os::raw::c_uint = 94;
pub const SQLT_LVB: ::std::os::raw::c_uint = 95;
pub const SQLT_AFC: ::std::os::raw::c_uint = 96;
pub const SQLT_AVC: ::std::os::raw::c_uint = 97;
pub const SQLT_IBFLOAT: ::std::os::raw::c_uint = 100;
pub const SQLT_IBDOUBLE: ::std::os::raw::c_uint = 101;
pub const SQLT_CUR: ::std::os::raw::c_uint = 102;
pub const SQLT_RDD: ::std::os::raw::c_uint = 104;
pub const SQLT_LAB: ::std::os::raw::c_uint = 105;
pub const SQLT_OSL: ::std::os::raw::c_uint = 106;
pub const SQLT_NTY: ::std::os::raw::c_uint = 108;
pub const SQLT_REF: ::std::os::raw::c_uint = 110;
pub const SQLT_CLOB: ::std::os::raw::c_uint = 112;
pub const SQLT_BLOB: ::std::os::raw::c_uint = 113;
pub const SQLT_BFILEE: ::std::os::raw::c_uint = 114;
pub const SQLT_CFILEE: ::std::os::raw::c_uint = 115;
pub const SQLT_RSET: ::std::os::raw::c_uint = 116;
pub const SQLT_NCO: ::std::os::raw::c_uint = 122;
pub const SQLT_VST: ::std::os::raw::c_uint = 155;
pub const SQLT_ODT: ::std::os::raw::c_uint = 156;
pub const SQLT_DATE: ::std::os::raw::c_uint = 184;
pub const SQLT_TIME: ::std::os::raw::c_uint = 185;
pub const SQLT_TIME_TZ: ::std::os::raw::c_uint = 186;
pub const SQLT_TIMESTAMP: ::std::os::raw::c_uint = 187;
pub const SQLT_TIMESTAMP_TZ: ::std::os::raw::c_uint = 188;
pub const SQLT_INTERVAL_YM: ::std::os::raw::c_uint = 189;
pub const SQLT_INTERVAL_DS: ::std::os::raw::c_uint = 190;
pub const SQLT_TIMESTAMP_LTZ: ::std::os::raw::c_uint = 232;
pub const SQLT_PNTY: ::std::os::raw::c_uint = 241;
pub const SQLT_REC: ::std::os::raw::c_uint = 250;
pub const SQLT_TAB: ::std::os::raw::c_uint = 251;
pub const SQLT_BOL: ::std::os::raw::c_uint = 252;
pub const SQLT_FILE: ::std::os::raw::c_uint = 114;
pub const SQLT_CFILE: ::std::os::raw::c_uint = 115;
pub const SQLT_BFILE: ::std::os::raw::c_uint = 114;
pub const SQLCS_IMPLICIT: ::std::os::raw::c_uint = 1;
pub const SQLCS_NCHAR: ::std::os::raw::c_uint = 2;
pub const SQLCS_EXPLICIT: ::std::os::raw::c_uint = 3;
pub const SQLCS_FLEXIBLE: ::std::os::raw::c_uint = 4;
pub const SQLCS_LIT_NULL: ::std::os::raw::c_uint = 5;
pub const OCI_HTYPE_FIRST: ::std::os::raw::c_uint = 1;
pub const OCI_HTYPE_ENV: ::std::os::raw::c_uint = 1;
pub const OCI_HTYPE_ERROR: ::std::os::raw::c_uint = 2;
pub const OCI_HTYPE_SVCCTX: ::std::os::raw::c_uint = 3;
pub const OCI_HTYPE_STMT: ::std::os::raw::c_uint = 4;
pub const OCI_HTYPE_BIND: ::std::os::raw::c_uint = 5;
pub const OCI_HTYPE_DEFINE: ::std::os::raw::c_uint = 6;
pub const OCI_HTYPE_DESCRIBE: ::std::os::raw::c_uint = 7;
pub const OCI_HTYPE_SERVER: ::std::os::raw::c_uint = 8;
pub const OCI_HTYPE_SESSION: ::std::os::raw::c_uint = 9;
pub const OCI_HTYPE_AUTHINFO: ::std::os::raw::c_uint = 9;
pub const OCI_HTYPE_TRANS: ::std::os::raw::c_uint = 10;
pub const OCI_HTYPE_COMPLEXOBJECT: ::std::os::raw::c_uint = 11;
pub const OCI_HTYPE_SECURITY: ::std::os::raw::c_uint = 12;
pub const OCI_HTYPE_SUBSCRIPTION: ::std::os::raw::c_uint = 13;
pub const OCI_HTYPE_DIRPATH_CTX: ::std::os::raw::c_uint = 14;
pub const OCI_HTYPE_DIRPATH_COLUMN_ARRAY: ::std::os::raw::c_uint = 15;
pub const OCI_HTYPE_DIRPATH_STREAM: ::std::os::raw::c_uint = 16;
pub const OCI_HTYPE_PROC: ::std::os::raw::c_uint = 17;
pub const OCI_HTYPE_DIRPATH_FN_CTX: ::std::os::raw::c_uint = 18;
pub const OCI_HTYPE_DIRPATH_FN_COL_ARRAY: ::std::os::raw::c_uint = 19;
pub const OCI_HTYPE_XADSESSION: ::std::os::raw::c_uint = 20;
pub const OCI_HTYPE_XADTABLE: ::std::os::raw::c_uint = 21;
pub const OCI_HTYPE_XADFIELD: ::std::os::raw::c_uint = 22;
pub const OCI_HTYPE_XADGRANULE: ::std::os::raw::c_uint = 23;
pub const OCI_HTYPE_XADRECORD: ::std::os::raw::c_uint = 24;
pub const OCI_HTYPE_XADIO: ::std::os::raw::c_uint = 25;
pub const OCI_HTYPE_CPOOL: ::std::os::raw::c_uint = 26;
pub const OCI_HTYPE_SPOOL: ::std::os::raw::c_uint = 27;
pub const OCI_HTYPE_ADMIN: ::std::os::raw::c_uint = 28;
pub const OCI_HTYPE_EVENT: ::std::os::raw::c_uint = 29;
pub const OCI_HTYPE_LAST: ::std::os::raw::c_uint = 29;
pub const OCI_DTYPE_FIRST: ::std::os::raw::c_uint = 50;
pub const OCI_DTYPE_LOB: ::std::os::raw::c_uint = 50;
pub const OCI_DTYPE_SNAP: ::std::os::raw::c_uint = 51;
pub const OCI_DTYPE_RSET: ::std::os::raw::c_uint = 52;
pub const OCI_DTYPE_PARAM: ::std::os::raw::c_uint = 53;
pub const OCI_DTYPE_ROWID: ::std::os::raw::c_uint = 54;
pub const OCI_DTYPE_COMPLEXOBJECTCOMP: ::std::os::raw::c_uint = 55;
pub const OCI_DTYPE_FILE: ::std::os::raw::c_uint = 56;
pub const OCI_DTYPE_AQENQ_OPTIONS: ::std::os::raw::c_uint = 57;
pub const OCI_DTYPE_AQDEQ_OPTIONS: ::std::os::raw::c_uint = 58;
pub const OCI_DTYPE_AQMSG_PROPERTIES: ::std::os::raw::c_uint = 59;
pub const OCI_DTYPE_AQAGENT: ::std::os::raw::c_uint = 60;
pub const OCI_DTYPE_LOCATOR: ::std::os::raw::c_uint = 61;
pub const OCI_DTYPE_INTERVAL_YM: ::std::os::raw::c_uint = 62;
pub const OCI_DTYPE_INTERVAL_DS: ::std::os::raw::c_uint = 63;
pub const OCI_DTYPE_AQNFY_DESCRIPTOR: ::std::os::raw::c_uint = 64;
pub const OCI_DTYPE_DATE: ::std::os::raw::c_uint = 65;
pub const OCI_DTYPE_TIME: ::std::os::raw::c_uint = 66;
pub const OCI_DTYPE_TIME_TZ: ::std::os::raw::c_uint = 67;
pub const OCI_DTYPE_TIMESTAMP: ::std::os::raw::c_uint = 68;
pub const OCI_DTYPE_TIMESTAMP_TZ: ::std::os::raw::c_uint = 69;
pub const OCI_DTYPE_TIMESTAMP_LTZ: ::std::os::raw::c_uint = 70;
pub const OCI_DTYPE_UCB: ::std::os::raw::c_uint = 71;
pub const OCI_DTYPE_SRVDN: ::std::os::raw::c_uint = 72;
pub const OCI_DTYPE_SIGNATURE: ::std::os::raw::c_uint = 73;
pub const OCI_DTYPE_RESERVED_1: ::std::os::raw::c_uint = 74;
pub const OCI_DTYPE_AQLIS_OPTIONS: ::std::os::raw::c_uint = 75;
pub const OCI_DTYPE_AQLIS_MSG_PROPERTIES: ::std::os::raw::c_uint = 76;
pub const OCI_DTYPE_CHDES: ::std::os::raw::c_uint = 77;
pub const OCI_DTYPE_TABLE_CHDES: ::std::os::raw::c_uint = 78;
pub const OCI_DTYPE_ROW_CHDES: ::std::os::raw::c_uint = 79;
pub const OCI_DTYPE_CQDES: ::std::os::raw::c_uint = 80;
pub const OCI_DTYPE_LOB_REGION: ::std::os::raw::c_uint = 81;
pub const OCI_DTYPE_RESERVED_82: ::std::os::raw::c_uint = 82;
pub const OCI_DTYPE_LAST: ::std::os::raw::c_uint = 82;
pub const OCI_TEMP_BLOB: ::std::os::raw::c_uint = 1;
pub const OCI_TEMP_CLOB: ::std::os::raw::c_uint = 2;
pub const OCI_OTYPE_NAME: ::std::os::raw::c_uint = 1;
pub const OCI_OTYPE_REF: ::std::os::raw::c_uint = 2;
pub const OCI_OTYPE_PTR: ::std::os::raw::c_uint = 3;
pub const OCI_ATTR_FNCODE: ::std::os::raw::c_uint = 1;
pub const OCI_ATTR_OBJECT: ::std::os::raw::c_uint = 2;
pub const OCI_ATTR_NONBLOCKING_MODE: ::std::os::raw::c_uint = 3;
pub const OCI_ATTR_SQLCODE: ::std::os::raw::c_uint = 4;
pub const OCI_ATTR_ENV: ::std::os::raw::c_uint = 5;
pub const OCI_ATTR_SERVER: ::std::os::raw::c_uint = 6;
pub const OCI_ATTR_SESSION: ::std::os::raw::c_uint = 7;
pub const OCI_ATTR_TRANS: ::std::os::raw::c_uint = 8;
pub const OCI_ATTR_ROW_COUNT: ::std::os::raw::c_uint = 9;
pub const OCI_ATTR_SQLFNCODE: ::std::os::raw::c_uint = 10;
pub const OCI_ATTR_PREFETCH_ROWS: ::std::os::raw::c_uint = 11;
pub const OCI_ATTR_NESTED_PREFETCH_ROWS: ::std::os::raw::c_uint = 12;
pub const OCI_ATTR_PREFETCH_MEMORY: ::std::os::raw::c_uint = 13;
pub const OCI_ATTR_NESTED_PREFETCH_MEMORY: ::std::os::raw::c_uint = 14;
pub const OCI_ATTR_CHAR_COUNT: ::std::os::raw::c_uint = 15;
pub const OCI_ATTR_PDSCL: ::std::os::raw::c_uint = 16;
pub const OCI_ATTR_FSPRECISION: ::std::os::raw::c_uint = 16;
pub const OCI_ATTR_PDPRC: ::std::os::raw::c_uint = 17;
pub const OCI_ATTR_LFPRECISION: ::std::os::raw::c_uint = 17;
pub const OCI_ATTR_PARAM_COUNT: ::std::os::raw::c_uint = 18;
pub const OCI_ATTR_ROWID: ::std::os::raw::c_uint = 19;
pub const OCI_ATTR_CHARSET: ::std::os::raw::c_uint = 20;
pub const OCI_ATTR_NCHAR: ::std::os::raw::c_uint = 21;
pub const OCI_ATTR_USERNAME: ::std::os::raw::c_uint = 22;
pub const OCI_ATTR_PASSWORD: ::std::os::raw::c_uint = 23;
pub const OCI_ATTR_STMT_TYPE: ::std::os::raw::c_uint = 24;
pub const OCI_ATTR_INTERNAL_NAME: ::std::os::raw::c_uint = 25;
pub const OCI_ATTR_EXTERNAL_NAME: ::std::os::raw::c_uint = 26;
pub const OCI_ATTR_XID: ::std::os::raw::c_uint = 27;
pub const OCI_ATTR_TRANS_LOCK: ::std::os::raw::c_uint = 28;
pub const OCI_ATTR_TRANS_NAME: ::std::os::raw::c_uint = 29;
pub const OCI_ATTR_HEAPALLOC: ::std::os::raw::c_uint = 30;
pub const OCI_ATTR_CHARSET_ID: ::std::os::raw::c_uint = 31;
pub const OCI_ATTR_CHARSET_FORM: ::std::os::raw::c_uint = 32;
pub const OCI_ATTR_MAXDATA_SIZE: ::std::os::raw::c_uint = 33;
pub const OCI_ATTR_CACHE_OPT_SIZE: ::std::os::raw::c_uint = 34;
pub const OCI_ATTR_CACHE_MAX_SIZE: ::std::os::raw::c_uint = 35;
pub const OCI_ATTR_PINOPTION: ::std::os::raw::c_uint = 36;
pub const OCI_ATTR_ALLOC_DURATION: ::std::os::raw::c_uint = 37;
pub const OCI_ATTR_PIN_DURATION: ::std::os::raw::c_uint = 38;
pub const OCI_ATTR_FDO: ::std::os::raw::c_uint = 39;
pub const OCI_ATTR_POSTPROCESSING_CALLBACK: ::std::os::raw::c_uint = 40;
pub const OCI_ATTR_POSTPROCESSING_CONTEXT: ::std::os::raw::c_uint = 41;
pub const OCI_ATTR_ROWS_RETURNED: ::std::os::raw::c_uint = 42;
pub const OCI_ATTR_FOCBK: ::std::os::raw::c_uint = 43;
pub const OCI_ATTR_IN_V8_MODE: ::std::os::raw::c_uint = 44;
pub const OCI_ATTR_LOBEMPTY: ::std::os::raw::c_uint = 45;
pub const OCI_ATTR_SESSLANG: ::std::os::raw::c_uint = 46;
pub const OCI_ATTR_VISIBILITY: ::std::os::raw::c_uint = 47;
pub const OCI_ATTR_RELATIVE_MSGID: ::std::os::raw::c_uint = 48;
pub const OCI_ATTR_SEQUENCE_DEVIATION: ::std::os::raw::c_uint = 49;
pub const OCI_ATTR_CONSUMER_NAME: ::std::os::raw::c_uint = 50;
pub const OCI_ATTR_DEQ_MODE: ::std::os::raw::c_uint = 51;
pub const OCI_ATTR_NAVIGATION: ::std::os::raw::c_uint = 52;
pub const OCI_ATTR_WAIT: ::std::os::raw::c_uint = 53;
pub const OCI_ATTR_DEQ_MSGID: ::std::os::raw::c_uint = 54;
pub const OCI_ATTR_PRIORITY: ::std::os::raw::c_uint = 55;
pub const OCI_ATTR_DELAY: ::std::os::raw::c_uint = 56;
pub const OCI_ATTR_EXPIRATION: ::std::os::raw::c_uint = 57;
pub const OCI_ATTR_CORRELATION: ::std::os::raw::c_uint = 58;
pub const OCI_ATTR_ATTEMPTS: ::std::os::raw::c_uint = 59;
pub const OCI_ATTR_RECIPIENT_LIST: ::std::os::raw::c_uint = 60;
pub const OCI_ATTR_EXCEPTION_QUEUE: ::std::os::raw::c_uint = 61;
pub const OCI_ATTR_ENQ_TIME: ::std::os::raw::c_uint = 62;
pub const OCI_ATTR_MSG_STATE: ::std::os::raw::c_uint = 63;
pub const OCI_ATTR_AGENT_NAME: ::std::os::raw::c_uint = 64;
pub const OCI_ATTR_AGENT_ADDRESS: ::std::os::raw::c_uint = 65;
pub const OCI_ATTR_AGENT_PROTOCOL: ::std::os::raw::c_uint = 66;
pub const OCI_ATTR_USER_PROPERTY: ::std::os::raw::c_uint = 67;
pub const OCI_ATTR_SENDER_ID: ::std::os::raw::c_uint = 68;
pub const OCI_ATTR_ORIGINAL_MSGID: ::std::os::raw::c_uint = 69;
pub const OCI_ATTR_QUEUE_NAME: ::std::os::raw::c_uint = 70;
pub const OCI_ATTR_NFY_MSGID: ::std::os::raw::c_uint = 71;
pub const OCI_ATTR_MSG_PROP: ::std::os::raw::c_uint = 72;
pub const OCI_ATTR_NUM_DML_ERRORS: ::std::os::raw::c_uint = 73;
pub const OCI_ATTR_DML_ROW_OFFSET: ::std::os::raw::c_uint = 74;
pub const OCI_ATTR_AQ_NUM_ERRORS: ::std::os::raw::c_uint = 73;
pub const OCI_ATTR_AQ_ERROR_INDEX: ::std::os::raw::c_uint = 74;
pub const OCI_ATTR_DATEFORMAT: ::std::os::raw::c_uint = 75;
pub const OCI_ATTR_BUF_ADDR: ::std::os::raw::c_uint = 76;
pub const OCI_ATTR_BUF_SIZE: ::std::os::raw::c_uint = 77;
pub const OCI_ATTR_NUM_ROWS: ::std::os::raw::c_uint = 81;
pub const OCI_ATTR_COL_COUNT: ::std::os::raw::c_uint = 82;
pub const OCI_ATTR_STREAM_OFFSET: ::std::os::raw::c_uint = 83;
pub const OCI_ATTR_SHARED_HEAPALLOC: ::std::os::raw::c_uint = 84;
pub const OCI_ATTR_SERVER_GROUP: ::std::os::raw::c_uint = 85;
pub const OCI_ATTR_MIGSESSION: ::std::os::raw::c_uint = 86;
pub const OCI_ATTR_NOCACHE: ::std::os::raw::c_uint = 87;
pub const OCI_ATTR_MEMPOOL_SIZE: ::std::os::raw::c_uint = 88;
pub const OCI_ATTR_MEMPOOL_INSTNAME: ::std::os::raw::c_uint = 89;
pub const OCI_ATTR_MEMPOOL_APPNAME: ::std::os::raw::c_uint = 90;
pub const OCI_ATTR_MEMPOOL_HOMENAME: ::std::os::raw::c_uint = 91;
pub const OCI_ATTR_MEMPOOL_MODEL: ::std::os::raw::c_uint = 92;
pub const OCI_ATTR_MODES: ::std::os::raw::c_uint = 93;
pub const OCI_ATTR_SUBSCR_NAME: ::std::os::raw::c_uint = 94;
pub const OCI_ATTR_SUBSCR_CALLBACK: ::std::os::raw::c_uint = 95;
pub const OCI_ATTR_SUBSCR_CTX: ::std::os::raw::c_uint = 96;
pub const OCI_ATTR_SUBSCR_PAYLOAD: ::std::os::raw::c_uint = 97;
pub const OCI_ATTR_SUBSCR_NAMESPACE: ::std::os::raw::c_uint = 98;
pub const OCI_ATTR_PROXY_CREDENTIALS: ::std::os::raw::c_uint = 99;
pub const OCI_ATTR_INITIAL_CLIENT_ROLES: ::std::os::raw::c_uint = 100;
pub const OCI_ATTR_UNK: ::std::os::raw::c_uint = 101;
pub const OCI_ATTR_NUM_COLS: ::std::os::raw::c_uint = 102;
pub const OCI_ATTR_LIST_COLUMNS: ::std::os::raw::c_uint = 103;
pub const OCI_ATTR_RDBA: ::std::os::raw::c_uint = 104;
pub const OCI_ATTR_CLUSTERED: ::std::os::raw::c_uint = 105;
pub const OCI_ATTR_PARTITIONED: ::std::os::raw::c_uint = 106;
pub const OCI_ATTR_INDEX_ONLY: ::std::os::raw::c_uint = 107;
pub const OCI_ATTR_LIST_ARGUMENTS: ::std::os::raw::c_uint = 108;
pub const OCI_ATTR_LIST_SUBPROGRAMS: ::std::os::raw::c_uint = 109;
pub const OCI_ATTR_REF_TDO: ::std::os::raw::c_uint = 110;
pub const OCI_ATTR_LINK: ::std::os::raw::c_uint = 111;
pub const OCI_ATTR_MIN: ::std::os::raw::c_uint = 112;
pub const OCI_ATTR_MAX: ::std::os::raw::c_uint = 113;
pub const OCI_ATTR_INCR: ::std::os::raw::c_uint = 114;
pub const OCI_ATTR_CACHE: ::std::os::raw::c_uint = 115;
pub const OCI_ATTR_ORDER: ::std::os::raw::c_uint = 116;
pub const OCI_ATTR_HW_MARK: ::std::os::raw::c_uint = 117;
pub const OCI_ATTR_TYPE_SCHEMA: ::std::os::raw::c_uint = 118;
pub const OCI_ATTR_TIMESTAMP: ::std::os::raw::c_uint = 119;
pub const OCI_ATTR_NUM_ATTRS: ::std::os::raw::c_uint = 120;
pub const OCI_ATTR_NUM_PARAMS: ::std::os::raw::c_uint = 121;
pub const OCI_ATTR_OBJID: ::std::os::raw::c_uint = 122;
pub const OCI_ATTR_PTYPE: ::std::os::raw::c_uint = 123;
pub const OCI_ATTR_PARAM: ::std::os::raw::c_uint = 124;
pub const OCI_ATTR_OVERLOAD_ID: ::std::os::raw::c_uint = 125;
pub const OCI_ATTR_TABLESPACE: ::std::os::raw::c_uint = 126;
pub const OCI_ATTR_TDO: ::std::os::raw::c_uint = 127;
pub const OCI_ATTR_LTYPE: ::std::os::raw::c_uint = 128;
pub const OCI_ATTR_PARSE_ERROR_OFFSET: ::std::os::raw::c_uint = 129;
pub const OCI_ATTR_IS_TEMPORARY: ::std::os::raw::c_uint = 130;
pub const OCI_ATTR_IS_TYPED: ::std::os::raw::c_uint = 131;
pub const OCI_ATTR_DURATION: ::std::os::raw::c_uint = 132;
pub const OCI_ATTR_IS_INVOKER_RIGHTS: ::std::os::raw::c_uint = 133;
pub const OCI_ATTR_OBJ_NAME: ::std::os::raw::c_uint = 134;
pub const OCI_ATTR_OBJ_SCHEMA: ::std::os::raw::c_uint = 135;
pub const OCI_ATTR_OBJ_ID: ::std::os::raw::c_uint = 136;
pub const OCI_ATTR_LIST_PKG_TYPES: ::std::os::raw::c_uint = 137;
pub const OCI_ATTR_TRANS_TIMEOUT: ::std::os::raw::c_uint = 142;
pub const OCI_ATTR_SERVER_STATUS: ::std::os::raw::c_uint = 143;
pub const OCI_ATTR_STATEMENT: ::std::os::raw::c_uint = 144;
pub const OCI_ATTR_DEQCOND: ::std::os::raw::c_uint = 146;
pub const OCI_ATTR_RESERVED_2: ::std::os::raw::c_uint = 147;
pub const OCI_ATTR_SUBSCR_RECPT: ::std::os::raw::c_uint = 148;
pub const OCI_ATTR_SUBSCR_RECPTPROTO: ::std::os::raw::c_uint = 149;
pub const OCI_ATTR_LDAP_HOST: ::std::os::raw::c_uint = 153;
pub const OCI_ATTR_LDAP_PORT: ::std::os::raw::c_uint = 154;
pub const OCI_ATTR_BIND_DN: ::std::os::raw::c_uint = 155;
pub const OCI_ATTR_LDAP_CRED: ::std::os::raw::c_uint = 156;
pub const OCI_ATTR_WALL_LOC: ::std::os::raw::c_uint = 157;
pub const OCI_ATTR_LDAP_AUTH: ::std::os::raw::c_uint = 158;
pub const OCI_ATTR_LDAP_CTX: ::std::os::raw::c_uint = 159;
pub const OCI_ATTR_SERVER_DNS: ::std::os::raw::c_uint = 160;
pub const OCI_ATTR_DN_COUNT: ::std::os::raw::c_uint = 161;
pub const OCI_ATTR_SERVER_DN: ::std::os::raw::c_uint = 162;
pub const OCI_ATTR_MAXCHAR_SIZE: ::std::os::raw::c_uint = 163;
pub const OCI_ATTR_CURRENT_POSITION: ::std::os::raw::c_uint = 164;
pub const OCI_ATTR_RESERVED_3: ::std::os::raw::c_uint = 165;
pub const OCI_ATTR_RESERVED_4: ::std::os::raw::c_uint = 166;
pub const OCI_ATTR_DIGEST_ALGO: ::std::os::raw::c_uint = 168;
pub const OCI_ATTR_CERTIFICATE: ::std::os::raw::c_uint = 169;
pub const OCI_ATTR_SIGNATURE_ALGO: ::std::os::raw::c_uint = 170;
pub const OCI_ATTR_CANONICAL_ALGO: ::std::os::raw::c_uint = 171;
pub const OCI_ATTR_PRIVATE_KEY: ::std::os::raw::c_uint = 172;
pub const OCI_ATTR_DIGEST_VALUE: ::std::os::raw::c_uint = 173;
pub const OCI_ATTR_SIGNATURE_VAL: ::std::os::raw::c_uint = 174;
pub const OCI_ATTR_SIGNATURE: ::std::os::raw::c_uint = 175;
pub const OCI_ATTR_STMTCACHESIZE: ::std::os::raw::c_uint = 176;
pub const OCI_ATTR_CONN_NOWAIT: ::std::os::raw::c_uint = 178;
pub const OCI_ATTR_CONN_BUSY_COUNT: ::std::os::raw::c_uint = 179;
pub const OCI_ATTR_CONN_OPEN_COUNT: ::std::os::raw::c_uint = 180;
pub const OCI_ATTR_CONN_TIMEOUT: ::std::os::raw::c_uint = 181;
pub const OCI_ATTR_STMT_STATE: ::std::os::raw::c_uint = 182;
pub const OCI_ATTR_CONN_MIN: ::std::os::raw::c_uint = 183;
pub const OCI_ATTR_CONN_MAX: ::std::os::raw::c_uint = 184;
pub const OCI_ATTR_CONN_INCR: ::std::os::raw::c_uint = 185;
pub const OCI_ATTR_NUM_OPEN_STMTS: ::std::os::raw::c_uint = 188;
pub const OCI_ATTR_DESCRIBE_NATIVE: ::std::os::raw::c_uint = 189;
pub const OCI_ATTR_BIND_COUNT: ::std::os::raw::c_uint = 190;
pub const OCI_ATTR_HANDLE_POSITION: ::std::os::raw::c_uint = 191;
pub const OCI_ATTR_RESERVED_5: ::std::os::raw::c_uint = 192;
pub const OCI_ATTR_SERVER_BUSY: ::std::os::raw::c_uint = 193;
pub const OCI_ATTR_SUBSCR_RECPTPRES: ::std::os::raw::c_uint = 195;
pub const OCI_ATTR_TRANSFORMATION: ::std::os::raw::c_uint = 196;
pub const OCI_ATTR_ROWS_FETCHED: ::std::os::raw::c_uint = 197;
pub const OCI_ATTR_SCN_BASE: ::std::os::raw::c_uint = 198;
pub const OCI_ATTR_SCN_WRAP: ::std::os::raw::c_uint = 199;
pub const OCI_ATTR_RESERVED_6: ::std::os::raw::c_uint = 200;
pub const OCI_ATTR_READONLY_TXN: ::std::os::raw::c_uint = 201;
pub const OCI_ATTR_RESERVED_7: ::std::os::raw::c_uint = 202;
pub const OCI_ATTR_ERRONEOUS_COLUMN: ::std::os::raw::c_uint = 203;
pub const OCI_ATTR_RESERVED_8: ::std::os::raw::c_uint = 204;
pub const OCI_ATTR_ASM_VOL_SPRT: ::std::os::raw::c_uint = 205;
pub const OCI_ATTR_INST_TYPE: ::std::os::raw::c_uint = 207;
pub const OCI_ATTR_ENV_UTF16: ::std::os::raw::c_uint = 209;
pub const OCI_ATTR_RESERVED_9: ::std::os::raw::c_uint = 210;
pub const OCI_ATTR_RESERVED_10: ::std::os::raw::c_uint = 211;
pub const OCI_ATTR_RESERVED_12: ::std::os::raw::c_uint = 214;
pub const OCI_ATTR_RESERVED_13: ::std::os::raw::c_uint = 215;
pub const OCI_ATTR_IS_EXTERNAL: ::std::os::raw::c_uint = 216;
pub const OCI_ATTR_RESERVED_15: ::std::os::raw::c_uint = 217;
pub const OCI_ATTR_STMT_IS_RETURNING: ::std::os::raw::c_uint = 218;
pub const OCI_ATTR_RESERVED_16: ::std::os::raw::c_uint = 219;
pub const OCI_ATTR_RESERVED_17: ::std::os::raw::c_uint = 220;
pub const OCI_ATTR_RESERVED_18: ::std::os::raw::c_uint = 221;
pub const OCI_ATTR_RESERVED_19: ::std::os::raw::c_uint = 222;
pub const OCI_ATTR_RESERVED_20: ::std::os::raw::c_uint = 223;
pub const OCI_ATTR_CURRENT_SCHEMA: ::std::os::raw::c_uint = 224;
pub const OCI_ATTR_RESERVED_21: ::std::os::raw::c_uint = 415;
pub const OCI_ATTR_LAST_LOGON_TIME_UTC: ::std::os::raw::c_uint = 463;
pub const OCI_ATTR_SUBSCR_QOSFLAGS: ::std::os::raw::c_uint = 225;
pub const OCI_ATTR_SUBSCR_PAYLOADCBK: ::std::os::raw::c_uint = 226;
pub const OCI_ATTR_SUBSCR_TIMEOUT: ::std::os::raw::c_uint = 227;
pub const OCI_ATTR_SUBSCR_NAMESPACE_CTX: ::std::os::raw::c_uint = 228;
pub const OCI_ATTR_SUBSCR_CQ_QOSFLAGS: ::std::os::raw::c_uint = 229;
pub const OCI_ATTR_SUBSCR_CQ_REGID: ::std::os::raw::c_uint = 230;
pub const OCI_ATTR_SUBSCR_NTFN_GROUPING_CLASS: ::std::os::raw::c_uint = 231;
pub const OCI_ATTR_SUBSCR_NTFN_GROUPING_VALUE: ::std::os::raw::c_uint = 232;
pub const OCI_ATTR_SUBSCR_NTFN_GROUPING_TYPE: ::std::os::raw::c_uint = 233;
pub const OCI_ATTR_SUBSCR_NTFN_GROUPING_START_TIME: ::std::os::raw::c_uint = 234;
pub const OCI_ATTR_SUBSCR_NTFN_GROUPING_REPEAT_COUNT: ::std::os::raw::c_uint = 235;
pub const OCI_ATTR_AQ_NTFN_GROUPING_MSGID_ARRAY: ::std::os::raw::c_uint = 236;
pub const OCI_ATTR_AQ_NTFN_GROUPING_COUNT: ::std::os::raw::c_uint = 237;
pub const OCI_ATTR_BIND_ROWCBK: ::std::os::raw::c_uint = 301;
pub const OCI_ATTR_BIND_ROWCTX: ::std::os::raw::c_uint = 302;
pub const OCI_ATTR_SKIP_BUFFER: ::std::os::raw::c_uint = 303;
pub const OCI_ATTR_XSTREAM_ACK_INTERVAL: ::std::os::raw::c_uint = 350;
pub const OCI_ATTR_XSTREAM_IDLE_TIMEOUT: ::std::os::raw::c_uint = 351;
pub const OCI_ATTR_CQ_QUERYID: ::std::os::raw::c_uint = 304;
pub const OCI_ATTR_CHNF_TABLENAMES: ::std::os::raw::c_uint = 401;
pub const OCI_ATTR_CHNF_ROWIDS: ::std::os::raw::c_uint = 402;
pub const OCI_ATTR_CHNF_OPERATIONS: ::std::os::raw::c_uint = 403;
pub const OCI_ATTR_CHNF_CHANGELAG: ::std::os::raw::c_uint = 404;
pub const OCI_ATTR_CHDES_DBNAME: ::std::os::raw::c_uint = 405;
pub const OCI_ATTR_CHDES_NFYTYPE: ::std::os::raw::c_uint = 406;
pub const OCI_ATTR_CHDES_XID: ::std::os::raw::c_uint = 407;
pub const OCI_ATTR_CHDES_TABLE_CHANGES: ::std::os::raw::c_uint = 408;
pub const OCI_ATTR_CHDES_TABLE_NAME: ::std::os::raw::c_uint = 409;
pub const OCI_ATTR_CHDES_TABLE_OPFLAGS: ::std::os::raw::c_uint = 410;
pub const OCI_ATTR_CHDES_TABLE_ROW_CHANGES: ::std::os::raw::c_uint = 411;
pub const OCI_ATTR_CHDES_ROW_ROWID: ::std::os::raw::c_uint = 412;
pub const OCI_ATTR_CHDES_ROW_OPFLAGS: ::std::os::raw::c_uint = 413;
pub const OCI_ATTR_CHNF_REGHANDLE: ::std::os::raw::c_uint = 414;
pub const OCI_ATTR_NETWORK_FILE_DESC: ::std::os::raw::c_uint = 415;
pub const OCI_ATTR_PROXY_CLIENT: ::std::os::raw::c_uint = 416;
pub const OCI_ATTR_TABLE_ENC: ::std::os::raw::c_uint = 417;
pub const OCI_ATTR_TABLE_ENC_ALG: ::std::os::raw::c_uint = 418;
pub const OCI_ATTR_TABLE_ENC_ALG_ID: ::std::os::raw::c_uint = 419;
pub const OCI_ATTR_STMTCACHE_CBKCTX: ::std::os::raw::c_uint = 420;
pub const OCI_ATTR_STMTCACHE_CBK: ::std::os::raw::c_uint = 421;
pub const OCI_ATTR_CQDES_OPERATION: ::std::os::raw::c_uint = 422;
pub const OCI_ATTR_CQDES_TABLE_CHANGES: ::std::os::raw::c_uint = 423;
pub const OCI_ATTR_CQDES_QUERYID: ::std::os::raw::c_uint = 424;
pub const OCI_ATTR_CHDES_QUERIES: ::std::os::raw::c_uint = 425;
pub const OCI_ATTR_RESERVED_26: ::std::os::raw::c_uint = 422;
pub const OCI_ATTR_CONNECTION_CLASS: ::std::os::raw::c_uint = 425;
pub const OCI_ATTR_PURITY: ::std::os::raw::c_uint = 426;
pub const OCI_ATTR_PURITY_DEFAULT: ::std::os::raw::c_uint = 0;
pub const OCI_ATTR_PURITY_NEW: ::std::os::raw::c_uint = 1;
pub const OCI_ATTR_PURITY_SELF: ::std::os::raw::c_uint = 2;
pub const OCI_ATTR_RESERVED_28: ::std::os::raw::c_uint = 426;
pub const OCI_ATTR_RESERVED_29: ::std::os::raw::c_uint = 427;
pub const OCI_ATTR_RESERVED_30: ::std::os::raw::c_uint = 428;
pub const OCI_ATTR_RESERVED_31: ::std::os::raw::c_uint = 429;
pub const OCI_ATTR_RESERVED_32: ::std::os::raw::c_uint = 430;
pub const OCI_ATTR_RESERVED_41: ::std::os::raw::c_uint = 454;
pub const OCI_ATTR_RESERVED_33: ::std::os::raw::c_uint = 433;
pub const OCI_ATTR_RESERVED_34: ::std::os::raw::c_uint = 434;
pub const OCI_ATTR_RESERVED_36: ::std::os::raw::c_uint = 444;
pub const OCI_ATTR_SEND_TIMEOUT: ::std::os::raw::c_uint = 435;
pub const OCI_ATTR_RECEIVE_TIMEOUT: ::std::os::raw::c_uint = 436;
pub const OCI_ATTR_DEFAULT_LOBPREFETCH_SIZE: ::std::os::raw::c_uint = 438;
pub const OCI_ATTR_LOBPREFETCH_SIZE: ::std::os::raw::c_uint = 439;
pub const OCI_ATTR_LOBPREFETCH_LENGTH: ::std::os::raw::c_uint = 440;
pub const OCI_ATTR_LOB_REGION_PRIMARY: ::std::os::raw::c_uint = 442;
pub const OCI_ATTR_LOB_REGION_PRIMOFF: ::std::os::raw::c_uint = 443;
pub const OCI_ATTR_LOB_REGION_OFFSET: ::std::os::raw::c_uint = 445;
pub const OCI_ATTR_LOB_REGION_LENGTH: ::std::os::raw::c_uint = 446;
pub const OCI_ATTR_LOB_REGION_MIME: ::std::os::raw::c_uint = 447;
pub const OCI_ATTR_FETCH_ROWID: ::std::os::raw::c_uint = 448;
pub const OCI_ATTR_RESERVED_37: ::std::os::raw::c_uint = 449;
pub const OCI_ATTR_NO_COLUMN_AUTH_WARNING: ::std::os::raw::c_uint = 450;
pub const OCI_ATTR_XDS_POLICY_STATUS: ::std::os::raw::c_uint = 451;
pub const OCI_XDS_POLICY_NONE: ::std::os::raw::c_uint = 0;
pub const OCI_XDS_POLICY_ENABLED: ::std::os::raw::c_uint = 1;
pub const OCI_XDS_POLICY_UNKNOWN: ::std::os::raw::c_uint = 2;
pub const OCI_ATTR_SUBSCR_IPADDR: ::std::os::raw::c_uint = 452;
pub const OCI_ATTR_RESERVED_40: ::std::os::raw::c_uint = 453;
pub const OCI_ATTR_RESERVED_42: ::std::os::raw::c_uint = 455;
pub const OCI_ATTR_RESERVED_43: ::std::os::raw::c_uint = 456;
pub const OCI_ATTR_UB8_ROW_COUNT: ::std::os::raw::c_uint = 457;
pub const OCI_ATTR_RESERVED_458: ::std::os::raw::c_uint = 458;
pub const OCI_ATTR_RESERVED_459: ::std::os::raw::c_uint = 459;
pub const OCI_ATTR_SHOW_INVISIBLE_COLUMNS: ::std::os::raw::c_uint = 460;
pub const OCI_ATTR_INVISIBLE_COL: ::std::os::raw::c_uint = 461;
pub const OCI_ATTR_LTXID: ::std::os::raw::c_uint = 462;
pub const OCI_ATTR_IMPLICIT_RESULT_COUNT: ::std::os::raw::c_uint = 463;
pub const OCI_ATTR_RESERVED_464: ::std::os::raw::c_uint = 464;
pub const OCI_ATTR_RESERVED_465: ::std::os::raw::c_uint = 465;
pub const OCI_ATTR_RESERVED_466: ::std::os::raw::c_uint = 466;
pub const OCI_ATTR_RESERVED_467: ::std::os::raw::c_uint = 467;
pub const OCI_ATTR_SQL_TRANSLATION_PROFILE: ::std::os::raw::c_uint = 468;
pub const OCI_ATTR_DML_ROW_COUNT_ARRAY: ::std::os::raw::c_uint = 469;
pub const OCI_ATTR_RESERVED_470: ::std::os::raw::c_uint = 470;
pub const OCI_ATTR_MAX_OPEN_CURSORS: ::std::os::raw::c_uint = 471;
pub const OCI_ATTR_ERROR_IS_RECOVERABLE: ::std::os::raw::c_uint = 472;
pub const OCI_ATTR_RESERVED_473: ::std::os::raw::c_uint = 473;
pub const OCI_ATTR_ILM_TRACK_WRITE: ::std::os::raw::c_uint = 474;
pub const OCI_ATTR_SUBSCR_FAILURE_CBK: ::std::os::raw::c_uint = 477;
pub const OCI_ATTR_SUBSCR_FAILURE_CTX: ::std::os::raw::c_uint = 478;
pub const OCI_ATTR_RESERVED_479: ::std::os::raw::c_uint = 479;
pub const OCI_ATTR_RESERVED_480: ::std::os::raw::c_uint = 480;
pub const OCI_ATTR_RESERVED_481: ::std::os::raw::c_uint = 481;
pub const OCI_ATTR_RESERVED_482: ::std::os::raw::c_uint = 482;
pub const OCI_ATTR_TRANS_PROFILE_FOREIGN: ::std::os::raw::c_uint = 483;
pub const OCI_ATTR_TRANSACTION_IN_PROGRESS: ::std::os::raw::c_uint = 484;
pub const OCI_ATTR_DBOP: ::std::os::raw::c_uint = 485;
pub const OCI_ATTR_RESERVED_486: ::std::os::raw::c_uint = 486;
pub const OCI_ATTR_RESERVED_487: ::std::os::raw::c_uint = 487;
pub const OCI_ATTR_RESERVED_488: ::std::os::raw::c_uint = 488;
pub const OCI_ATTR_VARTYPE_MAXLEN_COMPAT: ::std::os::raw::c_uint = 489;
pub const OCI_ATTR_SPOOL_MAX_LIFETIME_SESSION: ::std::os::raw::c_uint = 490;
pub const OCI_ATTR_RESERVED_491: ::std::os::raw::c_uint = 491;
pub const OCI_ATTR_RESERVED_492: ::std::os::raw::c_uint = 492;
pub const OCI_ATTR_RESERVED_493: ::std::os::raw::c_uint = 493;
pub const OCI_ATTR_ITERS_PROCESSED: ::std::os::raw::c_uint = 494;
pub const OCI_ATTR_BREAK_ON_NET_TIMEOUT: ::std::os::raw::c_uint = 495;
pub const OCI_ATTR_DIRPATH_RESERVED_9: ::std::os::raw::c_uint = 2000;
pub const OCI_ATTR_DIRPATH_RESERVED_10: ::std::os::raw::c_uint = 2001;
pub const OCI_ATTR_DIRPATH_RESERVED_11: ::std::os::raw::c_uint = 2002;
pub const OCI_ATTR_CURRENT_ERRCOL: ::std::os::raw::c_uint = 2003;
pub const OCI_ATTR_DIRPATH_SUBTYPE_INDEX: ::std::os::raw::c_uint = 2004;
pub const OCI_ATTR_DIRPATH_RESERVED_12: ::std::os::raw::c_uint = 2005;
pub const OCI_ATTR_DIRPATH_RESERVED_13: ::std::os::raw::c_uint = 2006;
pub const OCI_ATTR_DIRPATH_RESERVED_14: ::std::os::raw::c_uint = 2007;
pub const OCI_ATTR_DIRPATH_RESERVED_15: ::std::os::raw::c_uint = 2008;
pub const OCI_ATTR_DIRPATH_RESERVED_16: ::std::os::raw::c_uint = 2009;
pub const OCI_ATTR_DIRPATH_RESERVED_17: ::std::os::raw::c_uint = 2010;
pub const OCI_ATTR_DIRPATH_RESERVED_18: ::std::os::raw::c_uint = 2011;
pub const OCI_ATTR_DIRPATH_RESERVED_19: ::std::os::raw::c_uint = 2012;
pub const OCI_ATTR_DIRPATH_NO_INDEX_ERRORS: ::std::os::raw::c_uint = 2013;
pub const OCI_ATTR_DIRPATH_RESERVED_20: ::std::os::raw::c_uint = 2014;
pub const OCI_ATTR_DIRPATH_RESERVED_21: ::std::os::raw::c_uint = 2015;
pub const OCI_ATTR_DIRPATH_RESERVED_22: ::std::os::raw::c_uint = 2016;
pub const OCI_ATTR_DIRPATH_USE_ACTIVE_TRANS: ::std::os::raw::c_uint = 2017;
pub const OCI_ATTR_DIRPATH_RESERVED_23: ::std::os::raw::c_uint = 2018;
pub const OCI_ATTR_DIRPATH_RESERVED_24: ::std::os::raw::c_uint = 2019;
pub const OCI_ATTR_DIRPATH_REJECT_ROWS_REPCHR: ::std::os::raw::c_uint = 2020;
pub const OCI_ATTR_DIRPATH_RESERVED_25: ::std::os::raw::c_uint = 2021;
pub const OCI_ATTR_DIRPATH_PGA_LIM: ::std::os::raw::c_uint = 2022;
pub const OCI_ATTR_DIRPATH_SPILL_PASSES: ::std::os::raw::c_uint = 2023;
pub const OCI_ATTR_DIRPATH_FLAGS: ::std::os::raw::c_uint = 2024;
pub const OCI_ATTR_DIRPATH_FLAGS_RESERVED: ::std::os::raw::c_uint = 4294901760;
pub const OCI_EVENT_NONE: ::std::os::raw::c_uint = 0;
pub const OCI_EVENT_STARTUP: ::std::os::raw::c_uint = 1;
pub const OCI_EVENT_SHUTDOWN: ::std::os::raw::c_uint = 2;
pub const OCI_EVENT_SHUTDOWN_ANY: ::std::os::raw::c_uint = 3;
pub const OCI_EVENT_DROP_DB: ::std::os::raw::c_uint = 4;
pub const OCI_EVENT_DEREG: ::std::os::raw::c_uint = 5;
pub const OCI_EVENT_OBJCHANGE: ::std::os::raw::c_uint = 6;
pub const OCI_EVENT_QUERYCHANGE: ::std::os::raw::c_uint = 7;
pub const OCI_OPCODE_ALLROWS: ::std::os::raw::c_uint = 1;
pub const OCI_OPCODE_ALLOPS: ::std::os::raw::c_uint = 0;
pub const OCI_OPCODE_INSERT: ::std::os::raw::c_uint = 2;
pub const OCI_OPCODE_UPDATE: ::std::os::raw::c_uint = 4;
pub const OCI_OPCODE_DELETE: ::std::os::raw::c_uint = 8;
pub const OCI_OPCODE_ALTER: ::std::os::raw::c_uint = 16;
pub const OCI_OPCODE_DROP: ::std::os::raw::c_uint = 32;
pub const OCI_OPCODE_UNKNOWN: ::std::os::raw::c_uint = 64;
pub const OCI_ATTR_ENV_CHARSET_ID: ::std::os::raw::c_uint = 31;
pub const OCI_ATTR_EVTCBK: ::std::os::raw::c_uint = 304;
pub const OCI_ATTR_EVTCTX: ::std::os::raw::c_uint = 305;
pub const OCI_ATTR_USER_MEMORY: ::std::os::raw::c_uint = 306;
pub const OCI_ATTR_ACCESS_BANNER: ::std::os::raw::c_uint = 307;
pub const OCI_ATTR_AUDIT_BANNER: ::std::os::raw::c_uint = 308;
pub const OCI_ATTR_SUBSCR_PORTNO: ::std::os::raw::c_uint = 390;
pub const OCI_ATTR_RESERVED_35: ::std::os::raw::c_uint = 437;
pub const OCI_SUBSCR_PROTO_OCI: ::std::os::raw::c_uint = 0;
pub const OCI_SUBSCR_PROTO_MAIL: ::std::os::raw::c_uint = 1;
pub const OCI_SUBSCR_PROTO_SERVER: ::std::os::raw::c_uint = 2;
pub const OCI_SUBSCR_PROTO_HTTP: ::std::os::raw::c_uint = 3;
pub const OCI_SUBSCR_PROTO_MAX: ::std::os::raw::c_uint = 4;
pub const OCI_SUBSCR_PRES_DEFAULT: ::std::os::raw::c_uint = 0;
pub const OCI_SUBSCR_PRES_XML: ::std::os::raw::c_uint = 1;
pub const OCI_SUBSCR_PRES_MAX: ::std::os::raw::c_uint = 2;
pub const OCI_SUBSCR_QOS_RELIABLE: ::std::os::raw::c_uint = 1;
pub const OCI_SUBSCR_QOS_PAYLOAD: ::std::os::raw::c_uint = 2;
pub const OCI_SUBSCR_QOS_REPLICATE: ::std::os::raw::c_uint = 4;
pub const OCI_SUBSCR_QOS_SECURE: ::std::os::raw::c_uint = 8;
pub const OCI_SUBSCR_QOS_PURGE_ON_NTFN: ::std::os::raw::c_uint = 16;
pub const OCI_SUBSCR_QOS_MULTICBK: ::std::os::raw::c_uint = 32;
pub const OCI_SUBSCR_QOS_HAREG: ::std::os::raw::c_uint = 128;
pub const OCI_SUBSCR_QOS_NONDURABLE: ::std::os::raw::c_uint = 256;
pub const OCI_SUBSCR_QOS_ASYNC_DEQ: ::std::os::raw::c_uint = 512;
pub const OCI_SUBSCR_QOS_AUTO_ACK: ::std::os::raw::c_uint = 1024;
pub const OCI_SUBSCR_QOS_TX_ACK: ::std::os::raw::c_uint = 2048;
pub const OCI_SUBSCR_CQ_QOS_QUERY: ::std::os::raw::c_uint = 1;
pub const OCI_SUBSCR_CQ_QOS_BEST_EFFORT: ::std::os::raw::c_uint = 2;
pub const OCI_SUBSCR_CQ_QOS_CLQRYCACHE: ::std::os::raw::c_uint = 4;
pub const OCI_SUBSCR_NTFN_GROUPING_CLASS_TIME: ::std::os::raw::c_uint = 1;
pub const OCI_SUBSCR_NTFN_GROUPING_TYPE_SUMMARY: ::std::os::raw::c_uint = 1;
pub const OCI_SUBSCR_NTFN_GROUPING_TYPE_LAST: ::std::os::raw::c_uint = 2;
pub const OCI_UCS2ID: ::std::os::raw::c_uint = 1000;
pub const OCI_UTF16ID: ::std::os::raw::c_uint = 1000;
pub const OCI_RESULT_TYPE_SELECT: ::std::os::raw::c_uint = 1;
pub const OCI_SERVER_NOT_CONNECTED: ::std::os::raw::c_uint = 0;
pub const OCI_SERVER_NORMAL: ::std::os::raw::c_uint = 1;
pub const OCI_SUBSCR_NAMESPACE_ANONYMOUS: ::std::os::raw::c_uint = 0;
pub const OCI_SUBSCR_NAMESPACE_AQ: ::std::os::raw::c_uint = 1;
pub const OCI_SUBSCR_NAMESPACE_DBCHANGE: ::std::os::raw::c_uint = 2;
pub const OCI_SUBSCR_NAMESPACE_RESERVED1: ::std::os::raw::c_uint = 3;
pub const OCI_SUBSCR_NAMESPACE_MAX: ::std::os::raw::c_uint = 4;
pub const OCI_CRED_RDBMS: ::std::os::raw::c_uint = 1;
pub const OCI_CRED_EXT: ::std::os::raw::c_uint = 2;
pub const OCI_CRED_PROXY: ::std::os::raw::c_uint = 3;
pub const OCI_CRED_RESERVED_1: ::std::os::raw::c_uint = 4;
pub const OCI_CRED_RESERVED_2: ::std::os::raw::c_uint = 5;
pub const OCI_CRED_RESERVED_3: ::std::os::raw::c_uint = 6;
pub const OCI_SUCCESS: ::std::os::raw::c_uint = 0;
pub const OCI_SUCCESS_WITH_INFO: ::std::os::raw::c_uint = 1;
pub const OCI_RESERVED_FOR_INT_USE: ::std::os::raw::c_uint = 200;
pub const OCI_NO_DATA: ::std::os::raw::c_uint = 100;
pub const OCI_ERROR: ::std::os::raw::c_int = -1;
pub const OCI_INVALID_HANDLE: ::std::os::raw::c_int = -2;
pub const OCI_NEED_DATA: ::std::os::raw::c_uint = 99;
pub const OCI_STILL_EXECUTING: ::std::os::raw::c_int = -3123;
pub const OCI_CONTINUE: ::std::os::raw::c_int = -24200;
pub const OCI_ROWCBK_DONE: ::std::os::raw::c_int = -24201;
pub const OCI_DT_INVALID_DAY: ::std::os::raw::c_uint = 1;
pub const OCI_DT_DAY_BELOW_VALID: ::std::os::raw::c_uint = 2;
pub const OCI_DT_INVALID_MONTH: ::std::os::raw::c_uint = 4;
pub const OCI_DT_MONTH_BELOW_VALID: ::std::os::raw::c_uint = 8;
pub const OCI_DT_INVALID_YEAR: ::std::os::raw::c_uint = 16;
pub const OCI_DT_YEAR_BELOW_VALID: ::std::os::raw::c_uint = 32;
pub const OCI_DT_INVALID_HOUR: ::std::os::raw::c_uint = 64;
pub const OCI_DT_HOUR_BELOW_VALID: ::std::os::raw::c_uint = 128;
pub const OCI_DT_INVALID_MINUTE: ::std::os::raw::c_uint = 256;
pub const OCI_DT_MINUTE_BELOW_VALID: ::std::os::raw::c_uint = 512;
pub const OCI_DT_INVALID_SECOND: ::std::os::raw::c_uint = 1024;
pub const OCI_DT_SECOND_BELOW_VALID: ::std::os::raw::c_uint = 2048;
pub const OCI_DT_DAY_MISSING_FROM_1582: ::std::os::raw::c_uint = 4096;
pub const OCI_DT_YEAR_ZERO: ::std::os::raw::c_uint = 8192;
pub const OCI_DT_INVALID_TIMEZONE: ::std::os::raw::c_uint = 16384;
pub const OCI_DT_INVALID_FORMAT: ::std::os::raw::c_uint = 32768;
pub const OCI_INTER_INVALID_DAY: ::std::os::raw::c_uint = 1;
pub const OCI_INTER_DAY_BELOW_VALID: ::std::os::raw::c_uint = 2;
pub const OCI_INTER_INVALID_MONTH: ::std::os::raw::c_uint = 4;
pub const OCI_INTER_MONTH_BELOW_VALID: ::std::os::raw::c_uint = 8;
pub const OCI_INTER_INVALID_YEAR: ::std::os::raw::c_uint = 16;
pub const OCI_INTER_YEAR_BELOW_VALID: ::std::os::raw::c_uint = 32;
pub const OCI_INTER_INVALID_HOUR: ::std::os::raw::c_uint = 64;
pub const OCI_INTER_HOUR_BELOW_VALID: ::std::os::raw::c_uint = 128;
pub const OCI_INTER_INVALID_MINUTE: ::std::os::raw::c_uint = 256;
pub const OCI_INTER_MINUTE_BELOW_VALID: ::std::os::raw::c_uint = 512;
pub const OCI_INTER_INVALID_SECOND: ::std::os::raw::c_uint = 1024;
pub const OCI_INTER_SECOND_BELOW_VALID: ::std::os::raw::c_uint = 2048;
pub const OCI_INTER_INVALID_FRACSEC: ::std::os::raw::c_uint = 4096;
pub const OCI_INTER_FRACSEC_BELOW_VALID: ::std::os::raw::c_uint = 8192;
pub const OCI_V7_SYNTAX: ::std::os::raw::c_uint = 2;
pub const OCI_V8_SYNTAX: ::std::os::raw::c_uint = 3;
pub const OCI_NTV_SYNTAX: ::std::os::raw::c_uint = 1;
pub const OCI_FETCH_CURRENT: ::std::os::raw::c_uint = 1;
pub const OCI_FETCH_NEXT: ::std::os::raw::c_uint = 2;
pub const OCI_FETCH_FIRST: ::std::os::raw::c_uint = 4;
pub const OCI_FETCH_LAST: ::std::os::raw::c_uint = 8;
pub const OCI_FETCH_PRIOR: ::std::os::raw::c_uint = 16;
pub const OCI_FETCH_ABSOLUTE: ::std::os::raw::c_uint = 32;
pub const OCI_FETCH_RELATIVE: ::std::os::raw::c_uint = 64;
pub const OCI_FETCH_RESERVED_1: ::std::os::raw::c_uint = 128;
pub const OCI_FETCH_RESERVED_2: ::std::os::raw::c_uint = 256;
pub const OCI_FETCH_RESERVED_3: ::std::os::raw::c_uint = 512;
pub const OCI_FETCH_RESERVED_4: ::std::os::raw::c_uint = 1024;
pub const OCI_FETCH_RESERVED_5: ::std::os::raw::c_uint = 2048;
pub const OCI_FETCH_RESERVED_6: ::std::os::raw::c_uint = 4096;
pub const OCI_SB2_IND_PTR: ::std::os::raw::c_uint = 1;
pub const OCI_DATA_AT_EXEC: ::std::os::raw::c_uint = 2;
pub const OCI_DYNAMIC_FETCH: ::std::os::raw::c_uint = 2;
pub const OCI_PIECEWISE: ::std::os::raw::c_uint = 4;
pub const OCI_DEFINE_RESERVED_1: ::std::os::raw::c_uint = 8;
pub const OCI_BIND_RESERVED_2: ::std::os::raw::c_uint = 16;
pub const OCI_DEFINE_RESERVED_2: ::std::os::raw::c_uint = 32;
pub const OCI_BIND_SOFT: ::std::os::raw::c_uint = 64;
pub const OCI_DEFINE_SOFT: ::std::os::raw::c_uint = 128;
pub const OCI_BIND_RESERVED_3: ::std::os::raw::c_uint = 256;
pub const OCI_IOV: ::std::os::raw::c_uint = 512;
pub const OCI_DEFAULT: ::std::os::raw::c_uint = 0;
pub const OCI_THREADED: ::std::os::raw::c_uint = 1;
pub const OCI_OBJECT: ::std::os::raw::c_uint = 2;
pub const OCI_EVENTS: ::std::os::raw::c_uint = 4;
pub const OCI_RESERVED1: ::std::os::raw::c_uint = 8;
pub const OCI_SHARED: ::std::os::raw::c_uint = 16;
pub const OCI_RESERVED2: ::std::os::raw::c_uint = 32;
pub const OCI_NO_UCB: ::std::os::raw::c_uint = 64;
pub const OCI_NO_MUTEX: ::std::os::raw::c_uint = 128;
pub const OCI_SHARED_EXT: ::std::os::raw::c_uint = 256;
pub const OCI_ALWAYS_BLOCKING: ::std::os::raw::c_uint = 1024;
pub const OCI_USE_LDAP: ::std::os::raw::c_uint = 4096;
pub const OCI_REG_LDAPONLY: ::std::os::raw::c_uint = 8192;
pub const OCI_UTF16: ::std::os::raw::c_uint = 16384;
pub const OCI_AFC_PAD_ON: ::std::os::raw::c_uint = 32768;
pub const OCI_ENVCR_RESERVED3: ::std::os::raw::c_uint = 65536;
pub const OCI_NEW_LENGTH_SEMANTICS: ::std::os::raw::c_uint = 131072;
pub const OCI_NO_MUTEX_STMT: ::std::os::raw::c_uint = 262144;
pub const OCI_MUTEX_ENV_ONLY: ::std::os::raw::c_uint = 524288;
pub const OCI_SUPPRESS_NLS_VALIDATION: ::std::os::raw::c_uint = 1048576;
pub const OCI_MUTEX_TRY: ::std::os::raw::c_uint = 2097152;
pub const OCI_NCHAR_LITERAL_REPLACE_ON: ::std::os::raw::c_uint = 4194304;
pub const OCI_NCHAR_LITERAL_REPLACE_OFF: ::std::os::raw::c_uint = 8388608;
pub const OCI_ENABLE_NLS_VALIDATION: ::std::os::raw::c_uint = 16777216;
pub const OCI_ENVCR_RESERVED4: ::std::os::raw::c_uint = 33554432;
pub const OCI_ENVCR_RESERVED5: ::std::os::raw::c_uint = 67108864;
pub const OCI_ENVCR_RESERVED6: ::std::os::raw::c_uint = 134217728;
pub const OCI_ENVCR_RESERVED7: ::std::os::raw::c_uint = 268435456;
pub const OCI_SECURE_NOTIFICATION: ::std::os::raw::c_uint = 536870912;
pub const OCI_DISABLE_DIAG: ::std::os::raw::c_uint = 1073741824;
pub const OCI_CPOOL_REINITIALIZE: ::std::os::raw::c_uint = 273;
pub const OCI_LOGON2_SPOOL: ::std::os::raw::c_uint = 1;
pub const OCI_LOGON2_STMTCACHE: ::std::os::raw::c_uint = 4;
pub const OCI_LOGON2_PROXY: ::std::os::raw::c_uint = 8;
pub const OCI_SPC_REINITIALIZE: ::std::os::raw::c_uint = 1;
pub const OCI_SPC_HOMOGENEOUS: ::std::os::raw::c_uint = 2;
pub const OCI_SPC_STMTCACHE: ::std::os::raw::c_uint = 4;
pub const OCI_SPC_NO_RLB: ::std::os::raw::c_uint = 8;
pub const OCI_SESSGET_SPOOL: ::std::os::raw::c_uint = 1;
pub const OCI_SESSGET_STMTCACHE: ::std::os::raw::c_uint = 4;
pub const OCI_SESSGET_CREDPROXY: ::std::os::raw::c_uint = 8;
pub const OCI_SESSGET_CREDEXT: ::std::os::raw::c_uint = 16;
pub const OCI_SESSGET_SPOOL_MATCHANY: ::std::os::raw::c_uint = 32;
pub const OCI_SESSGET_PURITY_NEW: ::std::os::raw::c_uint = 64;
pub const OCI_SESSGET_PURITY_SELF: ::std::os::raw::c_uint = 128;
pub const OCI_SESSGET_SYSDBA: ::std::os::raw::c_uint = 256;
pub const OCI_SPOOL_ATTRVAL_WAIT: ::std::os::raw::c_uint = 0;
pub const OCI_SPOOL_ATTRVAL_NOWAIT: ::std::os::raw::c_uint = 1;
pub const OCI_SPOOL_ATTRVAL_FORCEGET: ::std::os::raw::c_uint = 2;
pub const OCI_SESSRLS_DROPSESS: ::std::os::raw::c_uint = 1;
pub const OCI_SESSRLS_RETAG: ::std::os::raw::c_uint = 2;
pub const OCI_SPD_FORCE: ::std::os::raw::c_uint = 1;
pub const OCI_STMT_STATE_INITIALIZED: ::std::os::raw::c_uint = 1;
pub const OCI_STMT_STATE_EXECUTED: ::std::os::raw::c_uint = 2;
pub const OCI_STMT_STATE_END_OF_FETCH: ::std::os::raw::c_uint = 3;
pub const OCI_MEM_INIT: ::std::os::raw::c_uint = 1;
pub const OCI_MEM_CLN: ::std::os::raw::c_uint = 2;
pub const OCI_MEM_FLUSH: ::std::os::raw::c_uint = 4;
pub const OCI_DUMP_HEAP: ::std::os::raw::c_uint = 128;
pub const OCI_CLIENT_STATS: ::std::os::raw::c_uint = 16;
pub const OCI_SERVER_STATS: ::std::os::raw::c_uint = 32;
pub const OCI_ENV_NO_UCB: ::std::os::raw::c_uint = 1;
pub const OCI_ENV_NO_MUTEX: ::std::os::raw::c_uint = 8;
pub const OCI_NO_SHARING: ::std::os::raw::c_uint = 1;
pub const OCI_PREP_RESERVED_1: ::std::os::raw::c_uint = 2;
pub const OCI_PREP_AFC_PAD_ON: ::std::os::raw::c_uint = 4;
pub const OCI_PREP_AFC_PAD_OFF: ::std::os::raw::c_uint = 8;
pub const OCI_BATCH_MODE: ::std::os::raw::c_uint = 1;
pub const OCI_EXACT_FETCH: ::std::os::raw::c_uint = 2;
pub const OCI_STMT_SCROLLABLE_READONLY: ::std::os::raw::c_uint = 8;
pub const OCI_DESCRIBE_ONLY: ::std::os::raw::c_uint = 16;
pub const OCI_COMMIT_ON_SUCCESS: ::std::os::raw::c_uint = 32;
pub const OCI_NON_BLOCKING: ::std::os::raw::c_uint = 64;
pub const OCI_BATCH_ERRORS: ::std::os::raw::c_uint = 128;
pub const OCI_PARSE_ONLY: ::std::os::raw::c_uint = 256;
pub const OCI_EXACT_FETCH_RESERVED_1: ::std::os::raw::c_uint = 512;
pub const OCI_SHOW_DML_WARNINGS: ::std::os::raw::c_uint = 1024;
pub const OCI_EXEC_RESERVED_2: ::std::os::raw::c_uint = 2048;
pub const OCI_DESC_RESERVED_1: ::std::os::raw::c_uint = 4096;
pub const OCI_EXEC_RESERVED_3: ::std::os::raw::c_uint = 8192;
pub const OCI_EXEC_RESERVED_4: ::std::os::raw::c_uint = 16384;
pub const OCI_EXEC_RESERVED_5: ::std::os::raw::c_uint = 32768;
pub const OCI_EXEC_RESERVED_6: ::std::os::raw::c_uint = 65536;
pub const OCI_RESULT_CACHE: ::std::os::raw::c_uint = 131072;
pub const OCI_NO_RESULT_CACHE: ::std::os::raw::c_uint = 262144;
pub const OCI_EXEC_RESERVED_7: ::std::os::raw::c_uint = 524288;
pub const OCI_RETURN_ROW_COUNT_ARRAY: ::std::os::raw::c_uint = 1048576;
pub const OCI_MIGRATE: ::std::os::raw::c_uint = 1;
pub const OCI_SYSDBA: ::std::os::raw::c_uint = 2;
pub const OCI_SYSOPER: ::std::os::raw::c_uint = 4;
pub const OCI_PRELIM_AUTH: ::std::os::raw::c_uint = 8;
pub const OCIP_ICACHE: ::std::os::raw::c_uint = 16;
pub const OCI_AUTH_RESERVED_1: ::std::os::raw::c_uint = 32;
pub const OCI_STMT_CACHE: ::std::os::raw::c_uint = 64;
pub const OCI_STATELESS_CALL: ::std::os::raw::c_uint = 128;
pub const OCI_STATELESS_TXN: ::std::os::raw::c_uint = 256;
pub const OCI_STATELESS_APP: ::std::os::raw::c_uint = 512;
pub const OCI_AUTH_RESERVED_2: ::std::os::raw::c_uint = 1024;
pub const OCI_AUTH_RESERVED_3: ::std::os::raw::c_uint = 2048;
pub const OCI_AUTH_RESERVED_4: ::std::os::raw::c_uint = 4096;
pub const OCI_AUTH_RESERVED_5: ::std::os::raw::c_uint = 8192;
pub const OCI_SYSASM: ::std::os::raw::c_uint = 32768;
pub const OCI_AUTH_RESERVED_6: ::std::os::raw::c_uint = 65536;
pub const OCI_SYSBKP: ::std::os::raw::c_uint = 131072;
pub const OCI_SYSDGD: ::std::os::raw::c_uint = 262144;
pub const OCI_SYSKMT: ::std::os::raw::c_uint = 524288;
pub const OCI_SESSEND_RESERVED_1: ::std::os::raw::c_uint = 1;
pub const OCI_SESSEND_RESERVED_2: ::std::os::raw::c_uint = 2;
pub const OCI_FASTPATH: ::std::os::raw::c_uint = 16;
pub const OCI_ATCH_RESERVED_1: ::std::os::raw::c_uint = 32;
pub const OCI_ATCH_RESERVED_2: ::std::os::raw::c_uint = 128;
pub const OCI_ATCH_RESERVED_3: ::std::os::raw::c_uint = 256;
pub const OCI_CPOOL: ::std::os::raw::c_uint = 512;
pub const OCI_ATCH_RESERVED_4: ::std::os::raw::c_uint = 1024;
pub const OCI_ATCH_RESERVED_5: ::std::os::raw::c_uint = 8192;
pub const OCI_ATCH_ENABLE_BEQ: ::std::os::raw::c_uint = 16384;
pub const OCI_ATCH_RESERVED_6: ::std::os::raw::c_uint = 32768;
pub const OCI_ATCH_RESERVED_7: ::std::os::raw::c_uint = 65536;
pub const OCI_ATCH_RESERVED_8: ::std::os::raw::c_uint = 131072;
pub const OCI_SRVATCH_RESERVED5: ::std::os::raw::c_uint = 16777216;
pub const OCI_SRVATCH_RESERVED6: ::std::os::raw::c_uint = 33554432;
pub const OCI_PREP2_CACHE_SEARCHONLY: ::std::os::raw::c_uint = 16;
pub const OCI_PREP2_GET_PLSQL_WARNINGS: ::std::os::raw::c_uint = 32;
pub const OCI_PREP2_RESERVED_1: ::std::os::raw::c_uint = 64;
pub const OCI_PREP2_RESERVED_2: ::std::os::raw::c_uint = 128;
pub const OCI_PREP2_RESERVED_3: ::std::os::raw::c_uint = 256;
pub const OCI_PREP2_RESERVED_4: ::std::os::raw::c_uint = 512;
pub const OCI_PREP2_IMPL_RESULTS_CLIENT: ::std::os::raw::c_uint = 1024;
pub const OCI_PREP2_RESERVED_5: ::std::os::raw::c_uint = 2048;
pub const OCI_STRLS_CACHE_DELETE: ::std::os::raw::c_uint = 16;
pub const OCI_STM_RESERVED4: ::std::os::raw::c_uint = 1048576;
pub const OCI_PARAM_IN: ::std::os::raw::c_uint = 1;
pub const OCI_PARAM_OUT: ::std::os::raw::c_uint = 2;
pub const OCI_TRANS_NEW: ::std::os::raw::c_uint = 1;
pub const OCI_TRANS_JOIN: ::std::os::raw::c_uint = 2;
pub const OCI_TRANS_RESUME: ::std::os::raw::c_uint = 4;
pub const OCI_TRANS_PROMOTE: ::std::os::raw::c_uint = 8;
pub const OCI_TRANS_STARTMASK: ::std::os::raw::c_uint = 255;
pub const OCI_TRANS_READONLY: ::std::os::raw::c_uint = 256;
pub const OCI_TRANS_READWRITE: ::std::os::raw::c_uint = 512;
pub const OCI_TRANS_SERIALIZABLE: ::std::os::raw::c_uint = 1024;
pub const OCI_TRANS_ISOLMASK: ::std::os::raw::c_uint = 65280;
pub const OCI_TRANS_LOOSE: ::std::os::raw::c_uint = 65536;
pub const OCI_TRANS_TIGHT: ::std::os::raw::c_uint = 131072;
pub const OCI_TRANS_TYPEMASK: ::std::os::raw::c_uint = 983040;
pub const OCI_TRANS_NOMIGRATE: ::std::os::raw::c_uint = 1048576;
pub const OCI_TRANS_SEPARABLE: ::std::os::raw::c_uint = 2097152;
pub const OCI_TRANS_OTSRESUME: ::std::os::raw::c_uint = 4194304;
pub const OCI_TRANS_OTHRMASK: ::std::os::raw::c_uint = 4293918720;
pub const OCI_TRANS_TWOPHASE: ::std::os::raw::c_uint = 16777216;
pub const OCI_TRANS_WRITEBATCH: ::std::os::raw::c_uint = 1;
pub const OCI_TRANS_WRITEIMMED: ::std::os::raw::c_uint = 2;
pub const OCI_TRANS_WRITEWAIT: ::std::os::raw::c_uint = 4;
pub const OCI_TRANS_WRITENOWAIT: ::std::os::raw::c_uint = 8;
pub const OCI_ENQ_IMMEDIATE: ::std::os::raw::c_uint = 1;
pub const OCI_ENQ_ON_COMMIT: ::std::os::raw::c_uint = 2;
pub const OCI_DEQ_BROWSE: ::std::os::raw::c_uint = 1;
pub const OCI_DEQ_LOCKED: ::std::os::raw::c_uint = 2;
pub const OCI_DEQ_REMOVE: ::std::os::raw::c_uint = 3;
pub const OCI_DEQ_REMOVE_NODATA: ::std::os::raw::c_uint = 4;
pub const OCI_DEQ_GETSIG: ::std::os::raw::c_uint = 5;
pub const OCI_DEQ_FIRST_MSG: ::std::os::raw::c_uint = 1;
pub const OCI_DEQ_NEXT_MSG: ::std::os::raw::c_uint = 3;
pub const OCI_DEQ_NEXT_TRANSACTION: ::std::os::raw::c_uint = 2;
pub const OCI_DEQ_FIRST_MSG_MULTI_GROUP: ::std::os::raw::c_uint = 4;
pub const OCI_DEQ_MULT_TRANSACTION: ::std::os::raw::c_uint = 5;
pub const OCI_DEQ_NEXT_MSG_MULTI_GROUP: ::std::os::raw::c_uint = 5;
pub const OCI_DEQ_RESERVED_1: ::std::os::raw::c_uint = 1;
pub const OCI_MSG_WAITING: ::std::os::raw::c_uint = 1;
pub const OCI_MSG_READY: ::std::os::raw::c_uint = 0;
pub const OCI_MSG_PROCESSED: ::std::os::raw::c_uint = 2;
pub const OCI_MSG_EXPIRED: ::std::os::raw::c_uint = 3;
pub const OCI_ENQ_BEFORE: ::std::os::raw::c_uint = 2;
pub const OCI_ENQ_TOP: ::std::os::raw::c_uint = 3;
pub const OCI_DEQ_IMMEDIATE: ::std::os::raw::c_uint = 1;
pub const OCI_DEQ_ON_COMMIT: ::std::os::raw::c_uint = 2;
pub const OCI_DEQ_WAIT_FOREVER: ::std::os::raw::c_int = -1;
pub const OCI_NTFN_GROUPING_FOREVER: ::std::os::raw::c_int = -1;
pub const OCI_DEQ_NO_WAIT: ::std::os::raw::c_uint = 0;
pub const OCI_FLOW_CONTROL_NO_TIMEOUT: ::std::os::raw::c_int = -1;
pub const OCI_MSG_NO_DELAY: ::std::os::raw::c_uint = 0;
pub const OCI_MSG_NO_EXPIRATION: ::std::os::raw::c_int = -1;
pub const OCI_MSG_PERSISTENT_OR_BUFFERED: ::std::os::raw::c_uint = 3;
pub const OCI_MSG_BUFFERED: ::std::os::raw::c_uint = 2;
pub const OCI_MSG_PERSISTENT: ::std::os::raw::c_uint = 1;
pub const OCI_AQ_RESERVED_1: ::std::os::raw::c_uint = 2;
pub const OCI_AQ_RESERVED_2: ::std::os::raw::c_uint = 4;
pub const OCI_AQ_RESERVED_3: ::std::os::raw::c_uint = 8;
pub const OCI_AQ_RESERVED_4: ::std::os::raw::c_uint = 16;
pub const OCI_AQ_STREAMING_FLAG: ::std::os::raw::c_uint = 33554432;
pub const OCI_AQJMS_RAW_MSG: ::std::os::raw::c_uint = 1;
pub const OCI_AQJMS_TEXT_MSG: ::std::os::raw::c_uint = 2;
pub const OCI_AQJMS_MAP_MSG: ::std::os::raw::c_uint = 4;
pub const OCI_AQJMS_BYTE_MSG: ::std::os::raw::c_uint = 8;
pub const OCI_AQJMS_STREAM_MSG: ::std::os::raw::c_uint = 16;
pub const OCI_AQJMS_ADT_MSG: ::std::os::raw::c_uint = 32;
pub const OCI_AQMSG_FIRST_CHUNK: ::std::os::raw::c_uint = 1;
pub const OCI_AQMSG_NEXT_CHUNK: ::std::os::raw::c_uint = 2;
pub const OCI_AQMSG_LAST_CHUNK: ::std::os::raw::c_uint = 4;
pub const OCI_AQ_LAST_ENQUEUED: ::std::os::raw::c_uint = 0;
pub const OCI_AQ_LAST_ACKNOWLEDGED: ::std::os::raw::c_uint = 1;
pub const OCI_OTYPE_UNK: ::std::os::raw::c_uint = 0;
pub const OCI_OTYPE_TABLE: ::std::os::raw::c_uint = 1;
pub const OCI_OTYPE_VIEW: ::std::os::raw::c_uint = 2;
pub const OCI_OTYPE_SYN: ::std::os::raw::c_uint = 3;
pub const OCI_OTYPE_PROC: ::std::os::raw::c_uint = 4;
pub const OCI_OTYPE_FUNC: ::std::os::raw::c_uint = 5;
pub const OCI_OTYPE_PKG: ::std::os::raw::c_uint = 6;
pub const OCI_OTYPE_STMT: ::std::os::raw::c_uint = 7;
pub const OCI_ATTR_DATA_SIZE: ::std::os::raw::c_uint = 1;
pub const OCI_ATTR_DATA_TYPE: ::std::os::raw::c_uint = 2;
pub const OCI_ATTR_DISP_SIZE: ::std::os::raw::c_uint = 3;
pub const OCI_ATTR_NAME: ::std::os::raw::c_uint = 4;
pub const OCI_ATTR_PRECISION: ::std::os::raw::c_uint = 5;
pub const OCI_ATTR_SCALE: ::std::os::raw::c_uint = 6;
pub const OCI_ATTR_IS_NULL: ::std::os::raw::c_uint = 7;
pub const OCI_ATTR_TYPE_NAME: ::std::os::raw::c_uint = 8;
pub const OCI_ATTR_SCHEMA_NAME: ::std::os::raw::c_uint = 9;
pub const OCI_ATTR_SUB_NAME: ::std::os::raw::c_uint = 10;
pub const OCI_ATTR_POSITION: ::std::os::raw::c_uint = 11;
pub const OCI_ATTR_PACKAGE_NAME: ::std::os::raw::c_uint = 12;
pub const OCI_ATTR_COMPLEXOBJECTCOMP_TYPE: ::std::os::raw::c_uint = 50;
pub const OCI_ATTR_COMPLEXOBJECTCOMP_TYPE_LEVEL: ::std::os::raw::c_uint = 51;
pub const OCI_ATTR_COMPLEXOBJECT_LEVEL: ::std::os::raw::c_uint = 52;
pub const OCI_ATTR_COMPLEXOBJECT_COLL_OUTOFLINE: ::std::os::raw::c_uint = 53;
pub const OCI_ATTR_DISP_NAME: ::std::os::raw::c_uint = 100;
pub const OCI_ATTR_ENCC_SIZE: ::std::os::raw::c_uint = 101;
pub const OCI_ATTR_COL_ENC: ::std::os::raw::c_uint = 102;
pub const OCI_ATTR_COL_ENC_SALT: ::std::os::raw::c_uint = 103;
pub const OCI_ATTR_COL_PROPERTIES: ::std::os::raw::c_uint = 104;
pub const OCI_ATTR_COL_PROPERTY_IS_IDENTITY: ::std::os::raw::c_uint = 1;
pub const OCI_ATTR_COL_PROPERTY_IS_GEN_ALWAYS: ::std::os::raw::c_uint = 2;
pub const OCI_ATTR_COL_PROPERTY_IS_GEN_BY_DEF_ON_NULL: ::std::os::raw::c_uint = 4;
pub const OCI_ATTR_OVERLOAD: ::std::os::raw::c_uint = 210;
pub const OCI_ATTR_LEVEL: ::std::os::raw::c_uint = 211;
pub const OCI_ATTR_HAS_DEFAULT: ::std::os::raw::c_uint = 212;
pub const OCI_ATTR_IOMODE: ::std::os::raw::c_uint = 213;
pub const OCI_ATTR_RADIX: ::std::os::raw::c_uint = 214;
pub const OCI_ATTR_NUM_ARGS: ::std::os::raw::c_uint = 215;
pub const OCI_ATTR_TYPECODE: ::std::os::raw::c_uint = 216;
pub const OCI_ATTR_COLLECTION_TYPECODE: ::std::os::raw::c_uint = 217;
pub const OCI_ATTR_VERSION: ::std::os::raw::c_uint = 218;
pub const OCI_ATTR_IS_INCOMPLETE_TYPE: ::std::os::raw::c_uint = 219;
pub const OCI_ATTR_IS_SYSTEM_TYPE: ::std::os::raw::c_uint = 220;
pub const OCI_ATTR_IS_PREDEFINED_TYPE: ::std::os::raw::c_uint = 221;
pub const OCI_ATTR_IS_TRANSIENT_TYPE: ::std::os::raw::c_uint = 222;
pub const OCI_ATTR_IS_SYSTEM_GENERATED_TYPE: ::std::os::raw::c_uint = 223;
pub const OCI_ATTR_HAS_NESTED_TABLE: ::std::os::raw::c_uint = 224;
pub const OCI_ATTR_HAS_LOB: ::std::os::raw::c_uint = 225;
pub const OCI_ATTR_HAS_FILE: ::std::os::raw::c_uint = 226;
pub const OCI_ATTR_COLLECTION_ELEMENT: ::std::os::raw::c_uint = 227;
pub const OCI_ATTR_NUM_TYPE_ATTRS: ::std::os::raw::c_uint = 228;
pub const OCI_ATTR_LIST_TYPE_ATTRS: ::std::os::raw::c_uint = 229;
pub const OCI_ATTR_NUM_TYPE_METHODS: ::std::os::raw::c_uint = 230;
pub const OCI_ATTR_LIST_TYPE_METHODS: ::std::os::raw::c_uint = 231;
pub const OCI_ATTR_MAP_METHOD: ::std::os::raw::c_uint = 232;
pub const OCI_ATTR_ORDER_METHOD: ::std::os::raw::c_uint = 233;
pub const OCI_ATTR_NUM_ELEMS: ::std::os::raw::c_uint = 234;
pub const OCI_ATTR_ENCAPSULATION: ::std::os::raw::c_uint = 235;
pub const OCI_ATTR_IS_SELFISH: ::std::os::raw::c_uint = 236;
pub const OCI_ATTR_IS_VIRTUAL: ::std::os::raw::c_uint = 237;
pub const OCI_ATTR_IS_INLINE: ::std::os::raw::c_uint = 238;
pub const OCI_ATTR_IS_CONSTANT: ::std::os::raw::c_uint = 239;
pub const OCI_ATTR_HAS_RESULT: ::std::os::raw::c_uint = 240;
pub const OCI_ATTR_IS_CONSTRUCTOR: ::std::os::raw::c_uint = 241;
pub const OCI_ATTR_IS_DESTRUCTOR: ::std::os::raw::c_uint = 242;
pub const OCI_ATTR_IS_OPERATOR: ::std::os::raw::c_uint = 243;
pub const OCI_ATTR_IS_MAP: ::std::os::raw::c_uint = 244;
pub const OCI_ATTR_IS_ORDER: ::std::os::raw::c_uint = 245;
pub const OCI_ATTR_IS_RNDS: ::std::os::raw::c_uint = 246;
pub const OCI_ATTR_IS_RNPS: ::std::os::raw::c_uint = 247;
pub const OCI_ATTR_IS_WNDS: ::std::os::raw::c_uint = 248;
pub const OCI_ATTR_IS_WNPS: ::std::os::raw::c_uint = 249;
pub const OCI_ATTR_DESC_PUBLIC: ::std::os::raw::c_uint = 250;
pub const OCI_ATTR_CACHE_CLIENT_CONTEXT: ::std::os::raw::c_uint = 251;
pub const OCI_ATTR_UCI_CONSTRUCT: ::std::os::raw::c_uint = 252;
pub const OCI_ATTR_UCI_DESTRUCT: ::std::os::raw::c_uint = 253;
pub const OCI_ATTR_UCI_COPY: ::std::os::raw::c_uint = 254;
pub const OCI_ATTR_UCI_PICKLE: ::std::os::raw::c_uint = 255;
pub const OCI_ATTR_UCI_UNPICKLE: ::std::os::raw::c_uint = 256;
pub const OCI_ATTR_UCI_REFRESH: ::std::os::raw::c_uint = 257;
pub const OCI_ATTR_IS_SUBTYPE: ::std::os::raw::c_uint = 258;
pub const OCI_ATTR_SUPERTYPE_SCHEMA_NAME: ::std::os::raw::c_uint = 259;
pub const OCI_ATTR_SUPERTYPE_NAME: ::std::os::raw::c_uint = 260;
pub const OCI_ATTR_LIST_OBJECTS: ::std::os::raw::c_uint = 261;
pub const OCI_ATTR_NCHARSET_ID: ::std::os::raw::c_uint = 262;
pub const OCI_ATTR_LIST_SCHEMAS: ::std::os::raw::c_uint = 263;
pub const OCI_ATTR_MAX_PROC_LEN: ::std::os::raw::c_uint = 264;
pub const OCI_ATTR_MAX_COLUMN_LEN: ::std::os::raw::c_uint = 265;
pub const OCI_ATTR_CURSOR_COMMIT_BEHAVIOR: ::std::os::raw::c_uint = 266;
pub const OCI_ATTR_MAX_CATALOG_NAMELEN: ::std::os::raw::c_uint = 267;
pub const OCI_ATTR_CATALOG_LOCATION: ::std::os::raw::c_uint = 268;
pub const OCI_ATTR_SAVEPOINT_SUPPORT: ::std::os::raw::c_uint = 269;
pub const OCI_ATTR_NOWAIT_SUPPORT: ::std::os::raw::c_uint = 270;
pub const OCI_ATTR_AUTOCOMMIT_DDL: ::std::os::raw::c_uint = 271;
pub const OCI_ATTR_LOCKING_MODE: ::std::os::raw::c_uint = 272;
pub const OCI_ATTR_APPCTX_SIZE: ::std::os::raw::c_uint = 273;
pub const OCI_ATTR_APPCTX_LIST: ::std::os::raw::c_uint = 274;
pub const OCI_ATTR_APPCTX_NAME: ::std::os::raw::c_uint = 275;
pub const OCI_ATTR_APPCTX_ATTR: ::std::os::raw::c_uint = 276;
pub const OCI_ATTR_APPCTX_VALUE: ::std::os::raw::c_uint = 277;
pub const OCI_ATTR_CLIENT_IDENTIFIER: ::std::os::raw::c_uint = 278;
pub const OCI_ATTR_IS_FINAL_TYPE: ::std::os::raw::c_uint = 279;
pub const OCI_ATTR_IS_INSTANTIABLE_TYPE: ::std::os::raw::c_uint = 280;
pub const OCI_ATTR_IS_FINAL_METHOD: ::std::os::raw::c_uint = 281;
pub const OCI_ATTR_IS_INSTANTIABLE_METHOD: ::std::os::raw::c_uint = 282;
pub const OCI_ATTR_IS_OVERRIDING_METHOD: ::std::os::raw::c_uint = 283;
pub const OCI_ATTR_DESC_SYNBASE: ::std::os::raw::c_uint = 284;
pub const OCI_ATTR_CHAR_USED: ::std::os::raw::c_uint = 285;
pub const OCI_ATTR_CHAR_SIZE: ::std::os::raw::c_uint = 286;
pub const OCI_ATTR_IS_JAVA_TYPE: ::std::os::raw::c_uint = 287;
pub const OCI_ATTR_DISTINGUISHED_NAME: ::std::os::raw::c_uint = 300;
pub const OCI_ATTR_KERBEROS_TICKET: ::std::os::raw::c_uint = 301;
pub const OCI_ATTR_ORA_DEBUG_JDWP: ::std::os::raw::c_uint = 302;
pub const OCI_ATTR_EDITION: ::std::os::raw::c_uint = 288;
pub const OCI_ATTR_RESERVED_14: ::std::os::raw::c_uint = 303;
pub const OCI_ATTR_SPOOL_TIMEOUT: ::std::os::raw::c_uint = 308;
pub const OCI_ATTR_SPOOL_GETMODE: ::std::os::raw::c_uint = 309;
pub const OCI_ATTR_SPOOL_BUSY_COUNT: ::std::os::raw::c_uint = 310;
pub const OCI_ATTR_SPOOL_OPEN_COUNT: ::std::os::raw::c_uint = 311;
pub const OCI_ATTR_SPOOL_MIN: ::std::os::raw::c_uint = 312;
pub const OCI_ATTR_SPOOL_MAX: ::std::os::raw::c_uint = 313;
pub const OCI_ATTR_SPOOL_INCR: ::std::os::raw::c_uint = 314;
pub const OCI_ATTR_SPOOL_STMTCACHESIZE: ::std::os::raw::c_uint = 208;
pub const OCI_ATTR_SPOOL_AUTH: ::std::os::raw::c_uint = 460;
pub const OCI_ATTR_IS_XMLTYPE: ::std::os::raw::c_uint = 315;
pub const OCI_ATTR_XMLSCHEMA_NAME: ::std::os::raw::c_uint = 316;
pub const OCI_ATTR_XMLELEMENT_NAME: ::std::os::raw::c_uint = 317;
pub const OCI_ATTR_XMLSQLTYPSCH_NAME: ::std::os::raw::c_uint = 318;
pub const OCI_ATTR_XMLSQLTYPE_NAME: ::std::os::raw::c_uint = 319;
pub const OCI_ATTR_XMLTYPE_STORED_OBJ: ::std::os::raw::c_uint = 320;
pub const OCI_ATTR_XMLTYPE_BINARY_XML: ::std::os::raw::c_uint = 422;
pub const OCI_ATTR_HAS_SUBTYPES: ::std::os::raw::c_uint = 321;
pub const OCI_ATTR_NUM_SUBTYPES: ::std::os::raw::c_uint = 322;
pub const OCI_ATTR_LIST_SUBTYPES: ::std::os::raw::c_uint = 323;
pub const OCI_ATTR_XML_HRCHY_ENABLED: ::std::os::raw::c_uint = 324;
pub const OCI_ATTR_IS_OVERRIDDEN_METHOD: ::std::os::raw::c_uint = 325;
pub const OCI_ATTR_OBJ_SUBS: ::std::os::raw::c_uint = 336;
pub const OCI_ATTR_XADFIELD_RESERVED_1: ::std::os::raw::c_uint = 339;
pub const OCI_ATTR_XADFIELD_RESERVED_2: ::std::os::raw::c_uint = 340;
pub const OCI_ATTR_KERBEROS_CID: ::std::os::raw::c_uint = 341;
pub const OCI_ATTR_CONDITION: ::std::os::raw::c_uint = 342;
pub const OCI_ATTR_COMMENT: ::std::os::raw::c_uint = 343;
pub const OCI_ATTR_VALUE: ::std::os::raw::c_uint = 344;
pub const OCI_ATTR_EVAL_CONTEXT_OWNER: ::std::os::raw::c_uint = 345;
pub const OCI_ATTR_EVAL_CONTEXT_NAME: ::std::os::raw::c_uint = 346;
pub const OCI_ATTR_EVALUATION_FUNCTION: ::std::os::raw::c_uint = 347;
pub const OCI_ATTR_VAR_TYPE: ::std::os::raw::c_uint = 348;
pub const OCI_ATTR_VAR_VALUE_FUNCTION: ::std::os::raw::c_uint = 349;
pub const OCI_ATTR_VAR_METHOD_FUNCTION: ::std::os::raw::c_uint = 350;
pub const OCI_ATTR_ACTION_CONTEXT: ::std::os::raw::c_uint = 351;
pub const OCI_ATTR_LIST_TABLE_ALIASES: ::std::os::raw::c_uint = 352;
pub const OCI_ATTR_LIST_VARIABLE_TYPES: ::std::os::raw::c_uint = 353;
pub const OCI_ATTR_TABLE_NAME: ::std::os::raw::c_uint = 356;
pub const OCI_ATTR_MESSAGE_CSCN: ::std::os::raw::c_uint = 360;
pub const OCI_ATTR_MESSAGE_DSCN: ::std::os::raw::c_uint = 361;
pub const OCI_ATTR_AUDIT_SESSION_ID: ::std::os::raw::c_uint = 362;
pub const OCI_ATTR_KERBEROS_KEY: ::std::os::raw::c_uint = 363;
pub const OCI_ATTR_KERBEROS_CID_KEY: ::std::os::raw::c_uint = 364;
pub const OCI_ATTR_TRANSACTION_NO: ::std::os::raw::c_uint = 365;
pub const OCI_ATTR_MODULE: ::std::os::raw::c_uint = 366;
pub const OCI_ATTR_ACTION: ::std::os::raw::c_uint = 367;
pub const OCI_ATTR_CLIENT_INFO: ::std::os::raw::c_uint = 368;
pub const OCI_ATTR_COLLECT_CALL_TIME: ::std::os::raw::c_uint = 369;
pub const OCI_ATTR_CALL_TIME: ::std::os::raw::c_uint = 370;
pub const OCI_ATTR_ECONTEXT_ID: ::std::os::raw::c_uint = 371;
pub const OCI_ATTR_ECONTEXT_SEQ: ::std::os::raw::c_uint = 372;
pub const OCI_ATTR_SESSION_STATE: ::std::os::raw::c_uint = 373;
pub const OCI_SESSION_STATELESS: ::std::os::raw::c_uint = 1;
pub const OCI_SESSION_STATEFUL: ::std::os::raw::c_uint = 2;
pub const OCI_ATTR_SESSION_STATETYPE: ::std::os::raw::c_uint = 374;
pub const OCI_SESSION_STATELESS_DEF: ::std::os::raw::c_uint = 0;
pub const OCI_SESSION_STATELESS_CAL: ::std::os::raw::c_uint = 1;
pub const OCI_SESSION_STATELESS_TXN: ::std::os::raw::c_uint = 2;
pub const OCI_SESSION_STATELESS_APP: ::std::os::raw::c_uint = 3;
pub const OCI_ATTR_SESSION_STATE_CLEARED: ::std::os::raw::c_uint = 376;
pub const OCI_ATTR_SESSION_MIGRATED: ::std::os::raw::c_uint = 377;
pub const OCI_ATTR_SESSION_PRESERVE_STATE: ::std::os::raw::c_uint = 388;
pub const OCI_ATTR_DRIVER_NAME: ::std::os::raw::c_uint = 424;
pub const OCI_ATTR_ADMIN_PFILE: ::std::os::raw::c_uint = 389;
pub const OCI_ATTR_HOSTNAME: ::std::os::raw::c_uint = 390;
pub const OCI_ATTR_DBNAME: ::std::os::raw::c_uint = 391;
pub const OCI_ATTR_INSTNAME: ::std::os::raw::c_uint = 392;
pub const OCI_ATTR_SERVICENAME: ::std::os::raw::c_uint = 393;
pub const OCI_ATTR_INSTSTARTTIME: ::std::os::raw::c_uint = 394;
pub const OCI_ATTR_HA_TIMESTAMP: ::std::os::raw::c_uint = 395;
pub const OCI_ATTR_RESERVED_22: ::std::os::raw::c_uint = 396;
pub const OCI_ATTR_RESERVED_23: ::std::os::raw::c_uint = 397;
pub const OCI_ATTR_RESERVED_24: ::std::os::raw::c_uint = 398;
pub const OCI_ATTR_DBDOMAIN: ::std::os::raw::c_uint = 399;
pub const OCI_ATTR_RESERVED_27: ::std::os::raw::c_uint = 425;
pub const OCI_ATTR_EVENTTYPE: ::std::os::raw::c_uint = 400;
pub const OCI_EVENTTYPE_HA: ::std::os::raw::c_uint = 0;
pub const OCI_ATTR_HA_SOURCE: ::std::os::raw::c_uint = 401;
pub const OCI_HA_SOURCE_INSTANCE: ::std::os::raw::c_uint = 0;
pub const OCI_HA_SOURCE_DATABASE: ::std::os::raw::c_uint = 1;
pub const OCI_HA_SOURCE_NODE: ::std::os::raw::c_uint = 2;
pub const OCI_HA_SOURCE_SERVICE: ::std::os::raw::c_uint = 3;
pub const OCI_HA_SOURCE_SERVICE_MEMBER: ::std::os::raw::c_uint = 4;
pub const OCI_HA_SOURCE_ASM_INSTANCE: ::std::os::raw::c_uint = 5;
pub const OCI_HA_SOURCE_SERVICE_PRECONNECT: ::std::os::raw::c_uint = 6;
pub const OCI_ATTR_HA_STATUS: ::std::os::raw::c_uint = 402;
pub const OCI_HA_STATUS_DOWN: ::std::os::raw::c_uint = 0;
pub const OCI_HA_STATUS_UP: ::std::os::raw::c_uint = 1;
pub const OCI_ATTR_HA_SRVFIRST: ::std::os::raw::c_uint = 403;
pub const OCI_ATTR_HA_SRVNEXT: ::std::os::raw::c_uint = 404;
pub const OCI_ATTR_TAF_ENABLED: ::std::os::raw::c_uint = 405;
pub const OCI_ATTR_NFY_FLAGS: ::std::os::raw::c_uint = 406;
pub const OCI_ATTR_MSG_DELIVERY_MODE: ::std::os::raw::c_uint = 407;
pub const OCI_ATTR_DB_CHARSET_ID: ::std::os::raw::c_uint = 416;
pub const OCI_ATTR_DB_NCHARSET_ID: ::std::os::raw::c_uint = 417;
pub const OCI_ATTR_RESERVED_25: ::std::os::raw::c_uint = 418;
pub const OCI_ATTR_FLOW_CONTROL_TIMEOUT: ::std::os::raw::c_uint = 423;
pub const OCI_ATTR_ENV_NLS_LANGUAGE: ::std::os::raw::c_uint = 424;
pub const OCI_ATTR_ENV_NLS_TERRITORY: ::std::os::raw::c_uint = 425;
pub const OCI_DIRPATH_STREAM_VERSION_1: ::std::os::raw::c_uint = 100;
pub const OCI_DIRPATH_STREAM_VERSION_2: ::std::os::raw::c_uint = 200;
pub const OCI_DIRPATH_STREAM_VERSION_3: ::std::os::raw::c_uint = 300;
pub const OCI_ATTR_DIRPATH_MODE: ::std::os::raw::c_uint = 78;
pub const OCI_ATTR_DIRPATH_NOLOG: ::std::os::raw::c_uint = 79;
pub const OCI_ATTR_DIRPATH_PARALLEL: ::std::os::raw::c_uint = 80;
pub const OCI_ATTR_DIRPATH_SORTED_INDEX: ::std::os::raw::c_uint = 137;
pub const OCI_ATTR_DIRPATH_INDEX_MAINT_METHOD: ::std::os::raw::c_uint = 138;
pub const OCI_ATTR_DIRPATH_FILE: ::std::os::raw::c_uint = 139;
pub const OCI_ATTR_DIRPATH_STORAGE_INITIAL: ::std::os::raw::c_uint = 140;
pub const OCI_ATTR_DIRPATH_STORAGE_NEXT: ::std::os::raw::c_uint = 141;
pub const OCI_ATTR_DIRPATH_SKIPINDEX_METHOD: ::std::os::raw::c_uint = 145;
pub const OCI_ATTR_DIRPATH_EXPR_TYPE: ::std::os::raw::c_uint = 150;
pub const OCI_ATTR_DIRPATH_INPUT: ::std::os::raw::c_uint = 151;
pub const OCI_DIRPATH_INPUT_TEXT: ::std::os::raw::c_uint = 1;
pub const OCI_DIRPATH_INPUT_STREAM: ::std::os::raw::c_uint = 2;
pub const OCI_DIRPATH_INPUT_OCI: ::std::os::raw::c_uint = 4;
pub const OCI_DIRPATH_INPUT_UNKNOWN: ::std::os::raw::c_uint = 8;
pub const OCI_ATTR_DIRPATH_FN_CTX: ::std::os::raw::c_uint = 167;
pub const OCI_ATTR_DIRPATH_OID: ::std::os::raw::c_uint = 187;
pub const OCI_ATTR_DIRPATH_SID: ::std::os::raw::c_uint = 194;
pub const OCI_ATTR_DIRPATH_OBJ_CONSTR: ::std::os::raw::c_uint = 206;
pub const OCI_ATTR_DIRPATH_STREAM_VERSION: ::std::os::raw::c_uint = 212;
pub const OCIP_ATTR_DIRPATH_VARRAY_INDEX: ::std::os::raw::c_uint = 213;
pub const OCI_ATTR_DIRPATH_DCACHE_NUM: ::std::os::raw::c_uint = 303;
pub const OCI_ATTR_DIRPATH_DCACHE_SIZE: ::std::os::raw::c_uint = 304;
pub const OCI_ATTR_DIRPATH_DCACHE_MISSES: ::std::os::raw::c_uint = 305;
pub const OCI_ATTR_DIRPATH_DCACHE_HITS: ::std::os::raw::c_uint = 306;
pub const OCI_ATTR_DIRPATH_DCACHE_DISABLE: ::std::os::raw::c_uint = 307;
pub const OCI_ATTR_DIRPATH_RESERVED_7: ::std::os::raw::c_uint = 326;
pub const OCI_ATTR_DIRPATH_RESERVED_8: ::std::os::raw::c_uint = 327;
pub const OCI_ATTR_DIRPATH_CONVERT: ::std::os::raw::c_uint = 328;
pub const OCI_ATTR_DIRPATH_BADROW: ::std::os::raw::c_uint = 329;
pub const OCI_ATTR_DIRPATH_BADROW_LENGTH: ::std::os::raw::c_uint = 330;
pub const OCI_ATTR_DIRPATH_WRITE_ORDER: ::std::os::raw::c_uint = 331;
pub const OCI_ATTR_DIRPATH_GRANULE_SIZE: ::std::os::raw::c_uint = 332;
pub const OCI_ATTR_DIRPATH_GRANULE_OFFSET: ::std::os::raw::c_uint = 333;
pub const OCI_ATTR_DIRPATH_RESERVED_1: ::std::os::raw::c_uint = 334;
pub const OCI_ATTR_DIRPATH_RESERVED_2: ::std::os::raw::c_uint = 335;
pub const OCI_ATTR_DIRPATH_RESERVED_3: ::std::os::raw::c_uint = 337;
pub const OCI_ATTR_DIRPATH_RESERVED_4: ::std::os::raw::c_uint = 338;
pub const OCI_ATTR_DIRPATH_RESERVED_5: ::std::os::raw::c_uint = 357;
pub const OCI_ATTR_DIRPATH_RESERVED_6: ::std::os::raw::c_uint = 358;
pub const OCI_ATTR_DIRPATH_LOCK_WAIT: ::std::os::raw::c_uint = 359;
pub const OCI_CURSOR_OPEN: ::std::os::raw::c_uint = 0;
pub const OCI_CURSOR_CLOSED: ::std::os::raw::c_uint = 1;
pub const OCI_CL_START: ::std::os::raw::c_uint = 0;
pub const OCI_CL_END: ::std::os::raw::c_uint = 1;
pub const OCI_SP_SUPPORTED: ::std::os::raw::c_uint = 0;
pub const OCI_SP_UNSUPPORTED: ::std::os::raw::c_uint = 1;
pub const OCI_NW_SUPPORTED: ::std::os::raw::c_uint = 0;
pub const OCI_NW_UNSUPPORTED: ::std::os::raw::c_uint = 1;
pub const OCI_AC_DDL: ::std::os::raw::c_uint = 0;
pub const OCI_NO_AC_DDL: ::std::os::raw::c_uint = 1;
pub const OCI_LOCK_IMMEDIATE: ::std::os::raw::c_uint = 0;
pub const OCI_LOCK_DELAYED: ::std::os::raw::c_uint = 1;
pub const OCI_INSTANCE_TYPE_UNKNOWN: ::std::os::raw::c_uint = 0;
pub const OCI_INSTANCE_TYPE_RDBMS: ::std::os::raw::c_uint = 1;
pub const OCI_INSTANCE_TYPE_OSM: ::std::os::raw::c_uint = 2;
pub const OCI_INSTANCE_TYPE_PROXY: ::std::os::raw::c_uint = 3;
pub const OCI_INSTANCE_TYPE_IOS: ::std::os::raw::c_uint = 4;
pub const OCI_ASM_VOLUME_UNSUPPORTED: ::std::os::raw::c_uint = 0;
pub const OCI_ASM_VOLUME_SUPPORTED: ::std::os::raw::c_uint = 1;
pub const OCI_AUTH: ::std::os::raw::c_uint = 8;
pub const OCI_MAX_FNS: ::std::os::raw::c_uint = 100;
pub const OCI_SQLSTATE_SIZE: ::std::os::raw::c_uint = 5;
pub const OCI_ERROR_MAXMSG_SIZE: ::std::os::raw::c_uint = 1024;
pub const OCI_ERROR_MAXMSG_SIZE2: ::std::os::raw::c_uint = 3072;
pub const OCI_ROWID_LEN: ::std::os::raw::c_uint = 23;
pub const OCI_LOB_CONTENTTYPE_MAXSIZE: ::std::os::raw::c_uint = 128;
pub const OCI_LOB_CONTENTTYPE_MAXBYTESIZE: ::std::os::raw::c_uint = 128;
pub const OCI_FO_END: ::std::os::raw::c_uint = 1;
pub const OCI_FO_ABORT: ::std::os::raw::c_uint = 2;
pub const OCI_FO_REAUTH: ::std::os::raw::c_uint = 4;
pub const OCI_FO_BEGIN: ::std::os::raw::c_uint = 8;
pub const OCI_FO_ERROR: ::std::os::raw::c_uint = 16;
pub const OCI_FO_RETRY: ::std::os::raw::c_uint = 25410;
pub const OCI_FO_NONE: ::std::os::raw::c_uint = 1;
pub const OCI_FO_SESSION: ::std::os::raw::c_uint = 2;
pub const OCI_FO_SELECT: ::std::os::raw::c_uint = 4;
pub const OCI_FO_TXNAL: ::std::os::raw::c_uint = 8;
pub const OCI_ATTR_MAXLEN_COMPAT_STANDARD: ::std::os::raw::c_uint = 1;
pub const OCI_ATTR_MAXLEN_COMPAT_EXTENDED: ::std::os::raw::c_uint = 2;
pub const OCI_FNCODE_INITIALIZE: ::std::os::raw::c_uint = 1;
pub const OCI_FNCODE_HANDLEALLOC: ::std::os::raw::c_uint = 2;
pub const OCI_FNCODE_HANDLEFREE: ::std::os::raw::c_uint = 3;
pub const OCI_FNCODE_DESCRIPTORALLOC: ::std::os::raw::c_uint = 4;
pub const OCI_FNCODE_DESCRIPTORFREE: ::std::os::raw::c_uint = 5;
pub const OCI_FNCODE_ENVINIT: ::std::os::raw::c_uint = 6;
pub const OCI_FNCODE_SERVERATTACH: ::std::os::raw::c_uint = 7;
pub const OCI_FNCODE_SERVERDETACH: ::std::os::raw::c_uint = 8;
pub const OCI_FNCODE_SESSIONBEGIN: ::std::os::raw::c_uint = 10;
pub const OCI_FNCODE_SESSIONEND: ::std::os::raw::c_uint = 11;
pub const OCI_FNCODE_PASSWORDCHANGE: ::std::os::raw::c_uint = 12;
pub const OCI_FNCODE_STMTPREPARE: ::std::os::raw::c_uint = 13;
pub const OCI_FNCODE_BINDDYNAMIC: ::std::os::raw::c_uint = 17;
pub const OCI_FNCODE_BINDOBJECT: ::std::os::raw::c_uint = 18;
pub const OCI_FNCODE_BINDARRAYOFSTRUCT: ::std::os::raw::c_uint = 20;
pub const OCI_FNCODE_STMTEXECUTE: ::std::os::raw::c_uint = 21;
pub const OCI_FNCODE_DEFINEOBJECT: ::std::os::raw::c_uint = 25;
pub const OCI_FNCODE_DEFINEDYNAMIC: ::std::os::raw::c_uint = 26;
pub const OCI_FNCODE_DEFINEARRAYOFSTRUCT: ::std::os::raw::c_uint = 27;
pub const OCI_FNCODE_STMTFETCH: ::std::os::raw::c_uint = 28;
pub const OCI_FNCODE_STMTGETBIND: ::std::os::raw::c_uint = 29;
pub const OCI_FNCODE_DESCRIBEANY: ::std::os::raw::c_uint = 32;
pub const OCI_FNCODE_TRANSSTART: ::std::os::raw::c_uint = 33;
pub const OCI_FNCODE_TRANSDETACH: ::std::os::raw::c_uint = 34;
pub const OCI_FNCODE_TRANSCOMMIT: ::std::os::raw::c_uint = 35;
pub const OCI_FNCODE_ERRORGET: ::std::os::raw::c_uint = 37;
pub const OCI_FNCODE_LOBOPENFILE: ::std::os::raw::c_uint = 38;
pub const OCI_FNCODE_LOBCLOSEFILE: ::std::os::raw::c_uint = 39;
pub const OCI_FNCODE_LOBCOPY: ::std::os::raw::c_uint = 42;
pub const OCI_FNCODE_LOBAPPEND: ::std::os::raw::c_uint = 43;
pub const OCI_FNCODE_LOBERASE: ::std::os::raw::c_uint = 44;
pub const OCI_FNCODE_LOBLENGTH: ::std::os::raw::c_uint = 45;
pub const OCI_FNCODE_LOBTRIM: ::std::os::raw::c_uint = 46;
pub const OCI_FNCODE_LOBREAD: ::std::os::raw::c_uint = 47;
pub const OCI_FNCODE_LOBWRITE: ::std::os::raw::c_uint = 48;
pub const OCI_FNCODE_SVCCTXBREAK: ::std::os::raw::c_uint = 50;
pub const OCI_FNCODE_SERVERVERSION: ::std::os::raw::c_uint = 51;
pub const OCI_FNCODE_KERBATTRSET: ::std::os::raw::c_uint = 52;
pub const OCI_FNCODE_SERVERRELEASE: ::std::os::raw::c_uint = 53;
pub const OCI_FNCODE_ATTRGET: ::std::os::raw::c_uint = 54;
pub const OCI_FNCODE_ATTRSET: ::std::os::raw::c_uint = 55;
pub const OCI_FNCODE_PARAMSET: ::std::os::raw::c_uint = 56;
pub const OCI_FNCODE_PARAMGET: ::std::os::raw::c_uint = 57;
pub const OCI_FNCODE_STMTGETPIECEINFO: ::std::os::raw::c_uint = 58;
pub const OCI_FNCODE_LDATOSVCCTX: ::std::os::raw::c_uint = 59;
pub const OCI_FNCODE_STMTSETPIECEINFO: ::std::os::raw::c_uint = 61;
pub const OCI_FNCODE_TRANSFORGET: ::std::os::raw::c_uint = 62;
pub const OCI_FNCODE_TRANSPREPARE: ::std::os::raw::c_uint = 63;
pub const OCI_FNCODE_TRANSROLLBACK: ::std::os::raw::c_uint = 64;
pub const OCI_FNCODE_DEFINEBYPOS: ::std::os::raw::c_uint = 65;
pub const OCI_FNCODE_BINDBYPOS: ::std::os::raw::c_uint = 66;
pub const OCI_FNCODE_BINDBYNAME: ::std::os::raw::c_uint = 67;
pub const OCI_FNCODE_LOBASSIGN: ::std::os::raw::c_uint = 68;
pub const OCI_FNCODE_LOBISEQUAL: ::std::os::raw::c_uint = 69;
pub const OCI_FNCODE_LOBISINIT: ::std::os::raw::c_uint = 70;
pub const OCI_FNCODE_LOBENABLEBUFFERING: ::std::os::raw::c_uint = 71;
pub const OCI_FNCODE_LOBCHARSETID: ::std::os::raw::c_uint = 72;
pub const OCI_FNCODE_LOBCHARSETFORM: ::std::os::raw::c_uint = 73;
pub const OCI_FNCODE_LOBFILESETNAME: ::std::os::raw::c_uint = 74;
pub const OCI_FNCODE_LOBFILEGETNAME: ::std::os::raw::c_uint = 75;
pub const OCI_FNCODE_LOGON: ::std::os::raw::c_uint = 76;
pub const OCI_FNCODE_LOGOFF: ::std::os::raw::c_uint = 77;
pub const OCI_FNCODE_LOBDISABLEBUFFERING: ::std::os::raw::c_uint = 78;
pub const OCI_FNCODE_LOBFLUSHBUFFER: ::std::os::raw::c_uint = 79;
pub const OCI_FNCODE_LOBLOADFROMFILE: ::std::os::raw::c_uint = 80;
pub const OCI_FNCODE_LOBOPEN: ::std::os::raw::c_uint = 81;
pub const OCI_FNCODE_LOBCLOSE: ::std::os::raw::c_uint = 82;
pub const OCI_FNCODE_LOBISOPEN: ::std::os::raw::c_uint = 83;
pub const OCI_FNCODE_LOBFILEISOPEN: ::std::os::raw::c_uint = 84;
pub const OCI_FNCODE_LOBFILEEXISTS: ::std::os::raw::c_uint = 85;
pub const OCI_FNCODE_LOBFILECLOSEALL: ::std::os::raw::c_uint = 86;
pub const OCI_FNCODE_LOBCREATETEMP: ::std::os::raw::c_uint = 87;
pub const OCI_FNCODE_LOBFREETEMP: ::std::os::raw::c_uint = 88;
pub const OCI_FNCODE_LOBISTEMP: ::std::os::raw::c_uint = 89;
pub const OCI_FNCODE_AQENQ: ::std::os::raw::c_uint = 90;
pub const OCI_FNCODE_AQDEQ: ::std::os::raw::c_uint = 91;
pub const OCI_FNCODE_RESET: ::std::os::raw::c_uint = 92;
pub const OCI_FNCODE_SVCCTXTOLDA: ::std::os::raw::c_uint = 93;
pub const OCI_FNCODE_LOBLOCATORASSIGN: ::std::os::raw::c_uint = 94;
pub const OCI_FNCODE_UBINDBYNAME: ::std::os::raw::c_uint = 95;
pub const OCI_FNCODE_AQLISTEN: ::std::os::raw::c_uint = 96;
pub const OCI_FNCODE_SVC2HST: ::std::os::raw::c_uint = 97;
pub const OCI_FNCODE_SVCRH: ::std::os::raw::c_uint = 98;
pub const OCI_FNCODE_TRANSMULTIPREPARE: ::std::os::raw::c_uint = 99;
pub const OCI_FNCODE_CPOOLCREATE: ::std::os::raw::c_uint = 100;
pub const OCI_FNCODE_CPOOLDESTROY: ::std::os::raw::c_uint = 101;
pub const OCI_FNCODE_LOGON2: ::std::os::raw::c_uint = 102;
pub const OCI_FNCODE_ROWIDTOCHAR: ::std::os::raw::c_uint = 103;
pub const OCI_FNCODE_SPOOLCREATE: ::std::os::raw::c_uint = 104;
pub const OCI_FNCODE_SPOOLDESTROY: ::std::os::raw::c_uint = 105;
pub const OCI_FNCODE_SESSIONGET: ::std::os::raw::c_uint = 106;
pub const OCI_FNCODE_SESSIONRELEASE: ::std::os::raw::c_uint = 107;
pub const OCI_FNCODE_STMTPREPARE2: ::std::os::raw::c_uint = 108;
pub const OCI_FNCODE_STMTRELEASE: ::std::os::raw::c_uint = 109;
pub const OCI_FNCODE_AQENQARRAY: ::std::os::raw::c_uint = 110;
pub const OCI_FNCODE_AQDEQARRAY: ::std::os::raw::c_uint = 111;
pub const OCI_FNCODE_LOBCOPY2: ::std::os::raw::c_uint = 112;
pub const OCI_FNCODE_LOBERASE2: ::std::os::raw::c_uint = 113;
pub const OCI_FNCODE_LOBLENGTH2: ::std::os::raw::c_uint = 114;
pub const OCI_FNCODE_LOBLOADFROMFILE2: ::std::os::raw::c_uint = 115;
pub const OCI_FNCODE_LOBREAD2: ::std::os::raw::c_uint = 116;
pub const OCI_FNCODE_LOBTRIM2: ::std::os::raw::c_uint = 117;
pub const OCI_FNCODE_LOBWRITE2: ::std::os::raw::c_uint = 118;
pub const OCI_FNCODE_LOBGETSTORAGELIMIT: ::std::os::raw::c_uint = 119;
pub const OCI_FNCODE_DBSTARTUP: ::std::os::raw::c_uint = 120;
pub const OCI_FNCODE_DBSHUTDOWN: ::std::os::raw::c_uint = 121;
pub const OCI_FNCODE_LOBARRAYREAD: ::std::os::raw::c_uint = 122;
pub const OCI_FNCODE_LOBARRAYWRITE: ::std::os::raw::c_uint = 123;
pub const OCI_FNCODE_AQENQSTREAM: ::std::os::raw::c_uint = 124;
pub const OCI_FNCODE_AQGETREPLAY: ::std::os::raw::c_uint = 125;
pub const OCI_FNCODE_AQRESETREPLAY: ::std::os::raw::c_uint = 126;
pub const OCI_FNCODE_ARRAYDESCRIPTORALLOC: ::std::os::raw::c_uint = 127;
pub const OCI_FNCODE_ARRAYDESCRIPTORFREE: ::std::os::raw::c_uint = 128;
pub const OCI_FNCODE_LOBGETOPT: ::std::os::raw::c_uint = 129;
pub const OCI_FNCODE_LOBSETOPT: ::std::os::raw::c_uint = 130;
pub const OCI_FNCODE_LOBFRAGINS: ::std::os::raw::c_uint = 131;
pub const OCI_FNCODE_LOBFRAGDEL: ::std::os::raw::c_uint = 132;
pub const OCI_FNCODE_LOBFRAGMOV: ::std::os::raw::c_uint = 133;
pub const OCI_FNCODE_LOBFRAGREP: ::std::os::raw::c_uint = 134;
pub const OCI_FNCODE_LOBGETDEDUPLICATEREGIONS: ::std::os::raw::c_uint = 135;
pub const OCI_FNCODE_APPCTXSET: ::std::os::raw::c_uint = 136;
pub const OCI_FNCODE_APPCTXCLEARALL: ::std::os::raw::c_uint = 137;
pub const OCI_FNCODE_LOBGETCONTENTTYPE: ::std::os::raw::c_uint = 138;
pub const OCI_FNCODE_LOBSETCONTENTTYPE: ::std::os::raw::c_uint = 139;
pub const OCI_FNCODE_DEFINEBYPOS2: ::std::os::raw::c_uint = 140;
pub const OCI_FNCODE_BINDBYPOS2: ::std::os::raw::c_uint = 141;
pub const OCI_FNCODE_BINDBYNAME2: ::std::os::raw::c_uint = 142;
pub const OCI_FNCODE_STMTGETNEXTRESULT: ::std::os::raw::c_uint = 143;
pub const OCI_FNCODE_AQENQ2: ::std::os::raw::c_uint = 144;
pub const OCI_FNCODE_AQDEQ2: ::std::os::raw::c_uint = 145;
pub const OCI_FNCODE_TYPEBYNAME: ::std::os::raw::c_uint = 146;
pub const OCI_FNCODE_TYPEBYFULLNAME: ::std::os::raw::c_uint = 147;
pub const OCI_FNCODE_TYPEBYREF: ::std::os::raw::c_uint = 148;
pub const OCI_FNCODE_TYPEARRAYBYNAME: ::std::os::raw::c_uint = 149;
pub const OCI_FNCODE_TYPEARRAYBYFULLNAME: ::std::os::raw::c_uint = 150;
pub const OCI_FNCODE_TYPEARRAYBYREF: ::std::os::raw::c_uint = 151;
pub const OCI_FNCODE_MAXFCN: ::std::os::raw::c_uint = 151;
pub const OCI_CBK_STMTCACHE_STMTPURGE: ::std::os::raw::c_uint = 1;
pub const OCI_INTHR_UNK: ::std::os::raw::c_uint = 24;
pub const OCI_ADJUST_UNK: ::std::os::raw::c_uint = 10;
pub const OCI_ORACLE_DATE: ::std::os::raw::c_uint = 0;
pub const OCI_ANSI_DATE: ::std::os::raw::c_uint = 1;
pub const OCI_FILE_READONLY: ::std::os::raw::c_uint = 1;
pub const OCI_LOB_READONLY: ::std::os::raw::c_uint = 1;
pub const OCI_LOB_READWRITE: ::std::os::raw::c_uint = 2;
pub const OCI_LOB_WRITEONLY: ::std::os::raw::c_uint = 3;
pub const OCI_LOB_APPENDONLY: ::std::os::raw::c_uint = 4;
pub const OCI_LOB_FULLOVERWRITE: ::std::os::raw::c_uint = 5;
pub const OCI_LOB_FULLREAD: ::std::os::raw::c_uint = 6;
pub const OCI_LOB_BUFFER_FREE: ::std::os::raw::c_uint = 1;
pub const OCI_LOB_BUFFER_NOFREE: ::std::os::raw::c_uint = 2;
pub const OCI_LOB_OPT_COMPRESS: ::std::os::raw::c_uint = 1;
pub const OCI_LOB_OPT_ENCRYPT: ::std::os::raw::c_uint = 2;
pub const OCI_LOB_OPT_DEDUPLICATE: ::std::os::raw::c_uint = 4;
pub const OCI_LOB_OPT_ALLOCSIZE: ::std::os::raw::c_uint = 8;
pub const OCI_LOB_OPT_CONTENTTYPE: ::std::os::raw::c_uint = 16;
pub const OCI_LOB_OPT_MODTIME: ::std::os::raw::c_uint = 32;
pub const OCI_LOB_COMPRESS_OFF: ::std::os::raw::c_uint = 0;
pub const OCI_LOB_COMPRESS_ON: ::std::os::raw::c_uint = 1;
pub const OCI_LOB_ENCRYPT_OFF: ::std::os::raw::c_uint = 0;
pub const OCI_LOB_ENCRYPT_ON: ::std::os::raw::c_uint = 2;
pub const OCI_LOB_DEDUPLICATE_OFF: ::std::os::raw::c_uint = 0;
pub const OCI_LOB_DEDUPLICATE_ON: ::std::os::raw::c_uint = 4;
pub const OCI_STMT_UNKNOWN: ::std::os::raw::c_uint = 0;
pub const OCI_STMT_SELECT: ::std::os::raw::c_uint = 1;
pub const OCI_STMT_UPDATE: ::std::os::raw::c_uint = 2;
pub const OCI_STMT_DELETE: ::std::os::raw::c_uint = 3;
pub const OCI_STMT_INSERT: ::std::os::raw::c_uint = 4;
pub const OCI_STMT_CREATE: ::std::os::raw::c_uint = 5;
pub const OCI_STMT_DROP: ::std::os::raw::c_uint = 6;
pub const OCI_STMT_ALTER: ::std::os::raw::c_uint = 7;
pub const OCI_STMT_BEGIN: ::std::os::raw::c_uint = 8;
pub const OCI_STMT_DECLARE: ::std::os::raw::c_uint = 9;
pub const OCI_STMT_CALL: ::std::os::raw::c_uint = 10;
pub const OCI_PTYPE_UNK: ::std::os::raw::c_uint = 0;
pub const OCI_PTYPE_TABLE: ::std::os::raw::c_uint = 1;
pub const OCI_PTYPE_VIEW: ::std::os::raw::c_uint = 2;
pub const OCI_PTYPE_PROC: ::std::os::raw::c_uint = 3;
pub const OCI_PTYPE_FUNC: ::std::os::raw::c_uint = 4;
pub const OCI_PTYPE_PKG: ::std::os::raw::c_uint = 5;
pub const OCI_PTYPE_TYPE: ::std::os::raw::c_uint = 6;
pub const OCI_PTYPE_SYN: ::std::os::raw::c_uint = 7;
pub const OCI_PTYPE_SEQ: ::std::os::raw::c_uint = 8;
pub const OCI_PTYPE_COL: ::std::os::raw::c_uint = 9;
pub const OCI_PTYPE_ARG: ::std::os::raw::c_uint = 10;
pub const OCI_PTYPE_LIST: ::std::os::raw::c_uint = 11;
pub const OCI_PTYPE_TYPE_ATTR: ::std::os::raw::c_uint = 12;
pub const OCI_PTYPE_TYPE_COLL: ::std::os::raw::c_uint = 13;
pub const OCI_PTYPE_TYPE_METHOD: ::std::os::raw::c_uint = 14;
pub const OCI_PTYPE_TYPE_ARG: ::std::os::raw::c_uint = 15;
pub const OCI_PTYPE_TYPE_RESULT: ::std::os::raw::c_uint = 16;
pub const OCI_PTYPE_SCHEMA: ::std::os::raw::c_uint = 17;
pub const OCI_PTYPE_DATABASE: ::std::os::raw::c_uint = 18;
pub const OCI_PTYPE_RULE: ::std::os::raw::c_uint = 19;
pub const OCI_PTYPE_RULE_SET: ::std::os::raw::c_uint = 20;
pub const OCI_PTYPE_EVALUATION_CONTEXT: ::std::os::raw::c_uint = 21;
pub const OCI_PTYPE_TABLE_ALIAS: ::std::os::raw::c_uint = 22;
pub const OCI_PTYPE_VARIABLE_TYPE: ::std::os::raw::c_uint = 23;
pub const OCI_PTYPE_NAME_VALUE: ::std::os::raw::c_uint = 24;
pub const OCI_LTYPE_UNK: ::std::os::raw::c_uint = 0;
pub const OCI_LTYPE_COLUMN: ::std::os::raw::c_uint = 1;
pub const OCI_LTYPE_ARG_PROC: ::std::os::raw::c_uint = 2;
pub const OCI_LTYPE_ARG_FUNC: ::std::os::raw::c_uint = 3;
pub const OCI_LTYPE_SUBPRG: ::std::os::raw::c_uint = 4;
pub const OCI_LTYPE_TYPE_ATTR: ::std::os::raw::c_uint = 5;
pub const OCI_LTYPE_TYPE_METHOD: ::std::os::raw::c_uint = 6;
pub const OCI_LTYPE_TYPE_ARG_PROC: ::std::os::raw::c_uint = 7;
pub const OCI_LTYPE_TYPE_ARG_FUNC: ::std::os::raw::c_uint = 8;
pub const OCI_LTYPE_SCH_OBJ: ::std::os::raw::c_uint = 9;
pub const OCI_LTYPE_DB_SCH: ::std::os::raw::c_uint = 10;
pub const OCI_LTYPE_TYPE_SUBTYPE: ::std::os::raw::c_uint = 11;
pub const OCI_LTYPE_TABLE_ALIAS: ::std::os::raw::c_uint = 12;
pub const OCI_LTYPE_VARIABLE_TYPE: ::std::os::raw::c_uint = 13;
pub const OCI_LTYPE_NAME_VALUE: ::std::os::raw::c_uint = 14;
pub const OCI_LTYPE_PACKAGE_TYPE: ::std::os::raw::c_uint = 15;
pub const OCI_MEMORY_CLEARED: ::std::os::raw::c_uint = 1;
pub const OCI_UCBTYPE_ENTRY: ::std::os::raw::c_uint = 1;
pub const OCI_UCBTYPE_EXIT: ::std::os::raw::c_uint = 2;
pub const OCI_UCBTYPE_REPLACE: ::std::os::raw::c_uint = 3;
pub const OCI_NLS_DAYNAME1: ::std::os::raw::c_uint = 1;
pub const OCI_NLS_DAYNAME2: ::std::os::raw::c_uint = 2;
pub const OCI_NLS_DAYNAME3: ::std::os::raw::c_uint = 3;
pub const OCI_NLS_DAYNAME4: ::std::os::raw::c_uint = 4;
pub const OCI_NLS_DAYNAME5: ::std::os::raw::c_uint = 5;
pub const OCI_NLS_DAYNAME6: ::std::os::raw::c_uint = 6;
pub const OCI_NLS_DAYNAME7: ::std::os::raw::c_uint = 7;
pub const OCI_NLS_ABDAYNAME1: ::std::os::raw::c_uint = 8;
pub const OCI_NLS_ABDAYNAME2: ::std::os::raw::c_uint = 9;
pub const OCI_NLS_ABDAYNAME3: ::std::os::raw::c_uint = 10;
pub const OCI_NLS_ABDAYNAME4: ::std::os::raw::c_uint = 11;
pub const OCI_NLS_ABDAYNAME5: ::std::os::raw::c_uint = 12;
pub const OCI_NLS_ABDAYNAME6: ::std::os::raw::c_uint = 13;
pub const OCI_NLS_ABDAYNAME7: ::std::os::raw::c_uint = 14;
pub const OCI_NLS_MONTHNAME1: ::std::os::raw::c_uint = 15;
pub const OCI_NLS_MONTHNAME2: ::std::os::raw::c_uint = 16;
pub const OCI_NLS_MONTHNAME3: ::std::os::raw::c_uint = 17;
pub const OCI_NLS_MONTHNAME4: ::std::os::raw::c_uint = 18;
pub const OCI_NLS_MONTHNAME5: ::std::os::raw::c_uint = 19;
pub const OCI_NLS_MONTHNAME6: ::std::os::raw::c_uint = 20;
pub const OCI_NLS_MONTHNAME7: ::std::os::raw::c_uint = 21;
pub const OCI_NLS_MONTHNAME8: ::std::os::raw::c_uint = 22;
pub const OCI_NLS_MONTHNAME9: ::std::os::raw::c_uint = 23;
pub const OCI_NLS_MONTHNAME10: ::std::os::raw::c_uint = 24;
pub const OCI_NLS_MONTHNAME11: ::std::os::raw::c_uint = 25;
pub const OCI_NLS_MONTHNAME12: ::std::os::raw::c_uint = 26;
pub const OCI_NLS_ABMONTHNAME1: ::std::os::raw::c_uint = 27;
pub const OCI_NLS_ABMONTHNAME2: ::std::os::raw::c_uint = 28;
pub const OCI_NLS_ABMONTHNAME3: ::std::os::raw::c_uint = 29;
pub const OCI_NLS_ABMONTHNAME4: ::std::os::raw::c_uint = 30;
pub const OCI_NLS_ABMONTHNAME5: ::std::os::raw::c_uint = 31;
pub const OCI_NLS_ABMONTHNAME6: ::std::os::raw::c_uint = 32;
pub const OCI_NLS_ABMONTHNAME7: ::std::os::raw::c_uint = 33;
pub const OCI_NLS_ABMONTHNAME8: ::std::os::raw::c_uint = 34;
pub const OCI_NLS_ABMONTHNAME9: ::std::os::raw::c_uint = 35;
pub const OCI_NLS_ABMONTHNAME10: ::std::os::raw::c_uint = 36;
pub const OCI_NLS_ABMONTHNAME11: ::std::os::raw::c_uint = 37;
pub const OCI_NLS_ABMONTHNAME12: ::std::os::raw::c_uint = 38;
pub const OCI_NLS_YES: ::std::os::raw::c_uint = 39;
pub const OCI_NLS_NO: ::std::os::raw::c_uint = 40;
pub const OCI_NLS_AM: ::std::os::raw::c_uint = 41;
pub const OCI_NLS_PM: ::std::os::raw::c_uint = 42;
pub const OCI_NLS_AD: ::std::os::raw::c_uint = 43;
pub const OCI_NLS_BC: ::std::os::raw::c_uint = 44;
pub const OCI_NLS_DECIMAL: ::std::os::raw::c_uint = 45;
pub const OCI_NLS_GROUP: ::std::os::raw::c_uint = 46;
pub const OCI_NLS_DEBIT: ::std::os::raw::c_uint = 47;
pub const OCI_NLS_CREDIT: ::std::os::raw::c_uint = 48;
pub const OCI_NLS_DATEFORMAT: ::std::os::raw::c_uint = 49;
pub const OCI_NLS_INT_CURRENCY: ::std::os::raw::c_uint = 50;
pub const OCI_NLS_LOC_CURRENCY: ::std::os::raw::c_uint = 51;
pub const OCI_NLS_LANGUAGE: ::std::os::raw::c_uint = 52;
pub const OCI_NLS_ABLANGUAGE: ::std::os::raw::c_uint = 53;
pub const OCI_NLS_TERRITORY: ::std::os::raw::c_uint = 54;
pub const OCI_NLS_CHARACTER_SET: ::std::os::raw::c_uint = 55;
pub const OCI_NLS_LINGUISTIC_NAME: ::std::os::raw::c_uint = 56;
pub const OCI_NLS_CALENDAR: ::std::os::raw::c_uint = 57;
pub const OCI_NLS_DUAL_CURRENCY: ::std::os::raw::c_uint = 78;
pub const OCI_NLS_WRITINGDIR: ::std::os::raw::c_uint = 79;
pub const OCI_NLS_ABTERRITORY: ::std::os::raw::c_uint = 80;
pub const OCI_NLS_DDATEFORMAT: ::std::os::raw::c_uint = 81;
pub const OCI_NLS_DTIMEFORMAT: ::std::os::raw::c_uint = 82;
pub const OCI_NLS_SFDATEFORMAT: ::std::os::raw::c_uint = 83;
pub const OCI_NLS_SFTIMEFORMAT: ::std::os::raw::c_uint = 84;
pub const OCI_NLS_NUMGROUPING: ::std::os::raw::c_uint = 85;
pub const OCI_NLS_LISTSEP: ::std::os::raw::c_uint = 86;
pub const OCI_NLS_MONDECIMAL: ::std::os::raw::c_uint = 87;
pub const OCI_NLS_MONGROUP: ::std::os::raw::c_uint = 88;
pub const OCI_NLS_MONGROUPING: ::std::os::raw::c_uint = 89;
pub const OCI_NLS_INT_CURRENCYSEP: ::std::os::raw::c_uint = 90;
pub const OCI_NLS_CHARSET_MAXBYTESZ: ::std::os::raw::c_uint = 91;
pub const OCI_NLS_CHARSET_FIXEDWIDTH: ::std::os::raw::c_uint = 92;
pub const OCI_NLS_CHARSET_ID: ::std::os::raw::c_uint = 93;
pub const OCI_NLS_NCHARSET_ID: ::std::os::raw::c_uint = 94;
pub const OCI_NLS_MAXBUFSZ: ::std::os::raw::c_uint = 100;
pub const OCI_NLS_BINARY: ::std::os::raw::c_uint = 1;
pub const OCI_NLS_LINGUISTIC: ::std::os::raw::c_uint = 2;
pub const OCI_NLS_CASE_INSENSITIVE: ::std::os::raw::c_uint = 16;
pub const OCI_NLS_UPPERCASE: ::std::os::raw::c_uint = 32;
pub const OCI_NLS_LOWERCASE: ::std::os::raw::c_uint = 64;
pub const OCI_NLS_CS_IANA_TO_ORA: ::std::os::raw::c_uint = 0;
pub const OCI_NLS_CS_ORA_TO_IANA: ::std::os::raw::c_uint = 1;
pub const OCI_NLS_LANG_ISO_TO_ORA: ::std::os::raw::c_uint = 2;
pub const OCI_NLS_LANG_ORA_TO_ISO: ::std::os::raw::c_uint = 3;
pub const OCI_NLS_TERR_ISO_TO_ORA: ::std::os::raw::c_uint = 4;
pub const OCI_NLS_TERR_ORA_TO_ISO: ::std::os::raw::c_uint = 5;
pub const OCI_NLS_TERR_ISO3_TO_ORA: ::std::os::raw::c_uint = 6;
pub const OCI_NLS_TERR_ORA_TO_ISO3: ::std::os::raw::c_uint = 7;
pub const OCI_NLS_LOCALE_A2_ISO_TO_ORA: ::std::os::raw::c_uint = 8;
pub const OCI_NLS_LOCALE_A2_ORA_TO_ISO: ::std::os::raw::c_uint = 9;
pub const OCI_XMLTYPE_CREATE_OCISTRING: ::std::os::raw::c_uint = 1;
pub const OCI_XMLTYPE_CREATE_CLOB: ::std::os::raw::c_uint = 2;
pub const OCI_XMLTYPE_CREATE_BLOB: ::std::os::raw::c_uint = 3;
pub const OCI_KERBCRED_PROXY: ::std::os::raw::c_uint = 1;
pub const OCI_KERBCRED_CLIENT_IDENTIFIER: ::std::os::raw::c_uint = 2;
pub const OCI_DBSTARTUPFLAG_FORCE: ::std::os::raw::c_uint = 1;
pub const OCI_DBSTARTUPFLAG_RESTRICT: ::std::os::raw::c_uint = 2;
pub const OCI_DBSHUTDOWN_TRANSACTIONAL: ::std::os::raw::c_uint = 1;
pub const OCI_DBSHUTDOWN_TRANSACTIONAL_LOCAL: ::std::os::raw::c_uint = 2;
pub const OCI_DBSHUTDOWN_IMMEDIATE: ::std::os::raw::c_uint = 3;
pub const OCI_DBSHUTDOWN_ABORT: ::std::os::raw::c_uint = 4;
pub const OCI_DBSHUTDOWN_FINAL: ::std::os::raw::c_uint = 5;
pub const OCI_MAJOR_VERSION: ::std::os::raw::c_uint = 12;
pub const OCI_MINOR_VERSION: ::std::os::raw::c_uint = 1;
pub const OCIFormatDP: ::std::os::raw::c_uint = 6;
pub const OCI_FILE_READ_ONLY: ::std::os::raw::c_uint = 1;
pub const OCI_FILE_WRITE_ONLY: ::std::os::raw::c_uint = 2;
pub const OCI_FILE_READ_WRITE: ::std::os::raw::c_uint = 3;
pub const OCI_FILE_EXIST: ::std::os::raw::c_uint = 0;
pub const OCI_FILE_CREATE: ::std::os::raw::c_uint = 1;
pub const OCI_FILE_EXCL: ::std::os::raw::c_uint = 2;
pub const OCI_FILE_TRUNCATE: ::std::os::raw::c_uint = 4;
pub const OCI_FILE_APPEND: ::std::os::raw::c_uint = 8;
pub const OCI_FILE_SEEK_BEGINNING: ::std::os::raw::c_uint = 1;
pub const OCI_FILE_SEEK_CURRENT: ::std::os::raw::c_uint = 2;
pub const OCI_FILE_SEEK_END: ::std::os::raw::c_uint = 3;
pub const OCI_FILE_FORWARD: ::std::os::raw::c_uint = 1;
pub const OCI_FILE_BACKWARD: ::std::os::raw::c_uint = 2;
pub const OCI_FILE_BIN: ::std::os::raw::c_uint = 0;
pub const OCI_FILE_TEXT: ::std::os::raw::c_uint = 1;
pub const OCI_FILE_STDIN: ::std::os::raw::c_uint = 2;
pub const OCI_FILE_STDOUT: ::std::os::raw::c_uint = 3;
pub const OCI_FILE_STDERR: ::std::os::raw::c_uint = 4;
pub const OCI_EXTRACT_CASE_SENSITIVE: ::std::os::raw::c_uint = 1;
pub const OCI_EXTRACT_UNIQUE_ABBREVS: ::std::os::raw::c_uint = 2;
pub const OCI_EXTRACT_APPEND_VALUES: ::std::os::raw::c_uint = 4;
pub const OCI_EXTRACT_MULTIPLE: ::std::os::raw::c_uint = 8;
pub const OCI_EXTRACT_TYPE_BOOLEAN: ::std::os::raw::c_uint = 1;
pub const OCI_EXTRACT_TYPE_STRING: ::std::os::raw::c_uint = 2;
pub const OCI_EXTRACT_TYPE_INTEGER: ::std::os::raw::c_uint = 3;
pub const OCI_EXTRACT_TYPE_OCINUM: ::std::os::raw::c_uint = 4;
pub const OCI_ATTR_OBJECT_DETECTCHANGE: ::std::os::raw::c_uint = 32;
pub const OCI_ATTR_OBJECT_NEWNOTNULL: ::std::os::raw::c_uint = 16;
pub const OCI_ATTR_CACHE_ARRAYFLUSH: ::std::os::raw::c_uint = 64;
pub const OCI_DURATION_INVALID: ::std::os::raw::c_uint = 65535;
pub const OCI_OBJECTPROP_LIFETIME: ::std::os::raw::c_uint = 1;
pub const OCI_OBJECTPROP_SCHEMA: ::std::os::raw::c_uint = 2;
pub const OCI_OBJECTPROP_TABLE: ::std::os::raw::c_uint = 3;
pub const OCI_OBJECTPROP_PIN_DURATION: ::std::os::raw::c_uint = 4;
pub const OCI_OBJECTPROP_ALLOC_DURATION: ::std::os::raw::c_uint = 5;
pub const OCI_OBJECTPROP_LOCK: ::std::os::raw::c_uint = 6;
pub const OCI_OBJECTPROP_MARKSTATUS: ::std::os::raw::c_uint = 7;
pub const OCI_OBJECTPROP_VIEW: ::std::os::raw::c_uint = 8;
pub const OCI_OBJECT_NEW: ::std::os::raw::c_uint = 1;
pub const OCI_OBJECT_DELETED: ::std::os::raw::c_uint = 2;
pub const OCI_OBJECT_UPDATED: ::std::os::raw::c_uint = 4;
pub const OCI_TYPECODE_REF: ::std::os::raw::c_uint = 110;
pub const OCI_TYPECODE_DATE: ::std::os::raw::c_uint = 12;
pub const OCI_TYPECODE_SIGNED8: ::std::os::raw::c_uint = 27;
pub const OCI_TYPECODE_SIGNED16: ::std::os::raw::c_uint = 28;
pub const OCI_TYPECODE_SIGNED32: ::std::os::raw::c_uint = 29;
pub const OCI_TYPECODE_REAL: ::std::os::raw::c_uint = 21;
pub const OCI_TYPECODE_DOUBLE: ::std::os::raw::c_uint = 22;
pub const OCI_TYPECODE_BFLOAT: ::std::os::raw::c_uint = 100;
pub const OCI_TYPECODE_BDOUBLE: ::std::os::raw::c_uint = 101;
pub const OCI_TYPECODE_FLOAT: ::std::os::raw::c_uint = 4;
pub const OCI_TYPECODE_NUMBER: ::std::os::raw::c_uint = 2;
pub const OCI_TYPECODE_DECIMAL: ::std::os::raw::c_uint = 7;
pub const OCI_TYPECODE_UNSIGNED8: ::std::os::raw::c_uint = 23;
pub const OCI_TYPECODE_UNSIGNED16: ::std::os::raw::c_uint = 25;
pub const OCI_TYPECODE_UNSIGNED32: ::std::os::raw::c_uint = 26;
pub const OCI_TYPECODE_OCTET: ::std::os::raw::c_uint = 245;
pub const OCI_TYPECODE_SMALLINT: ::std::os::raw::c_uint = 246;
pub const OCI_TYPECODE_INTEGER: ::std::os::raw::c_uint = 3;
pub const OCI_TYPECODE_RAW: ::std::os::raw::c_uint = 95;
pub const OCI_TYPECODE_PTR: ::std::os::raw::c_uint = 32;
pub const OCI_TYPECODE_VARCHAR2: ::std::os::raw::c_uint = 9;
pub const OCI_TYPECODE_CHAR: ::std::os::raw::c_uint = 96;
pub const OCI_TYPECODE_VARCHAR: ::std::os::raw::c_uint = 1;
pub const OCI_TYPECODE_MLSLABEL: ::std::os::raw::c_uint = 105;
pub const OCI_TYPECODE_VARRAY: ::std::os::raw::c_uint = 247;
pub const OCI_TYPECODE_TABLE: ::std::os::raw::c_uint = 248;
pub const OCI_TYPECODE_OBJECT: ::std::os::raw::c_uint = 108;
pub const OCI_TYPECODE_OPAQUE: ::std::os::raw::c_uint = 58;
pub const OCI_TYPECODE_NAMEDCOLLECTION: ::std::os::raw::c_uint = 122;
pub const OCI_TYPECODE_BLOB: ::std::os::raw::c_uint = 113;
pub const OCI_TYPECODE_BFILE: ::std::os::raw::c_uint = 114;
pub const OCI_TYPECODE_CLOB: ::std::os::raw::c_uint = 112;
pub const OCI_TYPECODE_CFILE: ::std::os::raw::c_uint = 115;
pub const OCI_TYPECODE_TIME: ::std::os::raw::c_uint = 185;
pub const OCI_TYPECODE_TIME_TZ: ::std::os::raw::c_uint = 186;
pub const OCI_TYPECODE_TIMESTAMP: ::std::os::raw::c_uint = 187;
pub const OCI_TYPECODE_TIMESTAMP_TZ: ::std::os::raw::c_uint = 188;
pub const OCI_TYPECODE_TIMESTAMP_LTZ: ::std::os::raw::c_uint = 232;
pub const OCI_TYPECODE_INTERVAL_YM: ::std::os::raw::c_uint = 189;
pub const OCI_TYPECODE_INTERVAL_DS: ::std::os::raw::c_uint = 190;
pub const OCI_TYPECODE_UROWID: ::std::os::raw::c_uint = 104;
pub const OCI_TYPECODE_OTMFIRST: ::std::os::raw::c_uint = 228;
pub const OCI_TYPECODE_OTMLAST: ::std::os::raw::c_uint = 320;
pub const OCI_TYPECODE_SYSFIRST: ::std::os::raw::c_uint = 228;
pub const OCI_TYPECODE_SYSLAST: ::std::os::raw::c_uint = 235;
pub const OCI_TYPECODE_PLS_INTEGER: ::std::os::raw::c_uint = 266;
pub const OCI_TYPECODE_ITABLE: ::std::os::raw::c_uint = 251;
pub const OCI_TYPECODE_RECORD: ::std::os::raw::c_uint = 250;
pub const OCI_TYPECODE_BOOLEAN: ::std::os::raw::c_uint = 252;
pub const OCI_TYPECODE_NCHAR: ::std::os::raw::c_uint = 286;
pub const OCI_TYPECODE_NVARCHAR2: ::std::os::raw::c_uint = 287;
pub const OCI_TYPECODE_NCLOB: ::std::os::raw::c_uint = 288;
pub const OCI_TYPECODE_NONE: ::std::os::raw::c_uint = 0;
pub const OCI_TYPECODE_ERRHP: ::std::os::raw::c_uint = 283;
pub const OCI_VARRAY_MAXSIZE: ::std::os::raw::c_uint = 4000;
pub const OCI_STRING_MAXLEN: ::std::os::raw::c_uint = 4000;
pub const OCI_TYPEELEM_REF: ::std::os::raw::c_uint = 32768;
pub const OCI_TYPEPARAM_REQUIRED: ::std::os::raw::c_uint = 2048;
pub const OCI_NUMBER_SIZE: ::std::os::raw::c_uint = 22;
pub const OCI_NUMBER_UNSIGNED: ::std::os::raw::c_uint = 0;
pub const OCI_NUMBER_SIGNED: ::std::os::raw::c_uint = 2;
pub const OCI_DATE_INVALID_DAY: ::std::os::raw::c_uint = 1;
pub const OCI_DATE_DAY_BELOW_VALID: ::std::os::raw::c_uint = 2;
pub const OCI_DATE_INVALID_MONTH: ::std::os::raw::c_uint = 4;
pub const OCI_DATE_MONTH_BELOW_VALID: ::std::os::raw::c_uint = 8;
pub const OCI_DATE_INVALID_YEAR: ::std::os::raw::c_uint = 16;
pub const OCI_DATE_YEAR_BELOW_VALID: ::std::os::raw::c_uint = 32;
pub const OCI_DATE_INVALID_HOUR: ::std::os::raw::c_uint = 64;
pub const OCI_DATE_HOUR_BELOW_VALID: ::std::os::raw::c_uint = 128;
pub const OCI_DATE_INVALID_MINUTE: ::std::os::raw::c_uint = 256;
pub const OCI_DATE_MINUTE_BELOW_VALID: ::std::os::raw::c_uint = 512;
pub const OCI_DATE_INVALID_SECOND: ::std::os::raw::c_uint = 1024;
pub const OCI_DATE_SECOND_BELOW_VALID: ::std::os::raw::c_uint = 2048;
pub const OCI_DATE_DAY_MISSING_FROM_1582: ::std::os::raw::c_uint = 4096;
pub const OCI_DATE_YEAR_ZERO: ::std::os::raw::c_uint = 8192;
pub const OCI_DATE_INVALID_FORMAT: ::std::os::raw::c_uint = 32768;
pub const OCIEXTPROC_SUCCESS: ::std::os::raw::c_uint = 0;
pub const OCIEXTPROC_ERROR: ::std::os::raw::c_uint = 1;
pub const __GNUC_VA_LIST: ::std::os::raw::c_uint = 1;
pub const NZT_MAX_SHA1: ::std::os::raw::c_uint = 20;
pub const NZT_MAX_MD5: ::std::os::raw::c_uint = 16;
pub const NZTTKPUSAGE_NONE: ::std::os::raw::c_uint = 0;
pub const NZTTKPUSAGE_SSL: ::std::os::raw::c_uint = 1;
pub const NZTTKPUSAGE_SMIME_ENCR: ::std::os::raw::c_uint = 2;
pub const NZTTKPUSAGE_SMIME_SIGN: ::std::os::raw::c_uint = 4;
pub const NZTTKPUSAGE_CODE_SIGN: ::std::os::raw::c_uint = 8;
pub const NZTTKPUSAGE_CERT_SIGN: ::std::os::raw::c_uint = 16;
pub const NZTTKPUSAGE_SSL_CLIENT: ::std::os::raw::c_uint = 32;
pub const NZTTKPUSAGE_INVALID_USE: ::std::os::raw::c_uint = 65535;
pub const NZT_NO_AUTO_REALLOC: ::std::os::raw::c_uint = 1;
pub const NUM_OCIXMLDBPARAMS: ::std::os::raw::c_uint = 2;
pub const OCIXMLDB_BINDBYNAME: ::std::os::raw::c_uint = 1;
pub const OCIXMLDB_BINDBYNUM: ::std::os::raw::c_uint = 2;
pub const OCIMAXXQUBNDLMT: ::std::os::raw::c_uint = 1000;
pub const OCIXmlDr_DEF: ::std::os::raw::c_uint = 2;
pub const OCI_DIRPATH_LOAD: ::std::os::raw::c_uint = 1;
pub const OCI_DIRPATH_UNLOAD: ::std::os::raw::c_uint = 2;
pub const OCI_DIRPATH_CONVERT: ::std::os::raw::c_uint = 3;
pub const OCI_DIRPATH_INDEX_MAINT_SINGLE_ROW: ::std::os::raw::c_uint = 1;
pub const OCI_DIRPATH_INDEX_MAINT_SKIP_UNUSABLE: ::std::os::raw::c_uint = 2;
pub const OCI_DIRPATH_INDEX_MAINT_DONT_SKIP_UNUSABLE: ::std::os::raw::c_uint = 3;
pub const OCI_DIRPATH_INDEX_MAINT_SKIP_ALL: ::std::os::raw::c_uint = 4;
pub const OCI_DIRPATH_NORMAL: ::std::os::raw::c_uint = 1;
pub const OCI_DIRPATH_PARTIAL: ::std::os::raw::c_uint = 2;
pub const OCI_DIRPATH_NOT_PREPARED: ::std::os::raw::c_uint = 3;
pub const OCI_DIRPATH_COL_COMPLETE: ::std::os::raw::c_uint = 0;
pub const OCI_DIRPATH_COL_NULL: ::std::os::raw::c_uint = 1;
pub const OCI_DIRPATH_COL_PARTIAL: ::std::os::raw::c_uint = 2;
pub const OCI_DIRPATH_COL_ERROR: ::std::os::raw::c_uint = 3;
pub const OCI_DIRPATH_DATASAVE_SAVEONLY: ::std::os::raw::c_uint = 0;
pub const OCI_DIRPATH_DATASAVE_FINISH: ::std::os::raw::c_uint = 1;
pub const OCI_DIRPATH_DATASAVE_PARTIAL: ::std::os::raw::c_uint = 2;
pub const OCI_DIRPATH_EXPR_OBJ_CONSTR: ::std::os::raw::c_uint = 1;
pub const OCI_DIRPATH_EXPR_SQL: ::std::os::raw::c_uint = 2;
pub const OCI_DIRPATH_EXPR_REF_TBLNAME: ::std::os::raw::c_uint = 3;
pub const OCI_LCR_XROW: ::std::os::raw::c_uint = 3;
pub const OCI_LCR_XDDL: ::std::os::raw::c_uint = 4;
pub const OCI_LCR_ROW_CMD_INSERT: &'static [u8; 7usize] = b"INSERT\x00";
pub const OCI_LCR_ROW_CMD_DELETE: &'static [u8; 7usize] = b"DELETE\x00";
pub const OCI_LCR_ROW_CMD_UPDATE: &'static [u8; 7usize] = b"UPDATE\x00";
pub const OCI_LCR_ROW_CMD_COMMIT: &'static [u8; 7usize] = b"COMMIT\x00";
pub const OCI_LCR_ROW_CMD_LOB_WRITE: &'static [u8; 10usize] = b"LOB WRITE\x00";
pub const OCI_LCR_ROW_CMD_LOB_TRIM: &'static [u8; 9usize] = b"LOB TRIM\x00";
pub const OCI_LCR_ROW_CMD_LOB_ERASE: &'static [u8; 10usize] = b"LOB ERASE\x00";
pub const OCI_LCR_ROW_CMD_ROLLBACK: &'static [u8; 9usize] = b"ROLLBACK\x00";
pub const OCI_LCR_ROW_CMD_START_TX: &'static [u8; 9usize] = b"START_TX\x00";
pub const OCI_LCR_ROW_CMD_CTRL_INFO: &'static [u8; 13usize] = b"CONTROL INFO\x00";
pub const OCI_LCR_CTRLINFO_MEMORY_PRESSURE: ::std::os::raw::c_uint = 32768;
pub const OCI_LCR_CTRLINFO_MISSING_LOGFILE: ::std::os::raw::c_uint = 32769;
pub const OCI_LCR_CTRLINFO_UNSUPPORTED_LCR: ::std::os::raw::c_uint = 32770;
pub const OCI_LCR_ATTR_THREAD_NO: &'static [u8; 8usize] = b"THREAD#\x00";
pub const OCI_LCR_ATTR_ROW_ID: &'static [u8; 7usize] = b"ROW_ID\x00";
pub const OCI_LCR_ATTR_SESSION_NO: &'static [u8; 9usize] = b"SESSION#\x00";
pub const OCI_LCR_ATTR_SERIAL_NO: &'static [u8; 8usize] = b"SERIAL#\x00";
pub const OCI_LCR_ATTR_USERNAME: &'static [u8; 9usize] = b"USERNAME\x00";
pub const OCI_LCR_ATTR_TX_NAME: &'static [u8; 8usize] = b"TX_NAME\x00";
pub const OCI_LCR_ATTR_EDITION_NAME: &'static [u8; 13usize] = b"EDITION_NAME\x00";
pub const OCI_LCR_ATTR_MESSAGE_TRACKING_LABEL: &'static [u8; 23usize] =
    b"MESSAGE_TRACKING_LABEL\x00";
pub const OCI_LCR_ATTR_CURRENT_USER: &'static [u8; 13usize] = b"CURRENT_USER\x00";
pub const OCI_LCR_ATTR_ROOT_NAME: &'static [u8; 10usize] = b"ROOT_NAME\x00";
pub const OCI_LCR_ATTR_OLD_OWNER: &'static [u8; 10usize] = b"OLD_OWNER\x00";
pub const OCI_LCR_ATTR_OLD_ONAME: &'static [u8; 10usize] = b"OLD_ONAME\x00";
pub const OCI_LCR_ROW_COLVAL_OLD: ::std::os::raw::c_uint = 0;
pub const OCI_LCR_ROW_COLVAL_NEW: ::std::os::raw::c_uint = 1;
pub const OCI_LCR_MAX_POSITION_LEN: ::std::os::raw::c_uint = 64;
pub const OCI_LCR_MAX_TXID_LEN: ::std::os::raw::c_uint = 128;
pub const OCI_LCR_COLUMN_LOB_DATA: ::std::os::raw::c_uint = 1;
pub const OCI_LCR_COLUMN_LONG_DATA: ::std::os::raw::c_uint = 2;
pub const OCI_LCR_COLUMN_EMPTY_LOB: ::std::os::raw::c_uint = 4;
pub const OCI_LCR_COLUMN_LAST_CHUNK: ::std::os::raw::c_uint = 8;
pub const OCI_LCR_COLUMN_AL16UTF16: ::std::os::raw::c_uint = 16;
pub const OCI_LCR_COLUMN_NCLOB: ::std::os::raw::c_uint = 32;
pub const OCI_LCR_COLUMN_XML_DATA: ::std::os::raw::c_uint = 64;
pub const OCI_LCR_COLUMN_XML_DIFF: ::std::os::raw::c_uint = 128;
pub const OCI_LCR_COLUMN_ENCRYPTED: ::std::os::raw::c_uint = 256;
pub const OCI_LCR_COLUMN_UPDATED: ::std::os::raw::c_uint = 512;
pub const OCI_LCR_COLUMN_32K_DATA: ::std::os::raw::c_uint = 1024;
pub const OCI_LCR_COLUMN_OBJ_XML: ::std::os::raw::c_uint = 2048;
pub const OCI_ROWLCR_HAS_ID_KEY_ONLY: ::std::os::raw::c_uint = 1;
pub const OCI_ROWLCR_SEQ_LCR: ::std::os::raw::c_uint = 16;
pub const OCI_ROWLCR_IS_INFLIGHT_TXN: ::std::os::raw::c_uint = 32;
pub const OCI_XSTREAM_MORE_ROW_DATA: ::std::os::raw::c_uint = 1;
pub const OCILCR_NEW_ONLY_MODE: ::std::os::raw::c_uint = 1;
pub const OCIXSTREAM_IN_FLUSH_WAIT_FOR_COMPLETE: ::std::os::raw::c_uint = 1;
pub const OCIXSTREAM_SESSION_SET_MAX_PARAM_LEN: ::std::os::raw::c_uint = 128;
pub const OCIXSTREAM_ATTR_ATTACH_TIMEOUT: &'static [u8; 20usize] = b"ATTACH_TIMEOUT_SECS\x00";
pub const OCIXSTREAM_ATTR_MAX_ATTACH_RETRIES: &'static [u8; 19usize] = b"MAX_ATTACH_RETRIES\x00";
pub const OCIXSTREAM_OUT_ATTACH_RESERVED_1: ::std::os::raw::c_uint = 1;
pub const OCIXSTREAM_OUT_ATTACH_APP_FREE_LCR: ::std::os::raw::c_uint = 2;
pub const OCIXSTREAM_IN_ATTACH_RESTART_INBOUND: ::std::os::raw::c_uint = 1;
pub const OCIXSTREAM_IN_DETACH_RESTART_INBOUND: ::std::os::raw::c_uint = 1;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: f64,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(::std::mem::size_of::<max_align_t>(),
               32usize,
               concat!("Size of: ", stringify!(max_align_t)));
    assert_eq!(unsafe {
                   &(*(0 as *const max_align_t)).__clang_max_align_nonce1 as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(max_align_t),
                       "::",
                       stringify!(__clang_max_align_nonce1)));
    assert_eq!(unsafe {
                   &(*(0 as *const max_align_t)).__clang_max_align_nonce2 as *const _ as usize
               },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(max_align_t),
                       "::",
                       stringify!(__clang_max_align_nonce2)));
}
impl Clone for max_align_t {
    fn clone(&self) -> Self {
        *self
    }
}
pub type ub1 = ::std::os::raw::c_uchar;
pub type sb1 = ::std::os::raw::c_schar;
pub type eb1 = ::std::os::raw::c_char;
pub type b1 = sb1;
pub type ub2 = ::std::os::raw::c_ushort;
pub type sb2 = ::std::os::raw::c_short;
pub type eb2 = ::std::os::raw::c_short;
pub type b2 = sb2;
pub type ub4 = ::std::os::raw::c_uint;
pub type sb4 = ::std::os::raw::c_int;
pub type eb4 = ::std::os::raw::c_int;
pub type oraub8 = ::std::os::raw::c_ulong;
pub type orasb8 = ::std::os::raw::c_long;
pub type ub8 = oraub8;
pub type sb8 = orasb8;
pub type b4 = sb4;
pub type oratext = ::std::os::raw::c_uchar;
pub type text = oratext;
pub type OraText = oratext;
pub type string = *mut OraText;
pub type utext = ::std::os::raw::c_ushort;
pub type boolean = ::std::os::raw::c_int;
pub type eword = ::std::os::raw::c_int;
pub type uword = ::std::os::raw::c_uint;
pub type sword = ::std::os::raw::c_int;
pub type ubig_ora = ::std::os::raw::c_ulong;
pub type sbig_ora = ::std::os::raw::c_long;
pub type lgenfp_t = ::std::option::Option<unsafe extern "C" fn()>;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(::std::mem::size_of::<__fsid_t>(),
               8usize,
               concat!("Size of: ", stringify!(__fsid_t)));
    assert_eq!(::std::mem::align_of::<__fsid_t>(),
               4usize,
               concat!("Alignment of ", stringify!(__fsid_t)));
    assert_eq!(unsafe { &(*(0 as *const __fsid_t)).__val as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(__fsid_t),
                       "::",
                       stringify!(__val)));
}
impl Clone for __fsid_t {
    fn clone(&self) -> Self {
        *self
    }
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __qaddr_t = *mut __quad_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type time_t = __time_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulong;
pub type register_t = ::std::os::raw::c_long;
pub type __sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(::std::mem::size_of::<__sigset_t>(),
               128usize,
               concat!("Size of: ", stringify!(__sigset_t)));
    assert_eq!(::std::mem::align_of::<__sigset_t>(),
               8usize,
               concat!("Alignment of ", stringify!(__sigset_t)));
    assert_eq!(unsafe { &(*(0 as *const __sigset_t)).__val as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(__sigset_t),
                       "::",
                       stringify!(__val)));
}
impl Clone for __sigset_t {
    fn clone(&self) -> Self {
        *self
    }
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(::std::mem::size_of::<timespec>(),
               16usize,
               concat!("Size of: ", stringify!(timespec)));
    assert_eq!(::std::mem::align_of::<timespec>(),
               8usize,
               concat!("Alignment of ", stringify!(timespec)));
    assert_eq!(unsafe { &(*(0 as *const timespec)).tv_sec as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(timespec),
                       "::",
                       stringify!(tv_sec)));
    assert_eq!(unsafe { &(*(0 as *const timespec)).tv_nsec as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(timespec),
                       "::",
                       stringify!(tv_nsec)));
}
impl Clone for timespec {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(::std::mem::size_of::<timeval>(),
               16usize,
               concat!("Size of: ", stringify!(timeval)));
    assert_eq!(::std::mem::align_of::<timeval>(),
               8usize,
               concat!("Alignment of ", stringify!(timeval)));
    assert_eq!(unsafe { &(*(0 as *const timeval)).tv_sec as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(timeval),
                       "::",
                       stringify!(tv_sec)));
    assert_eq!(unsafe { &(*(0 as *const timeval)).tv_usec as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(timeval),
                       "::",
                       stringify!(tv_usec)));
}
impl Clone for timeval {
    fn clone(&self) -> Self {
        *self
    }
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(::std::mem::size_of::<fd_set>(),
               128usize,
               concat!("Size of: ", stringify!(fd_set)));
    assert_eq!(::std::mem::align_of::<fd_set>(),
               8usize,
               concat!("Alignment of ", stringify!(fd_set)));
    assert_eq!(unsafe { &(*(0 as *const fd_set)).__fds_bits as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(fd_set),
                       "::",
                       stringify!(__fds_bits)));
}
impl Clone for fd_set {
    fn clone(&self) -> Self {
        *self
    }
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(__nfds: ::std::os::raw::c_int,
                  __readfds: *mut fd_set,
                  __writefds: *mut fd_set,
                  __exceptfds: *mut fd_set,
                  __timeout: *mut timeval)
                  -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(__nfds: ::std::os::raw::c_int,
                   __readfds: *mut fd_set,
                   __writefds: *mut fd_set,
                   __exceptfds: *mut fd_set,
                   __timeout: *const timespec,
                   __sigmask: *const __sigset_t)
                   -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnu_dev_major(__dev: ::std::os::raw::c_ulonglong) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnu_dev_minor(__dev: ::std::os::raw::c_ulonglong) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnu_dev_makedev(__major: ::std::os::raw::c_uint,
                           __minor: ::std::os::raw::c_uint)
                           -> ::std::os::raw::c_ulonglong;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(::std::mem::size_of::<pthread_attr_t>(),
               56usize,
               concat!("Size of: ", stringify!(pthread_attr_t)));
    assert_eq!(::std::mem::align_of::<pthread_attr_t>(),
               8usize,
               concat!("Alignment of ", stringify!(pthread_attr_t)));
    assert_eq!(unsafe { &(*(0 as *const pthread_attr_t)).__size as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(pthread_attr_t),
                       "::",
                       stringify!(__size)));
    assert_eq!(unsafe { &(*(0 as *const pthread_attr_t)).__align as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(pthread_attr_t),
                       "::",
                       stringify!(__align)));
}
impl Clone for pthread_attr_t {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(::std::mem::size_of::<__pthread_internal_list>(),
               16usize,
               concat!("Size of: ", stringify!(__pthread_internal_list)));
    assert_eq!(::std::mem::align_of::<__pthread_internal_list>(),
               8usize,
               concat!("Alignment of ", stringify!(__pthread_internal_list)));
    assert_eq!(unsafe { &(*(0 as *const __pthread_internal_list)).__prev as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(__pthread_internal_list),
                       "::",
                       stringify!(__prev)));
    assert_eq!(unsafe { &(*(0 as *const __pthread_internal_list)).__next as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(__pthread_internal_list),
                       "::",
                       stringify!(__next)));
}
impl Clone for __pthread_internal_list {
    fn clone(&self) -> Self {
        *self
    }
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Copy)]
pub union pthread_mutex_t {
    pub __data: pthread_mutex_t___pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_mutex_t___pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t___pthread_mutex_s() {
    assert_eq!(::std::mem::size_of::<pthread_mutex_t___pthread_mutex_s>(),
               40usize,
               concat!("Size of: ", stringify!(pthread_mutex_t___pthread_mutex_s)));
    assert_eq!(::std::mem::align_of::<pthread_mutex_t___pthread_mutex_s>(),
               8usize,
               concat!("Alignment of ",
                       stringify!(pthread_mutex_t___pthread_mutex_s)));
    assert_eq!(unsafe {
                   &(*(0 as *const pthread_mutex_t___pthread_mutex_s)).__lock as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(pthread_mutex_t___pthread_mutex_s),
                       "::",
                       stringify!(__lock)));
    assert_eq!(unsafe {
                   &(*(0 as *const pthread_mutex_t___pthread_mutex_s)).__count as *const _ as usize
               },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(pthread_mutex_t___pthread_mutex_s),
                       "::",
                       stringify!(__count)));
    assert_eq!(unsafe {
                   &(*(0 as *const pthread_mutex_t___pthread_mutex_s)).__owner as *const _ as usize
               },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(pthread_mutex_t___pthread_mutex_s),
                       "::",
                       stringify!(__owner)));
    assert_eq!(unsafe {
                   &(*(0 as *const pthread_mutex_t___pthread_mutex_s)).__nusers as *const _ as usize
               },
               12usize,
               concat!("Alignment of field: ",
                       stringify!(pthread_mutex_t___pthread_mutex_s),
                       "::",
                       stringify!(__nusers)));
    assert_eq!(unsafe {
                   &(*(0 as *const pthread_mutex_t___pthread_mutex_s)).__kind as *const _ as usize
               },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(pthread_mutex_t___pthread_mutex_s),
                       "::",
                       stringify!(__kind)));
    assert_eq!(unsafe {
                   &(*(0 as *const pthread_mutex_t___pthread_mutex_s)).__spins as *const _ as usize
               },
               20usize,
               concat!("Alignment of field: ",
                       stringify!(pthread_mutex_t___pthread_mutex_s),
                       "::",
                       stringify!(__spins)));
    assert_eq!(unsafe {
                   &(*(0 as *const pthread_mutex_t___pthread_mutex_s)).__elision as *const _ as
                   usize
               },
               22usize,
               concat!("Alignment of field: ",
                       stringify!(pthread_mutex_t___pthread_mutex_s),
                       "::",
                       stringify!(__elision)));
    assert_eq!(unsafe {
                   &(*(0 as *const pthread_mutex_t___pthread_mutex_s)).__list as *const _ as usize
               },
               24usize,
               concat!("Alignment of field: ",
                       stringify!(pthread_mutex_t___pthread_mutex_s),
                       "::",
                       stringify!(__list)));
}
impl Clone for pthread_mutex_t___pthread_mutex_s {
    fn clone(&self) -> Self {
        *self
    }
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(::std::mem::size_of::<pthread_mutex_t>(),
               40usize,
               concat!("Size of: ", stringify!(pthread_mutex_t)));
    assert_eq!(::std::mem::align_of::<pthread_mutex_t>(),
               8usize,
               concat!("Alignment of ", stringify!(pthread_mutex_t)));
    assert_eq!(unsafe { &(*(0 as *const pthread_mutex_t)).__data as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(pthread_mutex_t),
                       "::",
                       stringify!(__data)));
    assert_eq!(unsafe { &(*(0 as *const pthread_mutex_t)).__size as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(pthread_mutex_t),
                       "::",
                       stringify!(__size)));
    assert_eq!(unsafe { &(*(0 as *const pthread_mutex_t)).__align as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(pthread_mutex_t),
                       "::",
                       stringify!(__align)));
}
impl Clone for pthread_mutex_t {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Copy)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_mutexattr_t>(),
               4usize,
               concat!("Size of: ", stringify!(pthread_mutexattr_t)));
    assert_eq!(::std::mem::align_of::<pthread_mutexattr_t>(),
               4usize,
               concat!("Alignment of ", stringify!(pthread_mutexattr_t)));
    assert_eq!(unsafe { &(*(0 as *const pthread_mutexattr_t)).__size as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(pthread_mutexattr_t),
                       "::",
                       stringify!(__size)));
    assert_eq!(unsafe { &(*(0 as *const pthread_mutexattr_t)).__align as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(pthread_mutexattr_t),
                       "::",
                       stringify!(__align)));
}
impl Clone for pthread_mutexattr_t {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Copy)]
pub union pthread_cond_t {
    pub __data: pthread_cond_t__bindgen_ty_1,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
    _bindgen_union_align: [u64; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_cond_t__bindgen_ty_1 {
    pub __lock: ::std::os::raw::c_int,
    pub __futex: ::std::os::raw::c_uint,
    pub __total_seq: ::std::os::raw::c_ulonglong,
    pub __wakeup_seq: ::std::os::raw::c_ulonglong,
    pub __woken_seq: ::std::os::raw::c_ulonglong,
    pub __mutex: *mut ::std::os::raw::c_void,
    pub __nwaiters: ::std::os::raw::c_uint,
    pub __broadcast_seq: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_pthread_cond_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<pthread_cond_t__bindgen_ty_1>(),
               48usize,
               concat!("Size of: ", stringify!(pthread_cond_t__bindgen_ty_1)));
    assert_eq!(::std::mem::align_of::<pthread_cond_t__bindgen_ty_1>(),
               8usize,
               concat!("Alignment of ", stringify!(pthread_cond_t__bindgen_ty_1)));
    assert_eq!(unsafe {
                   &(*(0 as *const pthread_cond_t__bindgen_ty_1)).__lock as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(pthread_cond_t__bindgen_ty_1),
                       "::",
                       stringify!(__lock)));
    assert_eq!(unsafe {
                   &(*(0 as *const pthread_cond_t__bindgen_ty_1)).__futex as *const _ as usize
               },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(pthread_cond_t__bindgen_ty_1),
                       "::",
                       stringify!(__futex)));
    assert_eq!(unsafe {
                   &(*(0 as *const pthread_cond_t__bindgen_ty_1)).__total_seq as *const _ as usize
               },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(pthread_cond_t__bindgen_ty_1),
                       "::",
                       stringify!(__total_seq)));
    assert_eq!(unsafe {
                   &(*(0 as *const pthread_cond_t__bindgen_ty_1)).__wakeup_seq as *const _ as usize
               },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(pthread_cond_t__bindgen_ty_1),
                       "::",
                       stringify!(__wakeup_seq)));
    assert_eq!(unsafe {
                   &(*(0 as *const pthread_cond_t__bindgen_ty_1)).__woken_seq as *const _ as usize
               },
               24usize,
               concat!("Alignment of field: ",
                       stringify!(pthread_cond_t__bindgen_ty_1),
                       "::",
                       stringify!(__woken_seq)));
    assert_eq!(unsafe {
                   &(*(0 as *const pthread_cond_t__bindgen_ty_1)).__mutex as *const _ as usize
               },
               32usize,
               concat!("Alignment of field: ",
                       stringify!(pthread_cond_t__bindgen_ty_1),
                       "::",
                       stringify!(__mutex)));
    assert_eq!(unsafe {
                   &(*(0 as *const pthread_cond_t__bindgen_ty_1)).__nwaiters as *const _ as usize
               },
               40usize,
               concat!("Alignment of field: ",
                       stringify!(pthread_cond_t__bindgen_ty_1),
                       "::",
                       stringify!(__nwaiters)));
    assert_eq!(unsafe {
                   &(*(0 as *const pthread_cond_t__bindgen_ty_1)).__broadcast_seq as *const _ as
                   usize
               },
               44usize,
               concat!("Alignment of field: ",
                       stringify!(pthread_cond_t__bindgen_ty_1),
                       "::",
                       stringify!(__broadcast_seq)));
}
impl Clone for pthread_cond_t__bindgen_ty_1 {
    fn clone(&self) -> Self {
        *self
    }
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(::std::mem::size_of::<pthread_cond_t>(),
               48usize,
               concat!("Size of: ", stringify!(pthread_cond_t)));
    assert_eq!(::std::mem::align_of::<pthread_cond_t>(),
               8usize,
               concat!("Alignment of ", stringify!(pthread_cond_t)));
    assert_eq!(unsafe { &(*(0 as *const pthread_cond_t)).__data as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(pthread_cond_t),
                       "::",
                       stringify!(__data)));
    assert_eq!(unsafe { &(*(0 as *const pthread_cond_t)).__size as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(pthread_cond_t),
                       "::",
                       stringify!(__size)));
    assert_eq!(unsafe { &(*(0 as *const pthread_cond_t)).__align as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(pthread_cond_t),
                       "::",
                       stringify!(__align)));
}
impl Clone for pthread_cond_t {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Copy)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_condattr_t>(),
               4usize,
               concat!("Size of: ", stringify!(pthread_condattr_t)));
    assert_eq!(::std::mem::align_of::<pthread_condattr_t>(),
               4usize,
               concat!("Alignment of ", stringify!(pthread_condattr_t)));
    assert_eq!(unsafe { &(*(0 as *const pthread_condattr_t)).__size as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(pthread_condattr_t),
                       "::",
                       stringify!(__size)));
    assert_eq!(unsafe { &(*(0 as *const pthread_condattr_t)).__align as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(pthread_condattr_t),
                       "::",
                       stringify!(__align)));
}
impl Clone for pthread_condattr_t {
    fn clone(&self) -> Self {
        *self
    }
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy)]
pub union pthread_rwlock_t {
    pub __data: pthread_rwlock_t__bindgen_ty_1,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_rwlock_t__bindgen_ty_1 {
    pub __lock: ::std::os::raw::c_int,
    pub __nr_readers: ::std::os::raw::c_uint,
    pub __readers_wakeup: ::std::os::raw::c_uint,
    pub __writer_wakeup: ::std::os::raw::c_uint,
    pub __nr_readers_queued: ::std::os::raw::c_uint,
    pub __nr_writers_queued: ::std::os::raw::c_uint,
    pub __writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<pthread_rwlock_t__bindgen_ty_1>(),
               56usize,
               concat!("Size of: ", stringify!(pthread_rwlock_t__bindgen_ty_1)));
    assert_eq!(::std::mem::align_of::<pthread_rwlock_t__bindgen_ty_1>(),
               8usize,
               concat!("Alignment of ", stringify!(pthread_rwlock_t__bindgen_ty_1)));
    assert_eq!(unsafe {
                   &(*(0 as *const pthread_rwlock_t__bindgen_ty_1)).__lock as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(pthread_rwlock_t__bindgen_ty_1),
                       "::",
                       stringify!(__lock)));
    assert_eq!(unsafe {
                   &(*(0 as *const pthread_rwlock_t__bindgen_ty_1)).__nr_readers as *const _ as
                   usize
               },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(pthread_rwlock_t__bindgen_ty_1),
                       "::",
                       stringify!(__nr_readers)));
    assert_eq!(unsafe {
                   &(*(0 as *const pthread_rwlock_t__bindgen_ty_1)).__readers_wakeup as *const _ as
                   usize
               },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(pthread_rwlock_t__bindgen_ty_1),
                       "::",
                       stringify!(__readers_wakeup)));
    assert_eq!(unsafe {
                   &(*(0 as *const pthread_rwlock_t__bindgen_ty_1)).__writer_wakeup as *const _ as
                   usize
               },
               12usize,
               concat!("Alignment of field: ",
                       stringify!(pthread_rwlock_t__bindgen_ty_1),
                       "::",
                       stringify!(__writer_wakeup)));
    assert_eq!(unsafe {
                   &(*(0 as *const pthread_rwlock_t__bindgen_ty_1)).__nr_readers_queued as
                   *const _ as usize
               },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(pthread_rwlock_t__bindgen_ty_1),
                       "::",
                       stringify!(__nr_readers_queued)));
    assert_eq!(unsafe {
                   &(*(0 as *const pthread_rwlock_t__bindgen_ty_1)).__nr_writers_queued as
                   *const _ as usize
               },
               20usize,
               concat!("Alignment of field: ",
                       stringify!(pthread_rwlock_t__bindgen_ty_1),
                       "::",
                       stringify!(__nr_writers_queued)));
    assert_eq!(unsafe {
                   &(*(0 as *const pthread_rwlock_t__bindgen_ty_1)).__writer as *const _ as usize
               },
               24usize,
               concat!("Alignment of field: ",
                       stringify!(pthread_rwlock_t__bindgen_ty_1),
                       "::",
                       stringify!(__writer)));
    assert_eq!(unsafe {
                   &(*(0 as *const pthread_rwlock_t__bindgen_ty_1)).__shared as *const _ as usize
               },
               28usize,
               concat!("Alignment of field: ",
                       stringify!(pthread_rwlock_t__bindgen_ty_1),
                       "::",
                       stringify!(__shared)));
    assert_eq!(unsafe {
                   &(*(0 as *const pthread_rwlock_t__bindgen_ty_1)).__rwelision as *const _ as usize
               },
               32usize,
               concat!("Alignment of field: ",
                       stringify!(pthread_rwlock_t__bindgen_ty_1),
                       "::",
                       stringify!(__rwelision)));
    assert_eq!(unsafe {
                   &(*(0 as *const pthread_rwlock_t__bindgen_ty_1)).__pad1 as *const _ as usize
               },
               33usize,
               concat!("Alignment of field: ",
                       stringify!(pthread_rwlock_t__bindgen_ty_1),
                       "::",
                       stringify!(__pad1)));
    assert_eq!(unsafe {
                   &(*(0 as *const pthread_rwlock_t__bindgen_ty_1)).__pad2 as *const _ as usize
               },
               40usize,
               concat!("Alignment of field: ",
                       stringify!(pthread_rwlock_t__bindgen_ty_1),
                       "::",
                       stringify!(__pad2)));
    assert_eq!(unsafe {
                   &(*(0 as *const pthread_rwlock_t__bindgen_ty_1)).__flags as *const _ as usize
               },
               48usize,
               concat!("Alignment of field: ",
                       stringify!(pthread_rwlock_t__bindgen_ty_1),
                       "::",
                       stringify!(__flags)));
}
impl Clone for pthread_rwlock_t__bindgen_ty_1 {
    fn clone(&self) -> Self {
        *self
    }
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(::std::mem::size_of::<pthread_rwlock_t>(),
               56usize,
               concat!("Size of: ", stringify!(pthread_rwlock_t)));
    assert_eq!(::std::mem::align_of::<pthread_rwlock_t>(),
               8usize,
               concat!("Alignment of ", stringify!(pthread_rwlock_t)));
    assert_eq!(unsafe { &(*(0 as *const pthread_rwlock_t)).__data as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(pthread_rwlock_t),
                       "::",
                       stringify!(__data)));
    assert_eq!(unsafe { &(*(0 as *const pthread_rwlock_t)).__size as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(pthread_rwlock_t),
                       "::",
                       stringify!(__size)));
    assert_eq!(unsafe { &(*(0 as *const pthread_rwlock_t)).__align as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(pthread_rwlock_t),
                       "::",
                       stringify!(__align)));
}
impl Clone for pthread_rwlock_t {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Copy)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_rwlockattr_t>(),
               8usize,
               concat!("Size of: ", stringify!(pthread_rwlockattr_t)));
    assert_eq!(::std::mem::align_of::<pthread_rwlockattr_t>(),
               8usize,
               concat!("Alignment of ", stringify!(pthread_rwlockattr_t)));
    assert_eq!(unsafe { &(*(0 as *const pthread_rwlockattr_t)).__size as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(pthread_rwlockattr_t),
                       "::",
                       stringify!(__size)));
    assert_eq!(unsafe { &(*(0 as *const pthread_rwlockattr_t)).__align as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(pthread_rwlockattr_t),
                       "::",
                       stringify!(__align)));
}
impl Clone for pthread_rwlockattr_t {
    fn clone(&self) -> Self {
        *self
    }
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(::std::mem::size_of::<pthread_barrier_t>(),
               32usize,
               concat!("Size of: ", stringify!(pthread_barrier_t)));
    assert_eq!(::std::mem::align_of::<pthread_barrier_t>(),
               8usize,
               concat!("Alignment of ", stringify!(pthread_barrier_t)));
    assert_eq!(unsafe { &(*(0 as *const pthread_barrier_t)).__size as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(pthread_barrier_t),
                       "::",
                       stringify!(__size)));
    assert_eq!(unsafe { &(*(0 as *const pthread_barrier_t)).__align as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(pthread_barrier_t),
                       "::",
                       stringify!(__align)));
}
impl Clone for pthread_barrier_t {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Copy)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_barrierattr_t>(),
               4usize,
               concat!("Size of: ", stringify!(pthread_barrierattr_t)));
    assert_eq!(::std::mem::align_of::<pthread_barrierattr_t>(),
               4usize,
               concat!("Alignment of ", stringify!(pthread_barrierattr_t)));
    assert_eq!(unsafe { &(*(0 as *const pthread_barrierattr_t)).__size as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(pthread_barrierattr_t),
                       "::",
                       stringify!(__size)));
    assert_eq!(unsafe { &(*(0 as *const pthread_barrierattr_t)).__align as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(pthread_barrierattr_t),
                       "::",
                       stringify!(__align)));
}
impl Clone for pthread_barrierattr_t {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cda_head {
    pub v2_rc: sb2,
    pub ft: ub2,
    pub rpc: ub4,
    pub peo: ub2,
    pub fc: ub1,
    pub rcs1: ub1,
    pub rc: ub2,
    pub wrn: ub1,
    pub rcs2: ub1,
    pub rcs3: sword,
    pub rid: cda_head__bindgen_ty_1,
    pub ose: sword,
    pub chk: ub1,
    pub rcsp: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cda_head__bindgen_ty_1 {
    pub rd: cda_head__bindgen_ty_1__bindgen_ty_1,
    pub rcs7: ub4,
    pub rcs8: ub2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cda_head__bindgen_ty_1__bindgen_ty_1 {
    pub rcs4: ub4,
    pub rcs5: ub2,
    pub rcs6: ub1,
}
#[test]
fn bindgen_test_layout_cda_head__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<cda_head__bindgen_ty_1__bindgen_ty_1>(),
               8usize,
               concat!("Size of: ",
                       stringify!(cda_head__bindgen_ty_1__bindgen_ty_1)));
    assert_eq!(::std::mem::align_of::<cda_head__bindgen_ty_1__bindgen_ty_1>(),
               4usize,
               concat!("Alignment of ",
                       stringify!(cda_head__bindgen_ty_1__bindgen_ty_1)));
    assert_eq!(unsafe {
                   &(*(0 as *const cda_head__bindgen_ty_1__bindgen_ty_1)).rcs4 as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(cda_head__bindgen_ty_1__bindgen_ty_1),
                       "::",
                       stringify!(rcs4)));
    assert_eq!(unsafe {
                   &(*(0 as *const cda_head__bindgen_ty_1__bindgen_ty_1)).rcs5 as *const _ as usize
               },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(cda_head__bindgen_ty_1__bindgen_ty_1),
                       "::",
                       stringify!(rcs5)));
    assert_eq!(unsafe {
                   &(*(0 as *const cda_head__bindgen_ty_1__bindgen_ty_1)).rcs6 as *const _ as usize
               },
               6usize,
               concat!("Alignment of field: ",
                       stringify!(cda_head__bindgen_ty_1__bindgen_ty_1),
                       "::",
                       stringify!(rcs6)));
}
impl Clone for cda_head__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self {
        *self
    }
}
#[test]
fn bindgen_test_layout_cda_head__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<cda_head__bindgen_ty_1>(),
               16usize,
               concat!("Size of: ", stringify!(cda_head__bindgen_ty_1)));
    assert_eq!(::std::mem::align_of::<cda_head__bindgen_ty_1>(),
               4usize,
               concat!("Alignment of ", stringify!(cda_head__bindgen_ty_1)));
    assert_eq!(unsafe { &(*(0 as *const cda_head__bindgen_ty_1)).rd as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(cda_head__bindgen_ty_1),
                       "::",
                       stringify!(rd)));
    assert_eq!(unsafe { &(*(0 as *const cda_head__bindgen_ty_1)).rcs7 as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(cda_head__bindgen_ty_1),
                       "::",
                       stringify!(rcs7)));
    assert_eq!(unsafe { &(*(0 as *const cda_head__bindgen_ty_1)).rcs8 as *const _ as usize },
               12usize,
               concat!("Alignment of field: ",
                       stringify!(cda_head__bindgen_ty_1),
                       "::",
                       stringify!(rcs8)));
}
impl Clone for cda_head__bindgen_ty_1 {
    fn clone(&self) -> Self {
        *self
    }
}
#[test]
fn bindgen_test_layout_cda_head() {
    assert_eq!(::std::mem::size_of::<cda_head>(),
               56usize,
               concat!("Size of: ", stringify!(cda_head)));
    assert_eq!(::std::mem::align_of::<cda_head>(),
               8usize,
               concat!("Alignment of ", stringify!(cda_head)));
    assert_eq!(unsafe { &(*(0 as *const cda_head)).v2_rc as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(cda_head),
                       "::",
                       stringify!(v2_rc)));
    assert_eq!(unsafe { &(*(0 as *const cda_head)).ft as *const _ as usize },
               2usize,
               concat!("Alignment of field: ",
                       stringify!(cda_head),
                       "::",
                       stringify!(ft)));
    assert_eq!(unsafe { &(*(0 as *const cda_head)).rpc as *const _ as usize },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(cda_head),
                       "::",
                       stringify!(rpc)));
    assert_eq!(unsafe { &(*(0 as *const cda_head)).peo as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(cda_head),
                       "::",
                       stringify!(peo)));
    assert_eq!(unsafe { &(*(0 as *const cda_head)).fc as *const _ as usize },
               10usize,
               concat!("Alignment of field: ",
                       stringify!(cda_head),
                       "::",
                       stringify!(fc)));
    assert_eq!(unsafe { &(*(0 as *const cda_head)).rcs1 as *const _ as usize },
               11usize,
               concat!("Alignment of field: ",
                       stringify!(cda_head),
                       "::",
                       stringify!(rcs1)));
    assert_eq!(unsafe { &(*(0 as *const cda_head)).rc as *const _ as usize },
               12usize,
               concat!("Alignment of field: ",
                       stringify!(cda_head),
                       "::",
                       stringify!(rc)));
    assert_eq!(unsafe { &(*(0 as *const cda_head)).wrn as *const _ as usize },
               14usize,
               concat!("Alignment of field: ",
                       stringify!(cda_head),
                       "::",
                       stringify!(wrn)));
    assert_eq!(unsafe { &(*(0 as *const cda_head)).rcs2 as *const _ as usize },
               15usize,
               concat!("Alignment of field: ",
                       stringify!(cda_head),
                       "::",
                       stringify!(rcs2)));
    assert_eq!(unsafe { &(*(0 as *const cda_head)).rcs3 as *const _ as usize },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(cda_head),
                       "::",
                       stringify!(rcs3)));
    assert_eq!(unsafe { &(*(0 as *const cda_head)).rid as *const _ as usize },
               20usize,
               concat!("Alignment of field: ",
                       stringify!(cda_head),
                       "::",
                       stringify!(rid)));
    assert_eq!(unsafe { &(*(0 as *const cda_head)).ose as *const _ as usize },
               36usize,
               concat!("Alignment of field: ",
                       stringify!(cda_head),
                       "::",
                       stringify!(ose)));
    assert_eq!(unsafe { &(*(0 as *const cda_head)).chk as *const _ as usize },
               40usize,
               concat!("Alignment of field: ",
                       stringify!(cda_head),
                       "::",
                       stringify!(chk)));
    assert_eq!(unsafe { &(*(0 as *const cda_head)).rcsp as *const _ as usize },
               48usize,
               concat!("Alignment of field: ",
                       stringify!(cda_head),
                       "::",
                       stringify!(rcsp)));
}
impl Clone for cda_head {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cda_def {
    pub v2_rc: sb2,
    pub ft: ub2,
    pub rpc: ub4,
    pub peo: ub2,
    pub fc: ub1,
    pub rcs1: ub1,
    pub rc: ub2,
    pub wrn: ub1,
    pub rcs2: ub1,
    pub rcs3: sword,
    pub rid: cda_def__bindgen_ty_1,
    pub ose: sword,
    pub chk: ub1,
    pub rcsp: *mut ::std::os::raw::c_void,
    pub rcs9: [ub1; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cda_def__bindgen_ty_1 {
    pub rd: cda_def__bindgen_ty_1__bindgen_ty_1,
    pub rcs7: ub4,
    pub rcs8: ub2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cda_def__bindgen_ty_1__bindgen_ty_1 {
    pub rcs4: ub4,
    pub rcs5: ub2,
    pub rcs6: ub1,
}
#[test]
fn bindgen_test_layout_cda_def__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<cda_def__bindgen_ty_1__bindgen_ty_1>(),
               8usize,
               concat!("Size of: ", stringify!(cda_def__bindgen_ty_1__bindgen_ty_1)));
    assert_eq!(::std::mem::align_of::<cda_def__bindgen_ty_1__bindgen_ty_1>(),
               4usize,
               concat!("Alignment of ",
                       stringify!(cda_def__bindgen_ty_1__bindgen_ty_1)));
    assert_eq!(unsafe {
                   &(*(0 as *const cda_def__bindgen_ty_1__bindgen_ty_1)).rcs4 as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(cda_def__bindgen_ty_1__bindgen_ty_1),
                       "::",
                       stringify!(rcs4)));
    assert_eq!(unsafe {
                   &(*(0 as *const cda_def__bindgen_ty_1__bindgen_ty_1)).rcs5 as *const _ as usize
               },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(cda_def__bindgen_ty_1__bindgen_ty_1),
                       "::",
                       stringify!(rcs5)));
    assert_eq!(unsafe {
                   &(*(0 as *const cda_def__bindgen_ty_1__bindgen_ty_1)).rcs6 as *const _ as usize
               },
               6usize,
               concat!("Alignment of field: ",
                       stringify!(cda_def__bindgen_ty_1__bindgen_ty_1),
                       "::",
                       stringify!(rcs6)));
}
impl Clone for cda_def__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self {
        *self
    }
}
#[test]
fn bindgen_test_layout_cda_def__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<cda_def__bindgen_ty_1>(),
               16usize,
               concat!("Size of: ", stringify!(cda_def__bindgen_ty_1)));
    assert_eq!(::std::mem::align_of::<cda_def__bindgen_ty_1>(),
               4usize,
               concat!("Alignment of ", stringify!(cda_def__bindgen_ty_1)));
    assert_eq!(unsafe { &(*(0 as *const cda_def__bindgen_ty_1)).rd as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(cda_def__bindgen_ty_1),
                       "::",
                       stringify!(rd)));
    assert_eq!(unsafe { &(*(0 as *const cda_def__bindgen_ty_1)).rcs7 as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(cda_def__bindgen_ty_1),
                       "::",
                       stringify!(rcs7)));
    assert_eq!(unsafe { &(*(0 as *const cda_def__bindgen_ty_1)).rcs8 as *const _ as usize },
               12usize,
               concat!("Alignment of field: ",
                       stringify!(cda_def__bindgen_ty_1),
                       "::",
                       stringify!(rcs8)));
}
impl Clone for cda_def__bindgen_ty_1 {
    fn clone(&self) -> Self {
        *self
    }
}
#[test]
fn bindgen_test_layout_cda_def() {
    assert_eq!(::std::mem::size_of::<cda_def>(),
               64usize,
               concat!("Size of: ", stringify!(cda_def)));
    assert_eq!(::std::mem::align_of::<cda_def>(),
               8usize,
               concat!("Alignment of ", stringify!(cda_def)));
    assert_eq!(unsafe { &(*(0 as *const cda_def)).v2_rc as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(cda_def),
                       "::",
                       stringify!(v2_rc)));
    assert_eq!(unsafe { &(*(0 as *const cda_def)).ft as *const _ as usize },
               2usize,
               concat!("Alignment of field: ",
                       stringify!(cda_def),
                       "::",
                       stringify!(ft)));
    assert_eq!(unsafe { &(*(0 as *const cda_def)).rpc as *const _ as usize },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(cda_def),
                       "::",
                       stringify!(rpc)));
    assert_eq!(unsafe { &(*(0 as *const cda_def)).peo as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(cda_def),
                       "::",
                       stringify!(peo)));
    assert_eq!(unsafe { &(*(0 as *const cda_def)).fc as *const _ as usize },
               10usize,
               concat!("Alignment of field: ",
                       stringify!(cda_def),
                       "::",
                       stringify!(fc)));
    assert_eq!(unsafe { &(*(0 as *const cda_def)).rcs1 as *const _ as usize },
               11usize,
               concat!("Alignment of field: ",
                       stringify!(cda_def),
                       "::",
                       stringify!(rcs1)));
    assert_eq!(unsafe { &(*(0 as *const cda_def)).rc as *const _ as usize },
               12usize,
               concat!("Alignment of field: ",
                       stringify!(cda_def),
                       "::",
                       stringify!(rc)));
    assert_eq!(unsafe { &(*(0 as *const cda_def)).wrn as *const _ as usize },
               14usize,
               concat!("Alignment of field: ",
                       stringify!(cda_def),
                       "::",
                       stringify!(wrn)));
    assert_eq!(unsafe { &(*(0 as *const cda_def)).rcs2 as *const _ as usize },
               15usize,
               concat!("Alignment of field: ",
                       stringify!(cda_def),
                       "::",
                       stringify!(rcs2)));
    assert_eq!(unsafe { &(*(0 as *const cda_def)).rcs3 as *const _ as usize },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(cda_def),
                       "::",
                       stringify!(rcs3)));
    assert_eq!(unsafe { &(*(0 as *const cda_def)).rid as *const _ as usize },
               20usize,
               concat!("Alignment of field: ",
                       stringify!(cda_def),
                       "::",
                       stringify!(rid)));
    assert_eq!(unsafe { &(*(0 as *const cda_def)).ose as *const _ as usize },
               36usize,
               concat!("Alignment of field: ",
                       stringify!(cda_def),
                       "::",
                       stringify!(ose)));
    assert_eq!(unsafe { &(*(0 as *const cda_def)).chk as *const _ as usize },
               40usize,
               concat!("Alignment of field: ",
                       stringify!(cda_def),
                       "::",
                       stringify!(chk)));
    assert_eq!(unsafe { &(*(0 as *const cda_def)).rcsp as *const _ as usize },
               48usize,
               concat!("Alignment of field: ",
                       stringify!(cda_def),
                       "::",
                       stringify!(rcsp)));
    assert_eq!(unsafe { &(*(0 as *const cda_def)).rcs9 as *const _ as usize },
               56usize,
               concat!("Alignment of field: ",
                       stringify!(cda_def),
                       "::",
                       stringify!(rcs9)));
}
impl Clone for cda_def {
    fn clone(&self) -> Self {
        *self
    }
}
pub type Cda_Def = cda_def;
pub type Lda_Def = cda_def;
pub type Hda_AlignType = ub8;
pub type Hda_Def = [Hda_AlignType; 32usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIEnv {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIError {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCISvcCtx {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIStmt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIBind {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIDefine {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIDescribe {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIServer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCISession {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIComplexObject {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCITrans {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCISecurity {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCISubscription {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCICPool {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCISPool {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIAuthInfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIAdmin {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIEvent {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCISnapshot {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIResult {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCILobLocator {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCILobRegion {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIParam {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIComplexObjectComp {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIRowid {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIDateTime {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIInterval {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIUcb {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIServerDNs {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIAQEnqOptions {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIAQDeqOptions {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIAQMsgProperties {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIAQAgent {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIAQNfyDescriptor {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIAQSignature {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIAQListenOpts {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIAQLisMsgProps {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIAQJmsgProperties {
    _unused: [u8; 0],
}
pub type OCIClobLocator = OCILobLocator;
pub type OCIBlobLocator = OCILobLocator;
pub type OCIBFileLocator = OCILobLocator;
pub type OCILobOffset = ub4;
pub type OCILobLength = ub4;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum OCILobMode {
    OCI_LOBMODE_READONLY = 1,
    OCI_LOBMODE_READWRITE = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIPicklerTdsCtx {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIPicklerTds {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIPicklerImage {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIPicklerFdo {
    _unused: [u8; 0],
}
pub type OCIPicklerTdsElement = ub4;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIAnyData {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIAnyDataSet {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIAnyDataCtx {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIMsg {
    _unused: [u8; 0],
}
pub type OCIWchar = ub4;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct OCIIOV {
    pub bfp: *mut ::std::os::raw::c_void,
    pub bfl: ub4,
}
#[test]
fn bindgen_test_layout_OCIIOV() {
    assert_eq!(::std::mem::size_of::<OCIIOV>(),
               16usize,
               concat!("Size of: ", stringify!(OCIIOV)));
    assert_eq!(::std::mem::align_of::<OCIIOV>(),
               8usize,
               concat!("Alignment of ", stringify!(OCIIOV)));
    assert_eq!(unsafe { &(*(0 as *const OCIIOV)).bfp as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(OCIIOV),
                       "::",
                       stringify!(bfp)));
    assert_eq!(unsafe { &(*(0 as *const OCIIOV)).bfl as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(OCIIOV),
                       "::",
                       stringify!(bfl)));
}
impl Clone for OCIIOV {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIFileObject {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIThreadContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIThreadMutex {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIThreadKey {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIThreadId {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIThreadHandle {
    _unused: [u8; 0],
}
pub type OCIThreadKeyDestFunc =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIRef {
    _unused: [u8; 0],
}
pub type OCIInd = sb2;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum OCIPinOpt {
    OCI_PIN_DEFAULT = 1,
    OCI_PIN_ANY = 3,
    OCI_PIN_RECENT = 4,
    OCI_PIN_LATEST = 5,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum OCILockOpt {
    OCI_LOCK_NONE = 1,
    OCI_LOCK_X = 2,
    OCI_LOCK_X_NOWAIT = 3,
}
pub const OCIMarkOpt_OCI_MARK_NONE: OCIMarkOpt = OCIMarkOpt::OCI_MARK_DEFAULT;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum OCIMarkOpt {
    OCI_MARK_DEFAULT = 1,
    OCI_MARK_UPDATE = 2,
}
pub type OCIDuration = ub2;
#[repr(u32)]
/// DO NOT USE OCIObjectProperty. IT IS UNSUPPORTED                          **
/// WILL BE REMOVED/CHANGED IN A FUTURE RELEASE                              **
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum OCIObjectProperty {
    OCI_OBJECTPROP_DIRTIED = 1,
    OCI_OBJECTPROP_LOADED = 2,
    OCI_OBJECTPROP_LOCKED = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum OCIRefreshOpt {
    OCI_REFRESH_LOADED = 1,
}
#[repr(u32)]
/// DO NOT USE OCIObjectEvent. IT IS UNSUPPORTED                             **
/// WILL BE REMOVED/CHANGED IN A FUTURE RELEASE                              **
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum OCIObjectEvent {
    OCI_OBJECTEVENT_BEFORE_FLUSH = 1,
    OCI_OBJECTEVENT_AFTER_FLUSH = 2,
    OCI_OBJECTEVENT_BEFORE_REFRESH = 3,
    OCI_OBJECTEVENT_AFTER_REFRESH = 4,
    OCI_OBJECTEVENT_WHEN_MARK_UPDATED = 5,
    OCI_OBJECTEVENT_WHEN_MARK_DELETED = 6,
    OCI_OBJECTEVENT_WHEN_UNMARK = 7,
    OCI_OBJECTEVENT_WHEN_LOCK = 8,
}
pub type OCIObjectPropId = ub1;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum OCIObjectLifetime {
    OCI_OBJECT_PERSISTENT = 1,
    OCI_OBJECT_TRANSIENT = 2,
    OCI_OBJECT_VALUE = 3,
}
pub type OCIObjectMarkStatus = uword;
pub type OCITypeCode = ub2;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum OCITypeGetOpt {
    OCI_TYPEGET_HEADER = 0,
    OCI_TYPEGET_ALL = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum OCITypeEncap {
    OCI_TYPEENCAP_PRIVATE = 0,
    OCI_TYPEENCAP_PUBLIC = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum OCITypeMethodFlag {
    OCI_TYPEMETHOD_INLINE = 1,
    OCI_TYPEMETHOD_CONSTANT = 2,
    OCI_TYPEMETHOD_VIRTUAL = 4,
    OCI_TYPEMETHOD_CONSTRUCTOR = 8,
    OCI_TYPEMETHOD_DESTRUCTOR = 16,
    OCI_TYPEMETHOD_OPERATOR = 32,
    OCI_TYPEMETHOD_SELFISH = 64,
    OCI_TYPEMETHOD_MAP = 128,
    OCI_TYPEMETHOD_ORDER = 256,
    OCI_TYPEMETHOD_RNDS = 512,
    OCI_TYPEMETHOD_WNDS = 1024,
    OCI_TYPEMETHOD_RNPS = 2048,
    OCI_TYPEMETHOD_WNPS = 4096,
    OCI_TYPEMETHOD_ABSTRACT = 8192,
    OCI_TYPEMETHOD_OVERRIDING = 16384,
    OCI_TYPEMETHOD_PIPELINED = 32768,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum OCITypeParamMode {
    OCI_TYPEPARAM_IN = 0,
    OCI_TYPEPARAM_OUT = 1,
    OCI_TYPEPARAM_INOUT = 2,
    OCI_TYPEPARAM_BYREF = 3,
    OCI_TYPEPARAM_OUTNCPY = 4,
    OCI_TYPEPARAM_INOUTNCPY = 5,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIType {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCITypeElem {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCITypeMethod {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCITypeIter {
    _unused: [u8; 0],
}
extern "C" {
    pub fn OCITypeIterNew(env: *mut OCIEnv,
                          err: *mut OCIError,
                          tdo: *mut OCIType,
                          iterator_ort: *mut *mut OCITypeIter)
                          -> sword;
}
extern "C" {
    pub fn OCITypeIterSet(env: *mut OCIEnv,
                          err: *mut OCIError,
                          tdo: *mut OCIType,
                          iterator_ort: *mut OCITypeIter)
                          -> sword;
}
extern "C" {
    pub fn OCITypeIterFree(env: *mut OCIEnv,
                           err: *mut OCIError,
                           iterator_ort: *mut OCITypeIter)
                           -> sword;
}
extern "C" {
    pub fn OCITypeByName(env: *mut OCIEnv,
                         err: *mut OCIError,
                         svc: *const OCISvcCtx,
                         schema_name: *const oratext,
                         s_length: ub4,
                         type_name: *const oratext,
                         t_length: ub4,
                         version_name: *const oratext,
                         v_length: ub4,
                         pin_duration: OCIDuration,
                         get_option: OCITypeGetOpt,
                         tdo: *mut *mut OCIType)
                         -> sword;
}
extern "C" {
    pub fn OCITypeArrayByName(env: *mut OCIEnv,
                              err: *mut OCIError,
                              svc: *const OCISvcCtx,
                              array_len: ub4,
                              schema_name: *mut *const oratext,
                              s_length: *mut ub4,
                              type_name: *mut *const oratext,
                              t_length: *mut ub4,
                              version_name: *mut *const oratext,
                              v_length: *mut ub4,
                              pin_duration: OCIDuration,
                              get_option: OCITypeGetOpt,
                              tdo: *mut *mut OCIType)
                              -> sword;
}
extern "C" {
    pub fn OCITypeByFullName(env: *mut OCIEnv,
                             err: *mut OCIError,
                             svc: *const OCISvcCtx,
                             full_type_name: *const oratext,
                             full_type_name_length: ub4,
                             version_name: *const oratext,
                             version_name_length: ub4,
                             pin_duration: OCIDuration,
                             get_option: OCITypeGetOpt,
                             tdo: *mut *mut OCIType)
                             -> sword;
}
extern "C" {
    pub fn OCITypeArrayByFullName(env: *mut OCIEnv,
                                  err: *mut OCIError,
                                  svc: *const OCISvcCtx,
                                  array_len: ub4,
                                  full_type_name: *mut *const oratext,
                                  full_type_name_length: *mut ub4,
                                  version_name: *mut *const oratext,
                                  version_name_length: *mut ub4,
                                  pin_duration: OCIDuration,
                                  get_option: OCITypeGetOpt,
                                  tdo: *mut *mut OCIType)
                                  -> sword;
}
extern "C" {
    pub fn OCITypeByRef(env: *mut OCIEnv,
                        err: *mut OCIError,
                        type_ref: *const OCIRef,
                        pin_duration: OCIDuration,
                        get_option: OCITypeGetOpt,
                        tdo: *mut *mut OCIType)
                        -> sword;
}
extern "C" {
    pub fn OCITypeArrayByRef(env: *mut OCIEnv,
                             err: *mut OCIError,
                             array_len: ub4,
                             type_ref: *mut *const OCIRef,
                             pin_duration: OCIDuration,
                             get_option: OCITypeGetOpt,
                             tdo: *mut *mut OCIType)
                             -> sword;
}
extern "C" {
    pub fn OCITypeName(env: *mut OCIEnv,
                       err: *mut OCIError,
                       tdo: *const OCIType,
                       n_length: *mut ub4)
                       -> *mut oratext;
}
extern "C" {
    pub fn OCITypeSchema(env: *mut OCIEnv,
                         err: *mut OCIError,
                         tdo: *const OCIType,
                         n_length: *mut ub4)
                         -> *mut oratext;
}
extern "C" {
    pub fn OCITypePackage(env: *mut OCIEnv,
                          err: *mut OCIError,
                          tdo: *const OCIType,
                          n_length: *mut ub4)
                          -> *mut oratext;
}
extern "C" {
    pub fn OCITypeTypeCode(env: *mut OCIEnv,
                           err: *mut OCIError,
                           tdo: *const OCIType)
                           -> OCITypeCode;
}
extern "C" {
    pub fn OCITypeCollTypeCode(env: *mut OCIEnv,
                               err: *mut OCIError,
                               tdo: *const OCIType)
                               -> OCITypeCode;
}
extern "C" {
    pub fn OCITypeVersion(env: *mut OCIEnv,
                          err: *mut OCIError,
                          tdo: *const OCIType,
                          v_length: *mut ub4)
                          -> *mut oratext;
}
extern "C" {
    pub fn OCITypeAttrs(env: *mut OCIEnv, err: *mut OCIError, tdo: *const OCIType) -> ub4;
}
extern "C" {
    pub fn OCITypeMethods(env: *mut OCIEnv, err: *mut OCIError, tdo: *const OCIType) -> ub4;
}
extern "C" {
    pub fn OCITypeElemName(env: *mut OCIEnv,
                           err: *mut OCIError,
                           elem: *const OCITypeElem,
                           n_length: *mut ub4)
                           -> *mut oratext;
}
extern "C" {
    pub fn OCITypeElemTypeCode(env: *mut OCIEnv,
                               err: *mut OCIError,
                               elem: *const OCITypeElem)
                               -> OCITypeCode;
}
extern "C" {
    pub fn OCITypeElemType(env: *mut OCIEnv,
                           err: *mut OCIError,
                           elem: *const OCITypeElem,
                           elem_tdo: *mut *mut OCIType)
                           -> sword;
}
extern "C" {
    pub fn OCITypeElemFlags(env: *mut OCIEnv, err: *mut OCIError, elem: *const OCITypeElem) -> ub4;
}
extern "C" {
    pub fn OCITypeElemNumPrec(env: *mut OCIEnv,
                              err: *mut OCIError,
                              elem: *const OCITypeElem)
                              -> ub1;
}
extern "C" {
    pub fn OCITypeElemNumScale(env: *mut OCIEnv,
                               err: *mut OCIError,
                               elem: *const OCITypeElem)
                               -> sb1;
}
extern "C" {
    pub fn OCITypeElemLength(env: *mut OCIEnv,
                             err: *mut OCIError,
                             elem: *const OCITypeElem)
                             -> ub4;
}
extern "C" {
    pub fn OCITypeElemCharSetID(env: *mut OCIEnv,
                                err: *mut OCIError,
                                elem: *const OCITypeElem)
                                -> ub2;
}
extern "C" {
    pub fn OCITypeElemCharSetForm(env: *mut OCIEnv,
                                  err: *mut OCIError,
                                  elem: *const OCITypeElem)
                                  -> ub2;
}
extern "C" {
    pub fn OCITypeElemParameterizedType(env: *mut OCIEnv,
                                        err: *mut OCIError,
                                        elem: *const OCITypeElem,
                                        type_stored: *mut *mut OCIType)
                                        -> sword;
}
extern "C" {
    pub fn OCITypeElemExtTypeCode(env: *mut OCIEnv,
                                  err: *mut OCIError,
                                  elem: *const OCITypeElem)
                                  -> OCITypeCode;
}
extern "C" {
    pub fn OCITypeAttrByName(env: *mut OCIEnv,
                             err: *mut OCIError,
                             tdo: *const OCIType,
                             name: *const oratext,
                             n_length: ub4,
                             elem: *mut *mut OCITypeElem)
                             -> sword;
}
extern "C" {
    pub fn OCITypeAttrNext(env: *mut OCIEnv,
                           err: *mut OCIError,
                           iterator_ort: *mut OCITypeIter,
                           elem: *mut *mut OCITypeElem)
                           -> sword;
}
extern "C" {
    pub fn OCITypeCollElem(env: *mut OCIEnv,
                           err: *mut OCIError,
                           tdo: *const OCIType,
                           element: *mut *mut OCITypeElem)
                           -> sword;
}
extern "C" {
    pub fn OCITypeCollSize(env: *mut OCIEnv,
                           err: *mut OCIError,
                           tdo: *const OCIType,
                           num_elems: *mut ub4)
                           -> sword;
}
extern "C" {
    pub fn OCITypeCollExtTypeCode(env: *mut OCIEnv,
                                  err: *mut OCIError,
                                  tdo: *const OCIType,
                                  sqt_code: *mut OCITypeCode)
                                  -> sword;
}
extern "C" {
    pub fn OCITypeMethodOverload(env: *mut OCIEnv,
                                 err: *mut OCIError,
                                 tdo: *const OCIType,
                                 method_name: *const oratext,
                                 m_length: ub4)
                                 -> ub4;
}
extern "C" {
    pub fn OCITypeMethodByName(env: *mut OCIEnv,
                               err: *mut OCIError,
                               tdo: *const OCIType,
                               method_name: *const oratext,
                               m_length: ub4,
                               mdos: *mut *mut OCITypeMethod)
                               -> sword;
}
extern "C" {
    pub fn OCITypeMethodNext(env: *mut OCIEnv,
                             err: *mut OCIError,
                             iterator_ort: *mut OCITypeIter,
                             mdo: *mut *mut OCITypeMethod)
                             -> sword;
}
extern "C" {
    pub fn OCITypeMethodName(env: *mut OCIEnv,
                             err: *mut OCIError,
                             mdo: *const OCITypeMethod,
                             n_length: *mut ub4)
                             -> *mut oratext;
}
extern "C" {
    pub fn OCITypeMethodEncap(env: *mut OCIEnv,
                              err: *mut OCIError,
                              mdo: *const OCITypeMethod)
                              -> OCITypeEncap;
}
extern "C" {
    pub fn OCITypeMethodFlags(env: *mut OCIEnv,
                              err: *mut OCIError,
                              mdo: *const OCITypeMethod)
                              -> OCITypeMethodFlag;
}
extern "C" {
    pub fn OCITypeMethodMap(env: *mut OCIEnv,
                            err: *mut OCIError,
                            tdo: *const OCIType,
                            mdo: *mut *mut OCITypeMethod)
                            -> sword;
}
extern "C" {
    pub fn OCITypeMethodOrder(env: *mut OCIEnv,
                              err: *mut OCIError,
                              tdo: *const OCIType,
                              mdo: *mut *mut OCITypeMethod)
                              -> sword;
}
extern "C" {
    pub fn OCITypeMethodParams(env: *mut OCIEnv,
                               err: *mut OCIError,
                               mdo: *const OCITypeMethod)
                               -> ub4;
}
extern "C" {
    pub fn OCITypeResult(env: *mut OCIEnv,
                         err: *mut OCIError,
                         mdo: *const OCITypeMethod,
                         elem: *mut *mut OCITypeElem)
                         -> sword;
}
extern "C" {
    pub fn OCITypeParamByPos(env: *mut OCIEnv,
                             err: *mut OCIError,
                             mdo: *const OCITypeMethod,
                             position: ub4,
                             elem: *mut *mut OCITypeElem)
                             -> sword;
}
extern "C" {
    pub fn OCITypeParamByName(env: *mut OCIEnv,
                              err: *mut OCIError,
                              mdo: *const OCITypeMethod,
                              name: *const oratext,
                              n_length: ub4,
                              elem: *mut *mut OCITypeElem)
                              -> sword;
}
extern "C" {
    pub fn OCITypeParamPos(env: *mut OCIEnv,
                           err: *mut OCIError,
                           mdo: *const OCITypeMethod,
                           name: *const oratext,
                           n_length: ub4,
                           position: *mut ub4,
                           elem: *mut *mut OCITypeElem)
                           -> sword;
}
extern "C" {
    pub fn OCITypeElemParamMode(env: *mut OCIEnv,
                                err: *mut OCIError,
                                elem: *const OCITypeElem)
                                -> OCITypeParamMode;
}
extern "C" {
    pub fn OCITypeElemDefaultValue(env: *mut OCIEnv,
                                   err: *mut OCIError,
                                   elem: *const OCITypeElem,
                                   d_v_length: *mut ub4)
                                   -> *mut oratext;
}
extern "C" {
    pub fn OCITypeVTInit(env: *mut OCIEnv, err: *mut OCIError) -> sword;
}
extern "C" {
    pub fn OCITypeVTInsert(env: *mut OCIEnv,
                           err: *mut OCIError,
                           schema_name: *const oratext,
                           s_n_length: ub4,
                           type_name: *const oratext,
                           t_n_length: ub4,
                           user_version: *const oratext,
                           u_v_length: ub4)
                           -> sword;
}
extern "C" {
    pub fn OCITypeVTSelect(env: *mut OCIEnv,
                           err: *mut OCIError,
                           schema_name: *const oratext,
                           s_n_length: ub4,
                           type_name: *const oratext,
                           t_n_length: ub4,
                           user_version: *mut *mut oratext,
                           u_v_length: *mut ub4,
                           version: *mut ub2)
                           -> sword;
}
extern "C" {
    pub fn ortgcty(env: *mut OCIEnv,
                   err: *mut OCIError,
                   coll_tdo: *mut OCIType,
                   collelem_tdo: *mut *mut OCIType)
                   -> sword;
}
extern "C" {
    pub fn OCITypeBeginCreate(svchp: *mut OCISvcCtx,
                              errhp: *mut OCIError,
                              tc: OCITypeCode,
                              dur: OCIDuration,
                              type_: *mut *mut OCIType)
                              -> sword;
}
extern "C" {
    pub fn OCITypeSetCollection(svchp: *mut OCISvcCtx,
                                errhp: *mut OCIError,
                                type_: *mut OCIType,
                                collelem_info: *mut OCIParam,
                                coll_count: ub4)
                                -> sword;
}
extern "C" {
    pub fn OCITypeSetBuiltin(svchp: *mut OCISvcCtx,
                             errhp: *mut OCIError,
                             type_: *mut OCIType,
                             builtin_info: *mut OCIParam)
                             -> sword;
}
extern "C" {
    pub fn OCITypeAddAttr(svchp: *mut OCISvcCtx,
                          errhp: *mut OCIError,
                          type_: *mut OCIType,
                          a_name: *const oratext,
                          a_length: ub4,
                          attr_info: *mut OCIParam)
                          -> sword;
}
extern "C" {
    pub fn OCITypeEndCreate(svchp: *mut OCISvcCtx,
                            errhp: *mut OCIError,
                            type_: *mut OCIType)
                            -> sword;
}
extern "C" {
    pub fn OCIObjectNew(env: *mut OCIEnv,
                        err: *mut OCIError,
                        svc: *const OCISvcCtx,
                        typecode: OCITypeCode,
                        tdo: *mut OCIType,
                        table: *mut ::std::os::raw::c_void,
                        duration: OCIDuration,
                        value: boolean,
                        instance: *mut *mut ::std::os::raw::c_void)
                        -> sword;
}
extern "C" {
    pub fn OCIObjectPin(env: *mut OCIEnv,
                        err: *mut OCIError,
                        object_ref: *mut OCIRef,
                        corhdl: *mut OCIComplexObject,
                        pin_option: OCIPinOpt,
                        pin_duration: OCIDuration,
                        lock_option: OCILockOpt,
                        object: *mut *mut ::std::os::raw::c_void)
                        -> sword;
}
extern "C" {
    pub fn OCIObjectUnpin(env: *mut OCIEnv,
                          err: *mut OCIError,
                          object: *mut ::std::os::raw::c_void)
                          -> sword;
}
extern "C" {
    pub fn OCIObjectPinCountReset(env: *mut OCIEnv,
                                  err: *mut OCIError,
                                  object: *mut ::std::os::raw::c_void)
                                  -> sword;
}
extern "C" {
    pub fn OCIObjectLock(env: *mut OCIEnv,
                         err: *mut OCIError,
                         object: *mut ::std::os::raw::c_void)
                         -> sword;
}
extern "C" {
    pub fn OCIObjectLockNoWait(env: *mut OCIEnv,
                               err: *mut OCIError,
                               object: *mut ::std::os::raw::c_void)
                               -> sword;
}
extern "C" {
    pub fn OCIObjectMarkUpdate(env: *mut OCIEnv,
                               err: *mut OCIError,
                               object: *mut ::std::os::raw::c_void)
                               -> sword;
}
extern "C" {
    pub fn OCIObjectUnmark(env: *mut OCIEnv,
                           err: *mut OCIError,
                           object: *mut ::std::os::raw::c_void)
                           -> sword;
}
extern "C" {
    pub fn OCIObjectUnmarkByRef(env: *mut OCIEnv, err: *mut OCIError, ref_: *mut OCIRef) -> sword;
}
extern "C" {
    pub fn OCIObjectFree(env: *mut OCIEnv,
                         err: *mut OCIError,
                         instance: *mut ::std::os::raw::c_void,
                         flags: ub2)
                         -> sword;
}
extern "C" {
    pub fn OCIObjectMarkDeleteByRef(env: *mut OCIEnv,
                                    err: *mut OCIError,
                                    object_ref: *mut OCIRef)
                                    -> sword;
}
extern "C" {
    pub fn OCIObjectMarkDelete(env: *mut OCIEnv,
                               err: *mut OCIError,
                               instance: *mut ::std::os::raw::c_void)
                               -> sword;
}
extern "C" {
    pub fn OCIObjectFlush(env: *mut OCIEnv,
                          err: *mut OCIError,
                          object: *mut ::std::os::raw::c_void)
                          -> sword;
}
extern "C" {
    pub fn OCIObjectRefresh(env: *mut OCIEnv,
                            err: *mut OCIError,
                            object: *mut ::std::os::raw::c_void)
                            -> sword;
}
extern "C" {
    pub fn OCIObjectCopy(env: *mut OCIEnv,
                         err: *mut OCIError,
                         svc: *const OCISvcCtx,
                         source: *mut ::std::os::raw::c_void,
                         null_source: *mut ::std::os::raw::c_void,
                         target: *mut ::std::os::raw::c_void,
                         null_target: *mut ::std::os::raw::c_void,
                         tdo: *mut OCIType,
                         duration: OCIDuration,
                         option: ub1)
                         -> sword;
}
extern "C" {
    pub fn OCIObjectGetTypeRef(env: *mut OCIEnv,
                               err: *mut OCIError,
                               instance: *mut ::std::os::raw::c_void,
                               type_ref: *mut OCIRef)
                               -> sword;
}
extern "C" {
    pub fn OCIObjectGetObjectRef(env: *mut OCIEnv,
                                 err: *mut OCIError,
                                 object: *mut ::std::os::raw::c_void,
                                 object_ref: *mut OCIRef)
                                 -> sword;
}
extern "C" {
    pub fn OCIObjectMakeObjectRef(env: *mut OCIEnv,
                                  err: *mut OCIError,
                                  svc: *const OCISvcCtx,
                                  table: *mut ::std::os::raw::c_void,
                                  values: *mut *mut ::std::os::raw::c_void,
                                  array_len: ub4,
                                  object_ref: *mut OCIRef)
                                  -> sword;
}
extern "C" {
    pub fn OCIObjectGetPrimaryKeyTypeRef(env: *mut OCIEnv,
                                         err: *mut OCIError,
                                         svc: *const OCISvcCtx,
                                         table: *mut ::std::os::raw::c_void,
                                         type_ref: *mut OCIRef)
                                         -> sword;
}
extern "C" {
    pub fn OCIObjectGetInd(env: *mut OCIEnv,
                           err: *mut OCIError,
                           instance: *mut ::std::os::raw::c_void,
                           null_struct: *mut *mut ::std::os::raw::c_void)
                           -> sword;
}
extern "C" {
    pub fn OCIObjectExists(env: *mut OCIEnv,
                           err: *mut OCIError,
                           ins: *mut ::std::os::raw::c_void,
                           exist: *mut boolean)
                           -> sword;
}
extern "C" {
    pub fn OCIObjectGetProperty(envh: *mut OCIEnv,
                                errh: *mut OCIError,
                                obj: *const ::std::os::raw::c_void,
                                propertyId: OCIObjectPropId,
                                property: *mut ::std::os::raw::c_void,
                                size: *mut ub4)
                                -> sword;
}
extern "C" {
    pub fn OCIObjectIsLocked(env: *mut OCIEnv,
                             err: *mut OCIError,
                             ins: *mut ::std::os::raw::c_void,
                             lock: *mut boolean)
                             -> sword;
}
extern "C" {
    pub fn OCIObjectIsDirty(env: *mut OCIEnv,
                            err: *mut OCIError,
                            ins: *mut ::std::os::raw::c_void,
                            dirty: *mut boolean)
                            -> sword;
}
extern "C" {
    pub fn OCIObjectPinTable(env: *mut OCIEnv,
                             err: *mut OCIError,
                             svc: *const OCISvcCtx,
                             schema_name: *const oratext,
                             s_n_length: ub4,
                             object_name: *const oratext,
                             o_n_length: ub4,
                             scope_obj_ref: *const OCIRef,
                             pin_duration: OCIDuration,
                             object: *mut *mut ::std::os::raw::c_void)
                             -> sword;
}
extern "C" {
    pub fn OCIObjectArrayPin(env: *mut OCIEnv,
                             err: *mut OCIError,
                             ref_array: *mut *mut OCIRef,
                             array_size: ub4,
                             cor_array: *mut *mut OCIComplexObject,
                             cor_array_size: ub4,
                             pin_option: OCIPinOpt,
                             pin_duration: OCIDuration,
                             lock: OCILockOpt,
                             obj_array: *mut *mut ::std::os::raw::c_void,
                             pos: *mut ub4)
                             -> sword;
}
extern "C" {
    pub fn OCICacheFlush(env: *mut OCIEnv, err: *mut OCIError,
                         svc: *const OCISvcCtx,
                         context: *mut ::std::os::raw::c_void,
                         get:
                             ::std::option::Option<unsafe extern "C" fn(context:
                                                                            *mut ::std::os::raw::c_void,
                                                                        last:
                                                                            *mut ub1)
                                                       -> *mut OCIRef>,
ref_: *mut *mut OCIRef) -> sword;
}
extern "C" {
    pub fn OCICacheRefresh(env: *mut OCIEnv, err: *mut OCIError,
                           svc: *const OCISvcCtx, option: OCIRefreshOpt,
                           context: *mut ::std::os::raw::c_void,
                           get:
                               ::std::option::Option<unsafe extern "C" fn(context:
                                                                              *mut ::std::os::raw::c_void)
                                                         -> *mut OCIRef>,
ref_: *mut *mut OCIRef) -> sword;
}
extern "C" {
    pub fn OCICacheUnpin(env: *mut OCIEnv, err: *mut OCIError, svc: *const OCISvcCtx) -> sword;
}
extern "C" {
    pub fn OCICacheFree(env: *mut OCIEnv, err: *mut OCIError, svc: *const OCISvcCtx) -> sword;
}
extern "C" {
    pub fn OCICacheUnmark(env: *mut OCIEnv, err: *mut OCIError, svc: *const OCISvcCtx) -> sword;
}
extern "C" {
    pub fn OCIDurationBegin(env: *mut OCIEnv,
                            err: *mut OCIError,
                            svc: *const OCISvcCtx,
                            parent: OCIDuration,
                            dur: *mut OCIDuration)
                            -> sword;
}
extern "C" {
    pub fn OCIDurationEnd(env: *mut OCIEnv,
                          err: *mut OCIError,
                          svc: *const OCISvcCtx,
                          duration: OCIDuration)
                          -> sword;
}
extern "C" {
    /// DO  NOT  USE  THE  FUNCTIONS  BELOW!                             **
    /// UNSUPPORTED INTERFACE                                            **
    /// WILL BE REMOVED/CHANGED IN A FUTURE RELEASE                      **
    pub fn OCIDurationGetParent(env: *mut OCIEnv,
                                err: *mut OCIError,
                                duration: OCIDuration,
                                parent: *mut OCIDuration)
                                -> sword;
}
extern "C" {
    pub fn OCIObjectAlwaysLatest(env: *mut OCIEnv,
                                 err: *mut OCIError,
                                 object: *mut ::std::os::raw::c_void)
                                 -> sword;
}
extern "C" {
    pub fn OCIObjectNotAlwaysLatest(env: *mut OCIEnv,
                                    err: *mut OCIError,
                                    object: *mut ::std::os::raw::c_void)
                                    -> sword;
}
extern "C" {
    pub fn OCIObjectFlushRefresh(env: *mut OCIEnv,
                                 err: *mut OCIError,
                                 object: *mut ::std::os::raw::c_void)
                                 -> sword;
}
extern "C" {
    pub fn OCIObjectIsLoaded(env: *mut OCIEnv,
                             err: *mut OCIError,
                             ins: *mut ::std::os::raw::c_void,
                             load: *mut boolean)
                             -> sword;
}
extern "C" {
    pub fn OCIObjectIsDirtied(env: *mut OCIEnv,
                              err: *mut OCIError,
                              ins: *mut ::std::os::raw::c_void,
                              dirty: *mut boolean)
                              -> sword;
}
extern "C" {
    pub fn OCICacheGetObjects(env: *mut OCIEnv, err: *mut OCIError,
                              svc: *const OCISvcCtx,
                              property: OCIObjectProperty,
                              client_context: *mut ::std::os::raw::c_void,
                              client_callback:
                                  ::std::option::Option<unsafe extern "C" fn(client_context:
                                                                                 *mut ::std::os::raw::c_void,
                                                                             object:
                                                                                 *mut ::std::os::raw::c_void)>)
-> sword;
}
extern "C" {
    pub fn OCICacheRegister(env: *mut OCIEnv, err: *mut OCIError,
                            event: OCIObjectEvent,
                            client_context: *mut ::std::os::raw::c_void,
                            client_callback:
                                ::std::option::Option<unsafe extern "C" fn(client_context:
                                                                               *mut ::std::os::raw::c_void,
                                                                           event:
                                                                               OCIObjectEvent,
                                                                           object:
                                                                               *mut ::std::os::raw::c_void)>)
-> sword;
}
extern "C" {
    pub fn OCICacheFlushRefresh(env: *mut OCIEnv, err: *mut OCIError,
                                svc: *const OCISvcCtx,
                                context: *mut ::std::os::raw::c_void,
                                get:
                                    ::std::option::Option<unsafe extern "C" fn(context:
                                                                                   *mut ::std::os::raw::c_void,
                                                                               last:
                                                                                   *mut ub1)
                                                              -> *mut OCIRef>,
ref_: *mut *mut OCIRef) -> sword;
}
extern "C" {
    pub fn OCIObjectSetData(env: *mut OCIEnv,
                            err: *mut OCIError,
                            obj_hdr: *mut ::std::os::raw::c_void,
                            data: *mut ::std::os::raw::c_void)
                            -> sword;
}
extern "C" {
    pub fn OCIObjectGetNewOID(env: *mut OCIEnv,
                              err: *mut OCIError,
                              svc: *mut OCISvcCtx,
                              oid: *mut ub1)
                              -> sword;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct OCINumber {
    pub OCINumberPart: [ub1; 22usize],
}
#[test]
fn bindgen_test_layout_OCINumber() {
    assert_eq!(::std::mem::size_of::<OCINumber>(),
               22usize,
               concat!("Size of: ", stringify!(OCINumber)));
    assert_eq!(::std::mem::align_of::<OCINumber>(),
               1usize,
               concat!("Alignment of ", stringify!(OCINumber)));
    assert_eq!(unsafe { &(*(0 as *const OCINumber)).OCINumberPart as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(OCINumber),
                       "::",
                       stringify!(OCINumberPart)));
}
impl Clone for OCINumber {
    fn clone(&self) -> Self {
        *self
    }
}
extern "C" {
    pub fn OCINumberInc(err: *mut OCIError, number: *mut OCINumber) -> sword;
}
extern "C" {
    pub fn OCINumberDec(err: *mut OCIError, number: *mut OCINumber) -> sword;
}
extern "C" {
    pub fn OCINumberSetZero(err: *mut OCIError, num: *mut OCINumber);
}
extern "C" {
    pub fn OCINumberSetPi(err: *mut OCIError, num: *mut OCINumber);
}
extern "C" {
    pub fn OCINumberAdd(err: *mut OCIError,
                        number1: *const OCINumber,
                        number2: *const OCINumber,
                        result: *mut OCINumber)
                        -> sword;
}
extern "C" {
    pub fn OCINumberSub(err: *mut OCIError,
                        number1: *const OCINumber,
                        number2: *const OCINumber,
                        result: *mut OCINumber)
                        -> sword;
}
extern "C" {
    pub fn OCINumberMul(err: *mut OCIError,
                        number1: *const OCINumber,
                        number2: *const OCINumber,
                        result: *mut OCINumber)
                        -> sword;
}
extern "C" {
    pub fn OCINumberDiv(err: *mut OCIError,
                        number1: *const OCINumber,
                        number2: *const OCINumber,
                        result: *mut OCINumber)
                        -> sword;
}
extern "C" {
    pub fn OCINumberMod(err: *mut OCIError,
                        number1: *const OCINumber,
                        number2: *const OCINumber,
                        result: *mut OCINumber)
                        -> sword;
}
extern "C" {
    pub fn OCINumberIntPower(err: *mut OCIError,
                             base: *const OCINumber,
                             exp: sword,
                             result: *mut OCINumber)
                             -> sword;
}
extern "C" {
    pub fn OCINumberShift(err: *mut OCIError,
                          number: *const OCINumber,
                          nDig: sword,
                          result: *mut OCINumber)
                          -> sword;
}
extern "C" {
    pub fn OCINumberNeg(err: *mut OCIError,
                        number: *const OCINumber,
                        result: *mut OCINumber)
                        -> sword;
}
extern "C" {
    pub fn OCINumberToText(err: *mut OCIError,
                           number: *const OCINumber,
                           fmt: *const oratext,
                           fmt_length: ub4,
                           nls_params: *const oratext,
                           nls_p_length: ub4,
                           buf_size: *mut ub4,
                           buf: *mut oratext)
                           -> sword;
}
extern "C" {
    pub fn OCINumberFromText(err: *mut OCIError,
                             str: *const oratext,
                             str_length: ub4,
                             fmt: *const oratext,
                             fmt_length: ub4,
                             nls_params: *const oratext,
                             nls_p_length: ub4,
                             number: *mut OCINumber)
                             -> sword;
}
extern "C" {
    pub fn OCINumberToInt(err: *mut OCIError,
                          number: *const OCINumber,
                          rsl_length: uword,
                          rsl_flag: uword,
                          rsl: *mut ::std::os::raw::c_void)
                          -> sword;
}
extern "C" {
    pub fn OCINumberFromInt(err: *mut OCIError,
                            inum: *const ::std::os::raw::c_void,
                            inum_length: uword,
                            inum_s_flag: uword,
                            number: *mut OCINumber)
                            -> sword;
}
extern "C" {
    pub fn OCINumberToReal(err: *mut OCIError,
                           number: *const OCINumber,
                           rsl_length: uword,
                           rsl: *mut ::std::os::raw::c_void)
                           -> sword;
}
extern "C" {
    pub fn OCINumberToRealArray(err: *mut OCIError,
                                number: *mut *const OCINumber,
                                elems: uword,
                                rsl_length: uword,
                                rsl: *mut ::std::os::raw::c_void)
                                -> sword;
}
extern "C" {
    pub fn OCINumberFromReal(err: *mut OCIError,
                             rnum: *const ::std::os::raw::c_void,
                             rnum_length: uword,
                             number: *mut OCINumber)
                             -> sword;
}
extern "C" {
    pub fn OCINumberCmp(err: *mut OCIError,
                        number1: *const OCINumber,
                        number2: *const OCINumber,
                        result: *mut sword)
                        -> sword;
}
extern "C" {
    pub fn OCINumberSign(err: *mut OCIError,
                         number: *const OCINumber,
                         result: *mut sword)
                         -> sword;
}
extern "C" {
    pub fn OCINumberIsZero(err: *mut OCIError,
                           number: *const OCINumber,
                           result: *mut boolean)
                           -> sword;
}
extern "C" {
    pub fn OCINumberIsInt(err: *mut OCIError,
                          number: *const OCINumber,
                          result: *mut boolean)
                          -> sword;
}
extern "C" {
    pub fn OCINumberAssign(err: *mut OCIError,
                           from: *const OCINumber,
                           to: *mut OCINumber)
                           -> sword;
}
extern "C" {
    pub fn OCINumberAbs(err: *mut OCIError,
                        number: *const OCINumber,
                        result: *mut OCINumber)
                        -> sword;
}
extern "C" {
    pub fn OCINumberCeil(err: *mut OCIError,
                         number: *const OCINumber,
                         result: *mut OCINumber)
                         -> sword;
}
extern "C" {
    pub fn OCINumberFloor(err: *mut OCIError,
                          number: *const OCINumber,
                          result: *mut OCINumber)
                          -> sword;
}
extern "C" {
    pub fn OCINumberSqrt(err: *mut OCIError,
                         number: *const OCINumber,
                         result: *mut OCINumber)
                         -> sword;
}
extern "C" {
    pub fn OCINumberTrunc(err: *mut OCIError,
                          number: *const OCINumber,
                          decplace: sword,
                          result: *mut OCINumber)
                          -> sword;
}
extern "C" {
    pub fn OCINumberPower(err: *mut OCIError,
                          base: *const OCINumber,
                          number: *const OCINumber,
                          result: *mut OCINumber)
                          -> sword;
}
extern "C" {
    pub fn OCINumberRound(err: *mut OCIError,
                          number: *const OCINumber,
                          decplace: sword,
                          result: *mut OCINumber)
                          -> sword;
}
extern "C" {
    pub fn OCINumberPrec(err: *mut OCIError,
                         number: *const OCINumber,
                         nDigs: sword,
                         result: *mut OCINumber)
                         -> sword;
}
extern "C" {
    pub fn OCINumberSin(err: *mut OCIError,
                        number: *const OCINumber,
                        result: *mut OCINumber)
                        -> sword;
}
extern "C" {
    pub fn OCINumberArcSin(err: *mut OCIError,
                           number: *const OCINumber,
                           result: *mut OCINumber)
                           -> sword;
}
extern "C" {
    pub fn OCINumberHypSin(err: *mut OCIError,
                           number: *const OCINumber,
                           result: *mut OCINumber)
                           -> sword;
}
extern "C" {
    pub fn OCINumberCos(err: *mut OCIError,
                        number: *const OCINumber,
                        result: *mut OCINumber)
                        -> sword;
}
extern "C" {
    pub fn OCINumberArcCos(err: *mut OCIError,
                           number: *const OCINumber,
                           result: *mut OCINumber)
                           -> sword;
}
extern "C" {
    pub fn OCINumberHypCos(err: *mut OCIError,
                           number: *const OCINumber,
                           result: *mut OCINumber)
                           -> sword;
}
extern "C" {
    pub fn OCINumberTan(err: *mut OCIError,
                        number: *const OCINumber,
                        result: *mut OCINumber)
                        -> sword;
}
extern "C" {
    pub fn OCINumberArcTan(err: *mut OCIError,
                           number: *const OCINumber,
                           result: *mut OCINumber)
                           -> sword;
}
extern "C" {
    pub fn OCINumberArcTan2(err: *mut OCIError,
                            number1: *const OCINumber,
                            number2: *const OCINumber,
                            result: *mut OCINumber)
                            -> sword;
}
extern "C" {
    pub fn OCINumberHypTan(err: *mut OCIError,
                           number: *const OCINumber,
                           result: *mut OCINumber)
                           -> sword;
}
extern "C" {
    pub fn OCINumberExp(err: *mut OCIError,
                        number: *const OCINumber,
                        result: *mut OCINumber)
                        -> sword;
}
extern "C" {
    pub fn OCINumberLn(err: *mut OCIError,
                       number: *const OCINumber,
                       result: *mut OCINumber)
                       -> sword;
}
extern "C" {
    pub fn OCINumberLog(err: *mut OCIError,
                        base: *const OCINumber,
                        number: *const OCINumber,
                        result: *mut OCINumber)
                        -> sword;
}

#[repr(C)]
#[derive(Debug, Copy)]
pub struct OCITime {
    pub OCITimeHH: ub1,
    pub OCITimeMI: ub1,
    pub OCITimeSS: ub1,
}
#[test]
fn bindgen_test_layout_OCITime() {
    assert_eq!(::std::mem::size_of::<OCITime>(),
               3usize,
               concat!("Size of: ", stringify!(OCITime)));
    assert_eq!(::std::mem::align_of::<OCITime>(),
               1usize,
               concat!("Alignment of ", stringify!(OCITime)));
    assert_eq!(unsafe { &(*(0 as *const OCITime)).OCITimeHH as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(OCITime),
                       "::",
                       stringify!(OCITimeHH)));
    assert_eq!(unsafe { &(*(0 as *const OCITime)).OCITimeMI as *const _ as usize },
               1usize,
               concat!("Alignment of field: ",
                       stringify!(OCITime),
                       "::",
                       stringify!(OCITimeMI)));
    assert_eq!(unsafe { &(*(0 as *const OCITime)).OCITimeSS as *const _ as usize },
               2usize,
               concat!("Alignment of field: ",
                       stringify!(OCITime),
                       "::",
                       stringify!(OCITimeSS)));
}
impl Clone for OCITime {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct OCIDate {
    pub OCIDateYYYY: sb2,
    pub OCIDateMM: ub1,
    pub OCIDateDD: ub1,
    pub OCIDateTime: OCITime,
}
#[test]
fn bindgen_test_layout_OCIDate() {
    assert_eq!(::std::mem::size_of::<OCIDate>(),
               8usize,
               concat!("Size of: ", stringify!(OCIDate)));
    assert_eq!(::std::mem::align_of::<OCIDate>(),
               2usize,
               concat!("Alignment of ", stringify!(OCIDate)));
    assert_eq!(unsafe { &(*(0 as *const OCIDate)).OCIDateYYYY as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(OCIDate),
                       "::",
                       stringify!(OCIDateYYYY)));
    assert_eq!(unsafe { &(*(0 as *const OCIDate)).OCIDateMM as *const _ as usize },
               2usize,
               concat!("Alignment of field: ",
                       stringify!(OCIDate),
                       "::",
                       stringify!(OCIDateMM)));
    assert_eq!(unsafe { &(*(0 as *const OCIDate)).OCIDateDD as *const _ as usize },
               3usize,
               concat!("Alignment of field: ",
                       stringify!(OCIDate),
                       "::",
                       stringify!(OCIDateDD)));
    assert_eq!(unsafe { &(*(0 as *const OCIDate)).OCIDateTime as *const _ as usize },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(OCIDate),
                       "::",
                       stringify!(OCIDateTime)));
}
impl Clone for OCIDate {
    fn clone(&self) -> Self {
        *self
    }
}
extern "C" {
    pub fn OCIDateAssign(err: *mut OCIError, from: *const OCIDate, to: *mut OCIDate) -> sword;
}
extern "C" {
    pub fn OCIDateToText(err: *mut OCIError,
                         date: *const OCIDate,
                         fmt: *const oratext,
                         fmt_length: ub1,
                         lang_name: *const oratext,
                         lang_length: ub4,
                         buf_size: *mut ub4,
                         buf: *mut oratext)
                         -> sword;
}
extern "C" {
    pub fn OCIDateFromText(err: *mut OCIError,
                           date_str: *const oratext,
                           d_str_length: ub4,
                           fmt: *const oratext,
                           fmt_length: ub1,
                           lang_name: *const oratext,
                           lang_length: ub4,
                           date: *mut OCIDate)
                           -> sword;
}
extern "C" {
    pub fn OCIDateCompare(err: *mut OCIError,
                          date1: *const OCIDate,
                          date2: *const OCIDate,
                          result: *mut sword)
                          -> sword;
}
extern "C" {
    pub fn OCIDateAddMonths(err: *mut OCIError,
                            date: *const OCIDate,
                            num_months: sb4,
                            result: *mut OCIDate)
                            -> sword;
}
extern "C" {
    pub fn OCIDateAddDays(err: *mut OCIError,
                          date: *const OCIDate,
                          num_days: sb4,
                          result: *mut OCIDate)
                          -> sword;
}
extern "C" {
    pub fn OCIDateLastDay(err: *mut OCIError,
                          date: *const OCIDate,
                          last_day: *mut OCIDate)
                          -> sword;
}
extern "C" {
    pub fn OCIDateDaysBetween(err: *mut OCIError,
                              date1: *const OCIDate,
                              date2: *const OCIDate,
                              num_days: *mut sb4)
                              -> sword;
}
extern "C" {
    pub fn OCIDateZoneToZone(err: *mut OCIError,
                             date1: *const OCIDate,
                             zon1: *const oratext,
                             zon1_length: ub4,
                             zon2: *const oratext,
                             zon2_length: ub4,
                             date2: *mut OCIDate)
                             -> sword;
}
extern "C" {
    pub fn OCIDateNextDay(err: *mut OCIError,
                          date: *const OCIDate,
                          day_p: *const oratext,
                          day_length: ub4,
                          next_day: *mut OCIDate)
                          -> sword;
}
extern "C" {
    pub fn OCIDateCheck(err: *mut OCIError, date: *const OCIDate, valid: *mut uword) -> sword;
}
extern "C" {
    pub fn OCIDateSysDate(err: *mut OCIError, sys_date: *mut OCIDate) -> sword;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIString {
    _unused: [u8; 0],
}
extern "C" {
    pub fn OCIStringAssign(env: *mut OCIEnv,
                           err: *mut OCIError,
                           rhs: *const OCIString,
                           lhs: *mut *mut OCIString)
                           -> sword;
}
extern "C" {
    pub fn OCIStringAssignText(env: *mut OCIEnv,
                               err: *mut OCIError,
                               rhs: *const oratext,
                               rhs_len: ub4,
                               lhs: *mut *mut OCIString)
                               -> sword;
}
extern "C" {
    pub fn OCIStringResize(env: *mut OCIEnv,
                           err: *mut OCIError,
                           new_size: ub4,
                           str: *mut *mut OCIString)
                           -> sword;
}
extern "C" {
    pub fn OCIStringSize(env: *mut OCIEnv, vs: *const OCIString) -> ub4;
}
extern "C" {
    pub fn OCIStringPtr(env: *mut OCIEnv, vs: *const OCIString) -> *mut oratext;
}
extern "C" {
    pub fn OCIStringAllocSize(env: *mut OCIEnv,
                              err: *mut OCIError,
                              vs: *const OCIString,
                              allocsize: *mut ub4)
                              -> sword;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIRaw {
    _unused: [u8; 0],
}
extern "C" {
    pub fn OCIRawAssignRaw(env: *mut OCIEnv,
                           err: *mut OCIError,
                           rhs: *const OCIRaw,
                           lhs: *mut *mut OCIRaw)
                           -> sword;
}
extern "C" {
    pub fn OCIRawAssignBytes(env: *mut OCIEnv,
                             err: *mut OCIError,
                             rhs: *const ub1,
                             rhs_len: ub4,
                             lhs: *mut *mut OCIRaw)
                             -> sword;
}
extern "C" {
    pub fn OCIRawResize(env: *mut OCIEnv,
                        err: *mut OCIError,
                        new_size: ub4,
                        raw: *mut *mut OCIRaw)
                        -> sword;
}
extern "C" {
    pub fn OCIRawSize(env: *mut OCIEnv, raw: *const OCIRaw) -> ub4;
}
extern "C" {
    pub fn OCIRawPtr(env: *mut OCIEnv, raw: *const OCIRaw) -> *mut ub1;
}
extern "C" {
    pub fn OCIRawAllocSize(env: *mut OCIEnv,
                           err: *mut OCIError,
                           raw: *const OCIRaw,
                           allocsize: *mut ub4)
                           -> sword;
}
extern "C" {

    pub fn OCIRefClear(env: *mut OCIEnv, ref_: *mut OCIRef);
}
extern "C" {
    pub fn OCIRefAssign(env: *mut OCIEnv,
                        err: *mut OCIError,
                        source: *const OCIRef,
                        target: *mut *mut OCIRef)
                        -> sword;
}
extern "C" {
    pub fn OCIRefIsEqual(env: *mut OCIEnv, x: *const OCIRef, y: *const OCIRef) -> boolean;
}
extern "C" {
    pub fn OCIRefIsNull(env: *mut OCIEnv, ref_: *const OCIRef) -> boolean;
}
extern "C" {
    pub fn OCIRefHexSize(env: *mut OCIEnv, ref_: *const OCIRef) -> ub4;
}
extern "C" {
    pub fn OCIRefFromHex(env: *mut OCIEnv,
                         err: *mut OCIError,
                         svc: *const OCISvcCtx,
                         hex: *const oratext,
                         length: ub4,
                         ref_: *mut *mut OCIRef)
                         -> sword;
}
extern "C" {
    pub fn OCIRefToHex(env: *mut OCIEnv,
                       err: *mut OCIError,
                       ref_: *const OCIRef,
                       hex: *mut oratext,
                       hex_length: *mut ub4)
                       -> sword;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIColl {
    _unused: [u8; 0],
}
pub type OCIArray = OCIColl;
pub type OCITable = OCIColl;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIIter {
    _unused: [u8; 0],
}
extern "C" {
    pub fn OCICollSize(env: *mut OCIEnv,
                       err: *mut OCIError,
                       coll: *const OCIColl,
                       size: *mut sb4)
                       -> sword;
}
extern "C" {
    pub fn OCICollMax(env: *mut OCIEnv, coll: *const OCIColl) -> sb4;
}
extern "C" {
    pub fn OCICollGetElem(env: *mut OCIEnv,
                          err: *mut OCIError,
                          coll: *const OCIColl,
                          index: sb4,
                          exists: *mut boolean,
                          elem: *mut *mut ::std::os::raw::c_void,
                          elemind: *mut *mut ::std::os::raw::c_void)
                          -> sword;
}
extern "C" {
    pub fn OCICollGetElemArray(env: *mut OCIEnv,
                               err: *mut OCIError,
                               coll: *const OCIColl,
                               index: sb4,
                               exists: *mut boolean,
                               elem: *mut *mut ::std::os::raw::c_void,
                               elemind: *mut *mut ::std::os::raw::c_void,
                               nelems: *mut uword)
                               -> sword;
}
extern "C" {
    pub fn OCICollAssignElem(env: *mut OCIEnv,
                             err: *mut OCIError,
                             index: sb4,
                             elem: *const ::std::os::raw::c_void,
                             elemind: *const ::std::os::raw::c_void,
                             coll: *mut OCIColl)
                             -> sword;
}
extern "C" {
    pub fn OCICollAssign(env: *mut OCIEnv,
                         err: *mut OCIError,
                         rhs: *const OCIColl,
                         lhs: *mut OCIColl)
                         -> sword;
}
extern "C" {
    pub fn OCICollAppend(env: *mut OCIEnv,
                         err: *mut OCIError,
                         elem: *const ::std::os::raw::c_void,
                         elemind: *const ::std::os::raw::c_void,
                         coll: *mut OCIColl)
                         -> sword;
}
extern "C" {
    pub fn OCICollTrim(env: *mut OCIEnv,
                       err: *mut OCIError,
                       trim_num: sb4,
                       coll: *mut OCIColl)
                       -> sword;
}
extern "C" {
    pub fn OCICollIsLocator(env: *mut OCIEnv,
                            err: *mut OCIError,
                            coll: *const OCIColl,
                            result: *mut boolean)
                            -> sword;
}
extern "C" {
    pub fn OCIIterCreate(env: *mut OCIEnv,
                         err: *mut OCIError,
                         coll: *const OCIColl,
                         itr: *mut *mut OCIIter)
                         -> sword;
}
extern "C" {
    pub fn OCIIterDelete(env: *mut OCIEnv, err: *mut OCIError, itr: *mut *mut OCIIter) -> sword;
}
extern "C" {
    pub fn OCIIterInit(env: *mut OCIEnv,
                       err: *mut OCIError,
                       coll: *const OCIColl,
                       itr: *mut OCIIter)
                       -> sword;
}
extern "C" {
    pub fn OCIIterGetCurrent(env: *mut OCIEnv,
                             err: *mut OCIError,
                             itr: *const OCIIter,
                             elem: *mut *mut ::std::os::raw::c_void,
                             elemind: *mut *mut ::std::os::raw::c_void)
                             -> sword;
}
extern "C" {
    pub fn OCIIterNext(env: *mut OCIEnv,
                       err: *mut OCIError,
                       itr: *mut OCIIter,
                       elem: *mut *mut ::std::os::raw::c_void,
                       elemind: *mut *mut ::std::os::raw::c_void,
                       eoc: *mut boolean)
                       -> sword;
}
extern "C" {
    pub fn OCIIterPrev(env: *mut OCIEnv,
                       err: *mut OCIError,
                       itr: *mut OCIIter,
                       elem: *mut *mut ::std::os::raw::c_void,
                       elemind: *mut *mut ::std::os::raw::c_void,
                       boc: *mut boolean)
                       -> sword;
}
extern "C" {

    pub fn OCITableSize(env: *mut OCIEnv,
                        err: *mut OCIError,
                        tbl: *const OCITable,
                        size: *mut sb4)
                        -> sword;
}
extern "C" {
    pub fn OCITableExists(env: *mut OCIEnv,
                          err: *mut OCIError,
                          tbl: *const OCITable,
                          index: sb4,
                          exists: *mut boolean)
                          -> sword;
}
extern "C" {
    pub fn OCITableDelete(env: *mut OCIEnv,
                          err: *mut OCIError,
                          index: sb4,
                          tbl: *mut OCITable)
                          -> sword;
}
extern "C" {
    pub fn OCITableFirst(env: *mut OCIEnv,
                         err: *mut OCIError,
                         tbl: *const OCITable,
                         index: *mut sb4)
                         -> sword;
}
extern "C" {
    pub fn OCITableLast(env: *mut OCIEnv,
                        err: *mut OCIError,
                        tbl: *const OCITable,
                        index: *mut sb4)
                        -> sword;
}
extern "C" {
    pub fn OCITableNext(env: *mut OCIEnv,
                        err: *mut OCIError,
                        index: sb4,
                        tbl: *const OCITable,
                        next_index: *mut sb4,
                        exists: *mut boolean)
                        -> sword;
}
extern "C" {
    pub fn OCITablePrev(env: *mut OCIEnv,
                        err: *mut OCIError,
                        index: sb4,
                        tbl: *const OCITable,
                        prev_index: *mut sb4,
                        exists: *mut boolean)
                        -> sword;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIXMLType {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIDOMDocument {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIBinXmlReposCtx {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIExtProcContext {
    _unused: [u8; 0],
}
extern "C" {
    pub fn ociepacm(with_context: *mut OCIExtProcContext,
                    amount: usize)
                    -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ocieperr(with_context: *mut OCIExtProcContext,
                    error_number: ::std::os::raw::c_int)
                    -> usize;
}
extern "C" {
    pub fn ociepmsg(with_context: *mut OCIExtProcContext,
                    error_number: ::std::os::raw::c_int,
                    error_message: *mut oratext,
                    len: usize)
                    -> usize;
}
extern "C" {
    pub fn ociepgoe(with_context: *mut OCIExtProcContext,
                    envh: *mut *mut OCIEnv,
                    svch: *mut *mut OCISvcCtx,
                    errh: *mut *mut OCIError)
                    -> sword;
}
extern "C" {
    pub fn obindps(cursor: *mut cda_def,
                   opcode: ub1,
                   sqlvar: *mut OraText,
                   sqlvl: sb4,
                   pvctx: *mut ub1,
                   progvl: sb4,
                   ftype: sword,
                   scale: sword,
                   indp: *mut sb2,
                   alen: *mut ub2,
                   arcode: *mut ub2,
                   pv_skip: sb4,
                   ind_skip: sb4,
                   alen_skip: sb4,
                   rc_skip: sb4,
                   maxsiz: ub4,
                   cursiz: *mut ub4,
                   fmt: *mut OraText,
                   fmtl: sb4,
                   fmtt: sword)
                   -> sword;
}
extern "C" {
    pub fn obreak(lda: *mut cda_def) -> sword;
}
extern "C" {
    pub fn ocan(cursor: *mut cda_def) -> sword;
}
extern "C" {
    pub fn oclose(cursor: *mut cda_def) -> sword;
}
extern "C" {
    pub fn ocof(lda: *mut cda_def) -> sword;
}
extern "C" {
    pub fn ocom(lda: *mut cda_def) -> sword;
}
extern "C" {
    pub fn ocon(lda: *mut cda_def) -> sword;
}
extern "C" {
    pub fn odefinps(cursor: *mut cda_def,
                    opcode: ub1,
                    pos: sword,
                    bufctx: *mut ub1,
                    bufl: sb4,
                    ftype: sword,
                    scale: sword,
                    indp: *mut sb2,
                    fmt: *mut OraText,
                    fmtl: sb4,
                    fmtt: sword,
                    rlen: *mut ub2,
                    rcode: *mut ub2,
                    pv_skip: sb4,
                    ind_skip: sb4,
                    alen_skip: sb4,
                    rc_skip: sb4)
                    -> sword;
}
extern "C" {
    pub fn odessp(cursor: *mut cda_def,
                  objnam: *mut OraText,
                  onlen: usize,
                  rsv1: *mut ub1,
                  rsv1ln: usize,
                  rsv2: *mut ub1,
                  rsv2ln: usize,
                  ovrld: *mut ub2,
                  pos: *mut ub2,
                  level: *mut ub2,
                  argnam: *mut *mut OraText,
                  arnlen: *mut ub2,
                  dtype: *mut ub2,
                  defsup: *mut ub1,
                  mode: *mut ub1,
                  dtsiz: *mut ub4,
                  prec: *mut sb2,
                  scale: *mut sb2,
                  radix: *mut ub1,
                  spare: *mut ub4,
                  arrsiz: *mut ub4)
                  -> sword;
}
extern "C" {
    pub fn odescr(cursor: *mut cda_def,
                  pos: sword,
                  dbsize: *mut sb4,
                  dbtype: *mut sb2,
                  cbuf: *mut sb1,
                  cbufl: *mut sb4,
                  dsize: *mut sb4,
                  prec: *mut sb2,
                  scale: *mut sb2,
                  nullok: *mut sb2)
                  -> sword;
}
extern "C" {
    pub fn oerhms(lda: *mut cda_def, rcode: sb2, buf: *mut OraText, bufsiz: sword) -> sword;
}
extern "C" {
    pub fn oermsg(rcode: sb2, buf: *mut OraText) -> sword;
}
extern "C" {
    pub fn oexec(cursor: *mut cda_def) -> sword;
}
extern "C" {
    pub fn oexfet(cursor: *mut cda_def, nrows: ub4, cancel: sword, exact: sword) -> sword;
}
extern "C" {
    pub fn oexn(cursor: *mut cda_def, iters: sword, rowoff: sword) -> sword;
}
extern "C" {
    pub fn ofen(cursor: *mut cda_def, nrows: sword) -> sword;
}
extern "C" {
    pub fn ofetch(cursor: *mut cda_def) -> sword;
}
extern "C" {
    pub fn oflng(cursor: *mut cda_def,
                 pos: sword,
                 buf: *mut ub1,
                 bufl: sb4,
                 dtype: sword,
                 retl: *mut ub4,
                 offset: sb4)
                 -> sword;
}
extern "C" {
    pub fn ogetpi(cursor: *mut cda_def,
                  piecep: *mut ub1,
                  ctxpp: *mut *mut ::std::os::raw::c_void,
                  iterp: *mut ub4,
                  indexp: *mut ub4)
                  -> sword;
}
extern "C" {
    pub fn oopt(cursor: *mut cda_def, rbopt: sword, waitopt: sword) -> sword;
}
extern "C" {
    pub fn opinit(mode: ub4) -> sword;
}
extern "C" {
    pub fn olog(lda: *mut cda_def,
                hda: *mut ub1,
                uid: *mut OraText,
                uidl: sword,
                pswd: *mut OraText,
                pswdl: sword,
                conn: *mut OraText,
                connl: sword,
                mode: ub4)
                -> sword;
}
extern "C" {
    pub fn ologof(lda: *mut cda_def) -> sword;
}
extern "C" {
    pub fn oopen(cursor: *mut cda_def,
                 lda: *mut cda_def,
                 dbn: *mut OraText,
                 dbnl: sword,
                 arsize: sword,
                 uid: *mut OraText,
                 uidl: sword)
                 -> sword;
}
extern "C" {
    pub fn oparse(cursor: *mut cda_def,
                  sqlstm: *mut OraText,
                  sqllen: sb4,
                  defflg: sword,
                  lngflg: ub4)
                  -> sword;
}
extern "C" {
    pub fn orol(lda: *mut cda_def) -> sword;
}
extern "C" {
    pub fn osetpi(cursor: *mut cda_def,
                  piece: ub1,
                  bufp: *mut ::std::os::raw::c_void,
                  lenp: *mut ub4)
                  -> sword;
}
extern "C" {
    pub fn sqlld2(lda: *mut cda_def, cname: *mut OraText, cnlen: *mut sb4);
}
extern "C" {
    pub fn sqllda(lda: *mut cda_def);
}
extern "C" {
    pub fn onbset(lda: *mut cda_def) -> sword;
}
extern "C" {
    pub fn onbtst(lda: *mut cda_def) -> sword;
}
extern "C" {
    pub fn onbclr(lda: *mut cda_def) -> sword;
}
extern "C" {
    pub fn ognfd(lda: *mut cda_def, fdp: *mut ::std::os::raw::c_void) -> sword;
}
extern "C" {
    pub fn obndra(cursor: *mut cda_def,
                  sqlvar: *mut OraText,
                  sqlvl: sword,
                  progv: *mut ub1,
                  progvl: sword,
                  ftype: sword,
                  scale: sword,
                  indp: *mut sb2,
                  alen: *mut ub2,
                  arcode: *mut ub2,
                  maxsiz: ub4,
                  cursiz: *mut ub4,
                  fmt: *mut OraText,
                  fmtl: sword,
                  fmtt: sword)
                  -> sword;
}
extern "C" {
    pub fn obndrn(cursor: *mut cda_def,
                  sqlvn: sword,
                  progv: *mut ub1,
                  progvl: sword,
                  ftype: sword,
                  scale: sword,
                  indp: *mut sb2,
                  fmt: *mut OraText,
                  fmtl: sword,
                  fmtt: sword)
                  -> sword;
}
extern "C" {
    pub fn obndrv(cursor: *mut cda_def,
                  sqlvar: *mut OraText,
                  sqlvl: sword,
                  progv: *mut ub1,
                  progvl: sword,
                  ftype: sword,
                  scale: sword,
                  indp: *mut sb2,
                  fmt: *mut OraText,
                  fmtl: sword,
                  fmtt: sword)
                  -> sword;
}
extern "C" {
    pub fn odefin(cursor: *mut cda_def,
                  pos: sword,
                  buf: *mut ub1,
                  bufl: sword,
                  ftype: sword,
                  scale: sword,
                  indp: *mut sb2,
                  fmt: *mut OraText,
                  fmtl: sword,
                  fmtt: sword,
                  rlen: *mut ub2,
                  rcode: *mut ub2)
                  -> sword;
}
extern "C" {
    pub fn oname(cursor: *mut cda_def,
                 pos: sword,
                 tbuf: *mut sb1,
                 tbufl: *mut sb2,
                 buf: *mut sb1,
                 bufl: *mut sb2)
                 -> sword;
}
extern "C" {
    pub fn orlon(lda: *mut cda_def,
                 hda: *mut ub1,
                 uid: *mut OraText,
                 uidl: sword,
                 pswd: *mut OraText,
                 pswdl: sword,
                 audit: sword)
                 -> sword;
}
extern "C" {
    pub fn olon(lda: *mut cda_def,
                uid: *mut OraText,
                uidl: sword,
                pswd: *mut OraText,
                pswdl: sword,
                audit: sword)
                -> sword;
}
extern "C" {
    pub fn osql3(cda: *mut cda_def, sqlstm: *mut OraText, sqllen: sword) -> sword;
}
extern "C" {
    pub fn odsc(cursor: *mut cda_def,
                pos: sword,
                dbsize: *mut sb2,
                fsize: *mut sb2,
                rcode: *mut sb2,
                dtype: *mut sb2,
                buf: *mut sb1,
                bufl: *mut sb2,
                dsize: *mut sb2)
                -> sword;
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub const nzerror_NZERROR_P12_DEST_FAILED: nzerror = nzerror::NZERROR_P12_CREATE_FAILED;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nzerror {
    NZERROR_OK = 0,
    NZERROR_GENERIC = 28750,
    NZERROR_NO_MEMORY = 28751,
    NZERROR_DATA_SOURCE_INIT_FAILED = 28752,
    NZERROR_DATA_SOURCE_TERM_FAILED = 28753,
    NZERROR_OBJECT_STORE_FAILED = 28754,
    NZERROR_OBJECT_GET_FAILED = 28755,
    NZERROR_MEMORY_ALLOC_FAILED = 28756,
    NZERROR_MEMORY_ALLOC_0_BYTES = 28757,
    NZERROR_MEMORY_FREE_FAILED = 28758,
    NZERROR_FILE_OPEN_FAILED = 28759,
    NZERROR_LIST_CREATION_FAILED = 28760,
    NZERROR_NO_ELEMENT = 28761,
    NZERROR_ELEMENT_ADD_FAILED = 28762,
    NZERROR_PARAMETER_BAD_TYPE = 28763,
    NZERROR_PARAMETER_RETRIEVAL = 28764,
    NZERROR_NO_LIST = 28765,
    NZERROR_TERMINATE_FAIL = 28766,
    NZERROR_BAD_VERSION_NUMBER = 28767,
    NZERROR_BAD_MAGIC_NUMBER = 28768,
    NZERROR_METHOD_NOT_FOUND = 28769,
    NZERROR_ALREADY_INITIALIZED = 28770,
    NZERROR_NOT_INITIALIZED = 28771,
    NZERROR_BAD_FILE_ID = 28772,
    NZERROR_WRITE_MAGIC_VERSION = 28773,
    NZERROR_FILE_WRITE_FAILED = 28774,
    NZERROR_FILE_CLOSE_FAILED = 28775,
    NZERROR_OUTPUT_BUFFER_TOO_SMALL = 28776,
    NZERROR_BINDING_CREATION_FAILED = 28777,
    NZERROR_PARAMETER_MALFORMED = 28778,
    NZERROR_PARAMETER_NO_METHOD = 28779,
    NZERROR_BAD_PARAMETER_METHOD = 28780,
    NZERROR_PARAMETER_NO_DATA = 28781,
    NZERROR_NOT_ALLOCATED = 28782,
    NZERROR_INVALID_PARAMETER = 28783,
    NZERROR_FILE_NAME_TRANSLATION = 28784,
    NZERROR_NO_SUCH_PARAMETER = 28785,
    NZERROR_DECRYPT_FAILED = 28786,
    NZERROR_ENCRYPT_FAILED = 28787,
    NZERROR_INVALID_INPUT = 28788,
    NZERROR_NAME_TYPE_NOT_FOUND = 28789,
    NZERROR_NLS_STRING_OPEN_FAILED = 28790,
    NZERROR_CERTIFICATE_VERIFY = 28791,
    NZERROR_OCI_PLSQL_FAILED = 28792,
    NZERROR_OCI_BIND_FAILED = 28793,
    NZERROR_ATTRIBUTE_INIT = 28794,
    NZERROR_ATTRIBUTE_FINISH_FAILED = 28795,
    NZERROR_UNSUPPORTED_METHOD = 28796,
    NZERROR_INVALID_KEY_DATA_TYPE = 28797,
    NZEROR_BIND_SUBKEY_COUNT = 28798,
    NZERROR_AUTH_SHARED_MEMORY = 28799,
    NZERROR_RIO_OPEN = 28800,
    NZERROR_RIO_OBJECT_TYPE = 28801,
    NZERROR_RIO_MODE = 28802,
    NZERROR_RIO_IO = 28803,
    NZERROR_RIO_CLOSE = 28804,
    NZERROR_RIO_RETRIEVE = 28805,
    NZERROR_RIO_STORE = 28806,
    NZERROR_RIO_UPDATE = 28807,
    NZERROR_RIO_INFO = 28808,
    NZERROR_RIO_DELETE = 28809,
    NZERROR_KD_CREATE = 28810,
    NZERROR_RIO_ACCESS_DESCRIPTOR = 28811,
    NZERROR_RIO_RECORD = 28812,
    NZERROR_RIO_RECORD_TYPE = 28813,
    NZERROR_PLSQL_ORACLE_TO_REAL = 28814,
    NZERROR_PLSQL_REAL_TO_ORACLE = 28815,
    NZERROR_TK_PLSQL_NO_PASSWORD = 28816,
    NZERROR_TK_PLSQL_GENERIC = 28817,
    NZERROR_TK_PLSQL_NO_CONTEXT = 28818,
    NZERROR_TK_PLSQL_NO_DIST_NAME = 28819,
    NZERROR_TK_PLSQL_NO_STATE = 28820,
    NZERROR_TK_PLSQL_NO_INPUT = 28821,
    NZERROR_TK_PLSQL_NO_SEED = 28822,
    NZERROR_TK_PLSQL_NO_BYTES = 28823,
    NZERROR_TK_INVALID_STATE = 28824,
    NZERROR_TK_PLSQL_NO_ENG_FUNC = 28825,
    NZERROR_TK_INV_ENG_FUNC = 28826,
    NZERROR_TK_INV_CIPHR_TYPE = 28827,
    NZERROR_TK_INV_IDENT_TYPE = 28828,
    NZERROR_TK_PLSQL_NO_CIPHER_TYPE = 28829,
    NZERROR_TK_PLSQL_NO_IDENT_TYPE = 28830,
    NZERROR_TK_PLSQL_NO_DATA_FMT = 28831,
    NZERROR_TK_INV_DATA_FMT = 28832,
    NZERROR_TK_PLSQL_INSUFF_INFO = 28833,
    NZERROR_TK_PLSQL_BUF_TOO_SMALL = 28834,
    NZERROR_TK_PLSQL_INV_IDENT_DESC = 28835,
    NZERROR_TK_PLSQL_WALLET_NOTOPEN = 28836,
    NZERROR_TK_PLSQL_NO_WALLET = 28837,
    NZERROR_TK_PLSQL_NO_IDENTITY = 28838,
    NZERROR_TK_PLSQL_NO_PERSONA = 28839,
    NZERROR_TK_PLSQL_WALLET_OPEN = 28840,
    NZERROR_UNSUPPORTED = 28841,
    NZERROR_FILE_BAD_PERMISSION = 28842,
    NZERROR_FILE_OSD_ERROR = 28843,
    NZERROR_NO_WALLET = 28844,
    NZERROR_NO_CERTIFICATE_ALERT = 28845,
    NZERROR_NO_PRIVATE_KEY = 28846,
    NZERROR_NO_CLEAR_PRIVATE_KEY_FILE = 28847,
    NZERROR_NO_ENCRYPTED_PRIVATE_KEY_FILE = 28848,
    NZERROR_NO_TRUSTPOINTS = 28849,
    NZERROR_NO_CLEAR_TRUSTPOINT_FILE = 28850,
    NZERROR_NO_ENCRYPTED_TRUSTPOINT_FILE = 28851,
    NZERROR_BAD_PASSWORD = 28852,
    NZERROR_INITIALIZATION_FAILED = 28853,
    NZERROR_SSLMemoryErr = 28854,
    NZERROR_SSLUnsupportedErr = 28855,
    NZERROR_SSLOverflowErr = 28856,
    NZERROR_SSLUnknownErr = 28857,
    NZERROR_SSLProtocolErr = 28858,
    NZERROR_SSLNegotiationErr = 28859,
    NZERROR_SSLFatalAlert = 28860,
    NZERROR_SSLWouldBlockErr = 28861,
    NZERROR_SSLIOErr = 28862,
    NZERROR_SSLSessionNotFoundErr = 28863,
    NZERROR_SSLConnectionClosedGraceful = 28864,
    NZERROR_SSLConnectionClosedError = 28865,
    NZERROR_ASNBadEncodingErr = 28866,
    NZERROR_ASNIntegerTooBigErr = 28867,
    NZERROR_X509CertChainInvalidErr = 28868,
    NZERROR_X509CertExpiredErr = 28869,
    NZERROR_X509NamesNotEqualErr = 28870,
    NZERROR_X509CertChainIncompleteErr = 28871,
    NZERROR_X509DataNotFoundErr = 28872,
    NZERROR_SSLBadParameterErr = 28873,
    NZERROR_SSLIOClosedOverrideGoodbyeKiss = 28874,
    NZERROR_X509MozillaSGCErr = 28875,
    NZERROR_X509IESGCErr = 28876,
    NZERROR_ImproperServerCredentials = 28877,
    NZERROR_ImproperClientCredentials = 28878,
    NZERROR_NoProtocolSideSet = 28879,
    NZERROR_setPersonaFailed = 28880,
    NZERROR_setCertFailed = 28881,
    NZERROR_setVKeyFailed = 28882,
    NZERROR_setTPFailed = 28883,
    NZERROR_BadCipherSuite = 28884,
    NZERROR_NoKeyPairForKeyUsage = 28885,
    NZERROR_EntrustLoginFailed = 28890,
    NZERROR_EntrustGetInfoFailed = 28891,
    NZERROR_EntrustLoadCertificateFailed = 28892,
    NZERROR_EntrustGetNameFailed = 28893,
    NZERROR_OPEN_WINDOWS_CERT_STORE_FAILED = 28900,
    NZERROR_CertNotInstalled = 29000,
    NZERROR_ServerDNMisMatched = 29002,
    NZERROR_ServerDNMisConfigured = 29003,
    NZERROR_CIC_ERR_SSL_ALERT_CB_FAILURE = 29004,
    NZERROR_CIC_ERR_SSL_BAD_CERTIFICATE = 29005,
    NZERROR_CIC_ERR_SSL_BAD_CERTIFICATE_REQUEST = 29006,
    NZERROR_CIC_ERR_SSL_BAD_CLEAR_KEY_LEN = 29007,
    NZERROR_CIC_ERR_SSL_BAD_DHPARAM_KEY_LENGTH = 29008,
    NZERROR_CIC_ERR_SSL_BAD_ENCRYPTED_KEY_LEN = 29009,
    NZERROR_CIC_ERR_SSL_BAD_EXPORT_KEY_LENGTH = 29010,
    NZERROR_CIC_ERR_SSL_BAD_FINISHED_MESSAGE = 29011,
    NZERROR_CIC_ERR_SSL_BAD_KEY_ARG_LEN = 29012,
    NZERROR_CIC_ERR_SSL_BAD_MAC = 29013,
    NZERROR_CIC_ERR_SSL_BAD_MAX_FRAGMENT_LENGTH_EXTENSION = 29014,
    NZERROR_CIC_ERR_SSL_BAD_MESSAGE_LENGTH = 29015,
    NZERROR_CIC_ERR_SSL_BAD_PKCS1_PADDING = 29016,
    NZERROR_CIC_ERR_SSL_BAD_PREMASTER_SECRET_LENGTH = 29017,
    NZERROR_CIC_ERR_SSL_BAD_PREMASTER_SECRET_VERSION = 29018,
    NZERROR_CIC_ERR_SSL_BAD_PROTOCOL_VERSION = 29019,
    NZERROR_CIC_ERR_SSL_BAD_RECORD_LENGTH = 29020,
    NZERROR_CIC_ERR_SSL_BAD_SECRET_KEY_LEN = 29021,
    NZERROR_CIC_ERR_SSL_BAD_SIDE = 29022,
    NZERROR_CIC_ERR_SSL_BUFFERS_NOT_EMPTY = 29023,
    NZERROR_CIC_ERR_SSL_CERTIFICATE_VALIDATE_FAILED = 29024,
    NZERROR_CIC_ERR_SSL_CERT_CHECK_CALLBACK = 29025,
    NZERROR_CIC_ERR_SSL_DECRYPT_FAILED = 29026,
    NZERROR_CIC_ERR_SSL_ENTROPY_COLLECTION = 29027,
    NZERROR_CIC_ERR_SSL_FAIL_SERVER_VERIFY = 29028,
    NZERROR_CIC_ERR_SSL_HANDSHAKE_ALREADY_COMPLETED = 29029,
    NZERROR_CIC_ERR_SSL_HANDSHAKE_REQUESTED = 29030,
    NZERROR_CIC_ERR_SSL_HANDSHAKE_REQUIRED = 29031,
    NZERROR_CIC_ERR_SSL_INCOMPLETE_IDENTITY = 29032,
    NZERROR_CIC_ERR_SSL_INVALID_PFX = 29033,
    NZERROR_CIC_ERR_SSL_NEEDS_CIPHER_OR_CLIENTAUTH = 29034,
    NZERROR_CIC_ERR_SSL_NEEDS_PRNG = 29035,
    NZERROR_CIC_ERR_SSL_NOT_SUPPORTED = 29036,
    NZERROR_CIC_ERR_SSL_NO_CERTIFICATE = 29037,
    NZERROR_CIC_ERR_SSL_NO_MATCHING_CERTIFICATES = 29038,
    NZERROR_CIC_ERR_SSL_NO_MATCHING_CIPHER_SUITES = 29039,
    NZERROR_CIC_ERR_SSL_NO_SUPPORTED_CIPHER_SUITES = 29040,
    NZERROR_CIC_ERR_SSL_NULL_CB = 29041,
    NZERROR_CIC_ERR_SSL_READ_BUFFER_NOT_EMPTY = 29042,
    NZERROR_CIC_ERR_SSL_READ_REQUIRED = 29043,
    NZERROR_CIC_ERR_SSL_RENEGOTIATION_ALREADY_REQUESTED = 29044,
    NZERROR_CIC_ERR_SSL_RENEGOTIATION_REFUSED = 29045,
    NZERROR_CIC_ERR_SSL_RESUMABLE_SESSION = 29046,
    NZERROR_CIC_ERR_SSL_TLS_EXTENSION_MISMATCH = 29047,
    NZERROR_CIC_ERR_SSL_UNEXPECTED_MSG = 29048,
    NZERROR_CIC_ERR_SSL_UNKNOWN_RECORD = 29049,
    NZERROR_CIC_ERR_SSL_UNSUPPORTED_CLIENT_AUTH_MODE = 29050,
    NZERROR_CIC_ERR_SSL_UNSUPPORTED_PUBKEY_TYPE = 29051,
    NZERROR_CIC_ERR_SSL_WRITE_BUFFER_NOT_EMPTY = 29052,
    NZERROR_CIC_ERR_PKCS12_MISSING_ALG = 29053,
    NZERROR_CIC_ERR_PKCS_AUTH_FAILED = 29054,
    NZERROR_CIC_ERR_PKCS_BAD_CONTENT_TYPE = 29055,
    NZERROR_CIC_ERR_PKCS_BAD_INPUT = 29056,
    NZERROR_CIC_ERR_PKCS_BAD_PADDING = 29057,
    NZERROR_CIC_ERR_PKCS_BAD_SN = 29058,
    NZERROR_CIC_ERR_PKCS_BAD_SN_LENGTH = 29059,
    NZERROR_CIC_ERR_PKCS_BAD_VERSION = 29060,
    NZERROR_CIC_ERR_PKCS_BASE = 29061,
    NZERROR_CIC_ERR_PKCS_FIELD_NOT_PRESENT = 29062,
    NZERROR_CIC_ERR_PKCS_NEED_CERTVAL = 29063,
    NZERROR_CIC_ERR_PKCS_NEED_PASSWORD = 29064,
    NZERROR_CIC_ERR_PKCS_NEED_PKC = 29065,
    NZERROR_CIC_ERR_PKCS_NEED_PRV_KEY = 29066,
    NZERROR_CIC_ERR_PKCS_NEED_TRUSTED = 29067,
    NZERROR_CIC_ERR_PKCS_UNSUPPORTED_CERT_FORMAT = 29068,
    NZERROR_CIC_ERR_PKCS_UNSUP_PRVKEY_TYPE = 29069,
    NZERROR_CIC_ERR_CODING_BAD_PEM = 29070,
    NZERROR_CIC_ERR_CODING_BASE = 29071,
    NZERROR_CIC_ERR_DER_BAD_ENCODING = 29072,
    NZERROR_CIC_ERR_DER_BAD_ENCODING_LENGTH = 29073,
    NZERROR_CIC_ERR_DER_BASE = 29074,
    NZERROR_CIC_ERR_DER_ELEMENT_TOO_LONG = 29075,
    NZERROR_CIC_ERR_DER_INDEFINITE_LENGTH = 29076,
    NZERROR_CIC_ERR_DER_NO_MORE_ELEMENTS = 29077,
    NZERROR_CIC_ERR_DER_OBJECT_TOO_LONG = 29078,
    NZERROR_CIC_ERR_DER_TAG_SIZE = 29079,
    NZERROR_CIC_ERR_DER_TIME_OUT_OF_RANGE = 29080,
    NZERROR_CIC_ERR_DER_UNUSED_BITS_IN_BIT_STR = 29081,
    NZERROR_CIC_ERR_GENERAL_BASE = 29082,
    NZERROR_CIC_ERR_HASH_BASE = 29083,
    NZERROR_CIC_ERR_ILLEGAL_PARAM = 29084,
    NZERROR_CIC_ERR_MEM_NOT_OURS = 29085,
    NZERROR_CIC_ERR_MEM_OVERRUN = 29086,
    NZERROR_CIC_ERR_MEM_UNDERRUN = 29087,
    NZERROR_CIC_ERR_MEM_WAS_FREED = 29088,
    NZERROR_CIC_ERR_NOT_FOUND = 29090,
    NZERROR_CIC_ERR_NO_PTR = 29091,
    NZERROR_CIC_ERR_TIMEOUT = 29092,
    NZERROR_CIC_ERR_UNIT_MASK = 29093,
    NZERROR_CIC_ERR_BAD_CTX = 29094,
    NZERROR_CIC_ERR_BAD_INDEX = 29095,
    NZERROR_CIC_ERR_BAD_LENGTH = 29096,
    NZERROR_CIC_ERR_CODING_BAD_ENCODING = 29097,
    NZERROR_CIC_ERR_SSL_NO_CLIENT_AUTH_MODES = 29098,
    NZERROR_LOCKEYID_CREATE_FAILED = 29100,
    NZERROR_P12_ADD_PVTKEY_FAILED = 29101,
    NZERROR_P12_ADD_CERT_FAILED = 29102,
    NZERROR_P12_WLT_CREATE_FAILED = 29103,
    NZERROR_P12_ADD_CERTREQ_FAILED = 29104,
    NZERROR_P12_WLT_EXP_FAILED = 29105,
    NZERROR_P12_WLT_IMP_FAILED = 29106,
    NZERROR_P12_CREATE_FAILED = 29107,
    NZERROR_P12_RAND_ERROR = 29108,
    NZERROR_P12_PVTKEY_CRT_FAILED = 29109,
    NZERROR_P12_INVALID_BAG = 29110,
    NZERROR_P12_INVALID_INDEX = 29111,
    NZERROR_P12_GET_CERT_FAILED = 29112,
    NZERROR_P12_GET_PVTKEY_FAILED = 29113,
    NZERROR_P12_IMP_PVTKEY_FAILED = 29114,
    NZERROR_P12_EXP_PVTKEY_FAILED = 29115,
    NZERROR_P12_GET_ATTRIB_FAILED = 29116,
    NZERROR_P12_ADD_ATTRIB_FAILED = 29117,
    NZERROR_P12_CRT_ATTRIB_FAILED = 29118,
    NZERROR_P12_IMP_CERT_FAILED = 29119,
    NZERROR_P12_EXP_CERT_FAILED = 29120,
    NZERROR_P12_ADD_SECRET_FAILED = 29121,
    NZERROR_P12_ADD_PKCS11INFO_FAILED = 29122,
    NZERROR_P12_GET_PKCS11INFO_FAILED = 29123,
    NZERROR_P12_MULTIPLE_PKCS11_LIBNAME = 29124,
    NZERROR_P12_MULTIPLE_PKCS11_TOKENLABEL = 29125,
    NZERROR_P12_MULTIPLE_PKCS11_TOKENPASSPHRASE = 29126,
    NZERROR_P12_UNKNOWN_PKCS11INFO = 29127,
    NZERROR_P12_PKCS11_LIBNAME_NOT_SET = 29128,
    NZERROR_P12_PKCS11_TOKENLABEL_NOT_SET = 29129,
    NZERROR_P12_PKCS11_TOKENPASSPHRASE_NOT_SET = 29130,
    NZERROR_P12_MULTIPLE_PKCS11_CERTLABEL = 29131,
    NZERROR_CIC_ERR_RANDOM = 29135,
    NZERROR_CIC_ERR_SMALL_BUFFER = 29136,
    NZERROR_CIC_ERR_SSL_BAD_CONTEXT = 29137,
    NZERROR_MUTEX_INITIALIZE_FAILED = 29138,
    NZERROR_MUTEX_DESTROY_FAILED = 29139,
    NZERROR_BS_CERTOBJ_CREAT_FAILED = 29140,
    NZERROR_BS_DER_IMP_FAILED = 29141,
    NZERROR_CERT_NAME_ERROR = 29142,
    NZERROR_EXT_ERROR = 29143,
    NZERROR_DES_SELF_TEST_FAILED = 29150,
    NZERROR_3DES_SELF_TEST_FAILED = 29151,
    NZERROR_SHA_SELF_TEST_FAILED = 29152,
    NZERROR_RSA_SELF_TEST_FAILED = 29153,
    NZERROR_DRNG_SELF_TEST_FAILED = 29154,
    NZERROR_CKEYPAIR_SELF_TEST_FAILED = 29155,
    NZERROR_CRNG_SELF_TEST_FAILED = 29156,
    NZERROR_FIPS_PATHNAME_ERROR = 29157,
    NZERROR_FIPS_LIB_OPEN_FAILED = 29158,
    NZERROR_FIPS_LIB_READ_ERROR = 29159,
    NZERROR_FIPS_LIB_DIFFERS = 29160,
    NZERROR_DAC_SELF_TEST_FAILED = 29161,
    NZERROR_NONFIPS_CIPHERSUITE = 29162,
    NZERROR_VENDOR_NOT_SUPPORTED_FIPS_MODE = 29163,
    NZERROR_EXTERNAL_PKCS12_NOT_SUPPORTED_FIPS_MODE = 29164,
    NZERROR_AES_SELF_TEST_FAILED = 29165,
    NZERROR_FIPS_BAD_KEYSIZE = 29166,
    NZERROR_CRL_SIG_VERIFY_FAILED = 29176,
    NZERROR_CERT_NOT_IN_CRL = 29177,
    NZERROR_CERT_IN_CRL = 29178,
    NZERROR_CERT_IN_CRL_CHECK_FAILED = 29179,
    NZERROR_INVALID_CERT_STATUS_PROTOCOL = 29180,
    NZERROR_LDAP_OPEN_FAILED = 29181,
    NZERROR_LDAP_BIND_FAILED = 29182,
    NZERROR_LDAP_SEARCH_FAILED = 29183,
    NZERROR_LDAP_RESULT_FAILED = 29184,
    NZERROR_LDAP_FIRSTATTR_FAILED = 29185,
    NZERROR_LDAP_GETVALUESLEN_FAILED = 29186,
    NZERROR_LDAP_UNSUPPORTED_VALMEC = 29187,
    NZERROR_LDAP_COUNT_ENTRIES_FAILED = 29188,
    NZERROR_LDAP_NO_ENTRY_FOUND = 29189,
    NZERROR_LDAP_MULTIPLE_ENTRIES_FOUND = 29190,
    NZERROR_OID_INFO_NOT_SET = 29191,
    NZERROR_LDAP_VALMEC_NOT_SET = 29192,
    NZERROR_CRLDP_NO_CRL_FOUND = 29193,
    NZERROR_CRL_NOT_IN_CACHE = 29194,
    NZERROR_CRL_EXPIRED = 29195,
    NZERROR_CRL_FILETOOBIG = 29196,
    NZERROR_DN_MATCH = 29222,
    NZERROR_CERT_CHAIN_CREATION = 29223,
    NZERROR_NO_MATCHING_CERT_REQ = 29224,
    NZERROR_CERT_ALREADY_INSTALLED = 29225,
    NZERROR_NO_MATCHING_PRIVATE_KEY = 29226,
    NZERROR_VALIDITY_EXPIRED = 29227,
    NZERROR_TK_BYTES_NEEDED = 29228,
    NZERROR_TK_BAD_MAGIC_NUMBER = 29229,
    NZERROR_TK_BAD_HEADER_LENGTH = 29230,
    NZERROR_TK_CE_INIT = 29231,
    NZERROR_TK_CE_KEYINIT = 29232,
    NZERROR_TK_CE_ENCODE_KEY = 29233,
    NZERROR_TK_CE_DECODE_KEY = 29234,
    NZERROR_TK_CE_GEYKEYINFO = 29235,
    NZERROR_TK_SEED_RANDOM = 29236,
    NZERROR_TK_CE_ALGFINISH = 29237,
    NZERROR_TK_CE_ALGAPPLY = 29238,
    NZERROR_TK_CE_ALGINIT = 29239,
    NZERROR_TK_ALGORITHM = 29240,
    NZERROR_TK_CANNOT_GROW = 29241,
    NZERROR_TK_KEYSIZE = 29242,
    NZERROR_TK_KEYTYPE = 29243,
    NZERROR_TK_PLSQL_NO_WRL = 29244,
    NZERROR_TK_CE_FUNC = 29245,
    NZERROR_TK_TDU_FORMAT = 29246,
    NZERROR_TK_NOTOPEN = 29247,
    NZERROR_TK_WRLTYPE = 29248,
    NZERROR_TK_CE_STATE = 29249,
    NZERROR_PKCS11_LIBRARY_NOT_FOUND = 43000,
    NZERROR_PKCS11_TOKEN_NOT_FOUND = 43001,
    NZERROR_PKCS11_BAD_PASSPHRASE = 43002,
    NZERROR_PKCS11_GET_FUNC_LIST = 43003,
    NZERROR_PKCS11_INITIALIZE = 43004,
    NZERROR_PKCS11_NO_TOKENS_PRESENT = 43005,
    NZERROR_PKCS11_GET_SLOT_LIST = 43006,
    NZERROR_PKCS11_GET_TOKEN_INFO = 43008,
    NZERROR_PKCS11_SYMBOL_NOT_FOUND = 43009,
    NZERROR_PKCS11_TOKEN_LOGIN_FAILED = 43011,
    NZERROR_PKCS11_CHANGE_PROVIDERS_ERROR = 43013,
    NZERROR_PKCS11_GET_PRIVATE_KEY_ERROR = 43014,
    NZERROR_PKCS11_CREATE_KEYPAIR_ERROR = 43015,
    NZERROR_PKCS11_WALLET_CONTAINS_P11_INFO = 43016,
    NZERROR_PKCS11_NO_CERT_ON_TOKEN = 43017,
    NZERROR_PKCS11_NO_USER_CERT_ON_TOKEN = 43018,
    NZERROR_PKCS11_NO_CERT_ON_TOKEN_WITH_GIVEN_LABEL = 43019,
    NZERROR_PKCS11_MULTIPLE_CERTS_ON_TOKEN_WITH_GIVEN_LABEL = 43020,
    NZERROR_PKCS11_CERT_WITH_LABEL_NOT_USER_CERT = 43021,
    NZERROR_BIND_SERVICE_ERROR = 43050,
    NZERROR_CREATE_KEY_OBJ_ERROR = 43051,
    NZERROR_GET_CERT_FIELDS = 43052,
    NZERROR_CREATE_PKCS10_OBJECT = 43053,
    NZERROR_SET_PKCS10_FIELDS = 43054,
    NZERROR_SIGN_CERT_REQUEST = 43055,
    NZERROR_GET_PKCS10_DER = 43056,
    NZERROR_INITIALIZE_CERTC = 43057,
    NZERROR_INSERT_PRIVATE_KEY = 43058,
    NZERROR_RSA_ERROR = 43059,
    NZERROR_SLTSCTX_INIT_FAILED = 43060,
    NZERROR_SLTSKYC_FAILED = 43061,
    NZERROR_SLTSCTX_TERM_FAILED = 43062,
    NZERROR_SLTSKYS_FAILED = 43063,
    NZERROR_INVALID_HEADER_LENGTH = 43070,
    NZERROR_WALLET_CONTAINS_USER_CREDENTIALS = 43071,
    NZERROR_CANNOT_MODIFY_AL = 43072,
    NZERROR_FILE_LOCK_FAILED = 43073,
    NZERROR_MULTIPLE_MATCHING_CREDENTIALS = 43080,
    NZERROR_KEYPAIR_CHECK = 43081,
    NZERROR_CSF_ALIAS_INVALID = 43100,
    NZERROR_CSF_KEY_INVALID = 43101,
    NZERROR_CSF_CRED_NOT_SUPPORTED = 43102,
    NZERROR_CSF_HOSTNAME = 43103,
    NZERROR_CSF_XML = 43104,
    NZERROR_CSF_WALLET_NOT_SPECIFIED = 43105,
    NZERROR_CSF_MAP_NOT_IN_STORE = 43106,
    NZERROR_CSF_KEY_NOT_IN_STORE = 43107,
    NZERROR_CSF_ENTRY_EXISTS = 43108,
    NZERROR_CSF_BTSTRP_WLT_PATH_NOT_SET = 43109,
    NZERROR_CSF_BTSTRP_WLT_MAP_NOT_SET = 43110,
    NZERROR_CSF_BTSTRP_WLT_KEY_NOT_SET = 43111,
    NZERROR_CSF_LDAP_USERNAME_NOT_SET = 43112,
    NZERROR_CSF_LDAP_PWD_NOT_SET = 43113,
    NZERROR_CSF_LDAP_URL_NOT_SET = 43114,
    NZERROR_CSF_LDAP_PORT_NOT_SET = 43115,
    NZERROR_CSF_LDAP_FARMNAME_NOT_SET = 43116,
    NZERROR_CSF_LDAP_ROOTNAME_NOT_SET = 43117,
    NZERROR_SSL_UNSUPPORTED_CIPHER = 43120,
    NZERROR_SSL_BAD_ENCRYPTED_VAUE = 43121,
    NZERROR_SSL_ERR_SIGNATURE = 43122,
    NZERROR_SSL_HARDWARE_FAILURE = 43123,
    NZERROR_SSL_ERR_PKEY = 43124,
    NZERROR_SSL_HANDSHAKE_FAILED = 43125,
    NZERROR_UNKNOWN_ECC_CURVE = 43130,
    NZERROR_ODBC_SQL_FAILED = 43131,
    NZERROR_CSF_DB_B64_DECODE_FAILED = 43132,
    NZERROR_CSF_DB_DEC_SPLIT_FAILED = 43133,
    NZERROR_CSF_DB_DECKEY_NULL = 43134,
    NZERROR_CSF_MAP_NOT_PRESENT = 43135,
    NZERROR_CSF_KEY_NOT_PRESENT = 43136,
    NZERROR_LX_ERROR = 43490,
    NZERROR_LAST_ERROR = 43499,
    NZERROR_THIS_MUST_BE_LAST = 43500,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nzttwrl {
    NZTTWRL_DEFAULT = 1,
    NZTTWRL_SQLNET = 2,
    NZTTWRL_FILE = 3,
    NZTTWRL_ENTR = 4,
    NZTTWRL_MCS = 5,
    NZTTWRL_ORACLE = 6,
    NZTTWRL_NULL = 7,
    NZTTWRL_REGISTRY = 8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nzctx {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nzstrc {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nzosContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nzttIdentity {
    pub dn_nzttIdentity: *mut text,
    pub dnlen_nzttIdentity: ub4,
    pub comment_nzttIdentity: *mut text,
    pub commentlen_nzttIdentity: ub4,
    pub private_nzttIdentity: *mut nzttIdentityPrivate,
    pub next_nzttIdentity: *mut nzttIdentity,
}
#[test]
fn bindgen_test_layout_nzttIdentity() {
    assert_eq!(::std::mem::size_of::<nzttIdentity>(),
               48usize,
               concat!("Size of: ", stringify!(nzttIdentity)));
    assert_eq!(::std::mem::align_of::<nzttIdentity>(),
               8usize,
               concat!("Alignment of ", stringify!(nzttIdentity)));
    assert_eq!(unsafe { &(*(0 as *const nzttIdentity)).dn_nzttIdentity as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(nzttIdentity),
                       "::",
                       stringify!(dn_nzttIdentity)));
    assert_eq!(unsafe { &(*(0 as *const nzttIdentity)).dnlen_nzttIdentity as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(nzttIdentity),
                       "::",
                       stringify!(dnlen_nzttIdentity)));
    assert_eq!(unsafe { &(*(0 as *const nzttIdentity)).comment_nzttIdentity as *const _ as usize },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(nzttIdentity),
                       "::",
                       stringify!(comment_nzttIdentity)));
    assert_eq!(unsafe {
                   &(*(0 as *const nzttIdentity)).commentlen_nzttIdentity as *const _ as usize
               },
               24usize,
               concat!("Alignment of field: ",
                       stringify!(nzttIdentity),
                       "::",
                       stringify!(commentlen_nzttIdentity)));
    assert_eq!(unsafe { &(*(0 as *const nzttIdentity)).private_nzttIdentity as *const _ as usize },
               32usize,
               concat!("Alignment of field: ",
                       stringify!(nzttIdentity),
                       "::",
                       stringify!(private_nzttIdentity)));
    assert_eq!(unsafe { &(*(0 as *const nzttIdentity)).next_nzttIdentity as *const _ as usize },
               40usize,
               concat!("Alignment of field: ",
                       stringify!(nzttIdentity),
                       "::",
                       stringify!(next_nzttIdentity)));
}
impl Clone for nzttIdentity {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nzttIdentityPrivate {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nzttPersona {
    pub genericName_nzttPersona: *mut ub1,
    pub genericNamelen_nzttPersona: ub4,
    pub private_nzttPersona: *mut nzttPersonaPrivate,
    pub mycertreqs_nzttPersona: *mut nzttIdentity,
    pub mycerts_nzttPersona: *mut nzttIdentity,
    pub mytps_nzttPersona: *mut nzttIdentity,
    pub mystore_nzttPersona: *mut nzssEntry,
    pub mypkcs11Info_nzttPersona: *mut nzpkcs11_Info,
    pub next_nzttPersona: *mut nzttPersona,
    pub p12Info_nzttPersona: *mut nzpkcs12_Info,
}
#[test]
fn bindgen_test_layout_nzttPersona() {
    assert_eq!(::std::mem::size_of::<nzttPersona>(),
               80usize,
               concat!("Size of: ", stringify!(nzttPersona)));
    assert_eq!(::std::mem::align_of::<nzttPersona>(),
               8usize,
               concat!("Alignment of ", stringify!(nzttPersona)));
    assert_eq!(unsafe {
                   &(*(0 as *const nzttPersona)).genericName_nzttPersona as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(nzttPersona),
                       "::",
                       stringify!(genericName_nzttPersona)));
    assert_eq!(unsafe {
                   &(*(0 as *const nzttPersona)).genericNamelen_nzttPersona as *const _ as usize
               },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(nzttPersona),
                       "::",
                       stringify!(genericNamelen_nzttPersona)));
    assert_eq!(unsafe { &(*(0 as *const nzttPersona)).private_nzttPersona as *const _ as usize },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(nzttPersona),
                       "::",
                       stringify!(private_nzttPersona)));
    assert_eq!(unsafe {
                   &(*(0 as *const nzttPersona)).mycertreqs_nzttPersona as *const _ as usize
               },
               24usize,
               concat!("Alignment of field: ",
                       stringify!(nzttPersona),
                       "::",
                       stringify!(mycertreqs_nzttPersona)));
    assert_eq!(unsafe { &(*(0 as *const nzttPersona)).mycerts_nzttPersona as *const _ as usize },
               32usize,
               concat!("Alignment of field: ",
                       stringify!(nzttPersona),
                       "::",
                       stringify!(mycerts_nzttPersona)));
    assert_eq!(unsafe { &(*(0 as *const nzttPersona)).mytps_nzttPersona as *const _ as usize },
               40usize,
               concat!("Alignment of field: ",
                       stringify!(nzttPersona),
                       "::",
                       stringify!(mytps_nzttPersona)));
    assert_eq!(unsafe { &(*(0 as *const nzttPersona)).mystore_nzttPersona as *const _ as usize },
               48usize,
               concat!("Alignment of field: ",
                       stringify!(nzttPersona),
                       "::",
                       stringify!(mystore_nzttPersona)));
    assert_eq!(unsafe {
                   &(*(0 as *const nzttPersona)).mypkcs11Info_nzttPersona as *const _ as usize
               },
               56usize,
               concat!("Alignment of field: ",
                       stringify!(nzttPersona),
                       "::",
                       stringify!(mypkcs11Info_nzttPersona)));
    assert_eq!(unsafe { &(*(0 as *const nzttPersona)).next_nzttPersona as *const _ as usize },
               64usize,
               concat!("Alignment of field: ",
                       stringify!(nzttPersona),
                       "::",
                       stringify!(next_nzttPersona)));
    assert_eq!(unsafe { &(*(0 as *const nzttPersona)).p12Info_nzttPersona as *const _ as usize },
               72usize,
               concat!("Alignment of field: ",
                       stringify!(nzttPersona),
                       "::",
                       stringify!(p12Info_nzttPersona)));
}
impl Clone for nzttPersona {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nzttPersonaPrivate {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nzttWallet {
    pub ldapName_nzttWallet: *mut ub1,
    pub ldapNamelen_nzttWallet: ub4,
    pub securePolicy_nzttWallet: nzttPolicy,
    pub openPolicy_nzttWallet: nzttPolicy,
    pub persona_nzttWallet: *mut nzttPersona,
    pub private_nzttWallet: *mut nzttWalletPrivate,
}
#[test]
fn bindgen_test_layout_nzttWallet() {
    assert_eq!(::std::mem::size_of::<nzttWallet>(),
               40usize,
               concat!("Size of: ", stringify!(nzttWallet)));
    assert_eq!(::std::mem::align_of::<nzttWallet>(),
               8usize,
               concat!("Alignment of ", stringify!(nzttWallet)));
    assert_eq!(unsafe { &(*(0 as *const nzttWallet)).ldapName_nzttWallet as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(nzttWallet),
                       "::",
                       stringify!(ldapName_nzttWallet)));
    assert_eq!(unsafe { &(*(0 as *const nzttWallet)).ldapNamelen_nzttWallet as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(nzttWallet),
                       "::",
                       stringify!(ldapNamelen_nzttWallet)));
    assert_eq!(unsafe {
                   &(*(0 as *const nzttWallet)).securePolicy_nzttWallet as *const _ as usize
               },
               12usize,
               concat!("Alignment of field: ",
                       stringify!(nzttWallet),
                       "::",
                       stringify!(securePolicy_nzttWallet)));
    assert_eq!(unsafe { &(*(0 as *const nzttWallet)).openPolicy_nzttWallet as *const _ as usize },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(nzttWallet),
                       "::",
                       stringify!(openPolicy_nzttWallet)));
    assert_eq!(unsafe { &(*(0 as *const nzttWallet)).persona_nzttWallet as *const _ as usize },
               24usize,
               concat!("Alignment of field: ",
                       stringify!(nzttWallet),
                       "::",
                       stringify!(persona_nzttWallet)));
    assert_eq!(unsafe { &(*(0 as *const nzttWallet)).private_nzttWallet as *const _ as usize },
               32usize,
               concat!("Alignment of field: ",
                       stringify!(nzttWallet),
                       "::",
                       stringify!(private_nzttWallet)));
}
impl Clone for nzttWallet {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nzttWalletPrivate {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nzttWalletObj {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nzssEntry {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nzpkcs11_Info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nzpkcs12_Info {
    _unused: [u8; 0],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nzttces {
    NZTTCES_CONTINUE = 1,
    NZTTCES_END = 2,
    NZTTCES_RESET = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nzttcef {
    NZTTCEF_DETACHEDSIGNATURE = 1,
    NZTTCEF_SIGNATURE = 2,
    NZTTCEF_ENVELOPING = 3,
    NZTTCEF_PKENCRYPTION = 4,
    NZTTCEF_ENCRYPTION = 5,
    NZTTCEF_KEYEDHASH = 6,
    NZTTCEF_HASH = 7,
    NZTTCEF_RANDOM = 8,
    NZTTCEF_LAST = 9,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nzttState {
    NZTTSTATE_EMPTY = 0,
    NZTTSTATE_REQUESTED = 1,
    NZTTSTATE_READY = 2,
    NZTTSTATE_INVALID = 3,
    NZTTSTATE_RENEWAL = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nzttVersion {
    NZTTVERSION_X509v1 = 1,
    NZTTVERSION_X509v3 = 2,
    NZTTVERSION_INVALID_TYPE = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nzttCipherType {
    NZTTCIPHERTYPE_INVALID = 0,
    NZTTCIPHERTYPE_RSA = 1,
    NZTTCIPHERTYPE_DES = 2,
    NZTTCIPHERTYPE_RC4 = 3,
    NZTTCIPHERTYPE_MD5DES = 4,
    NZTTCIPHERTYPE_MD5RC2 = 5,
    NZTTCIPHERTYPE_MD5 = 6,
    NZTTCIPHERTYPE_SHA = 7,
    NZTTCIPHERTYPE_ECC = 8,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nztttdufmt {
    NZTTTDUFMT_PKCS7 = 1,
    NZTTTDUFMT_RSAPAD = 2,
    NZTTTDUFMT_ORACLEv1 = 3,
    NZTTTDUFMT_LAST = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nzttValState {
    NZTTVALSTATE_NONE = 1,
    NZTTVALSTATE_GOOD = 2,
    NZTTVALSTATE_REVOKED = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nzttPolicy {
    NZTTPOLICY_NONE = 0,
    NZTTPOLICY_RETRY_1 = 1,
    NZTTPOLICY_RETRY_2 = 2,
    NZTTPOLICY_RETRY_3 = 3,
}
pub type nzttID = [ub1; 16usize];
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nzttIdentType {
    NZTTIDENTITYTYPE_INVALID_TYPE = 0,
    NZTTIDENTITYTYPE_CERTIFICTAE = 1,
    NZTTIDENTITYTYPE_CERT_REQ = 2,
    NZTTIDENTITYTYPE_RENEW_CERT_REQ = 3,
    NZTTIDENTITYTYPE_CLEAR_ETP = 4,
    NZTTIDENTITYTYPE_CLEAR_UTP = 5,
    NZTTIDENTITYTYPE_CLEAR_PTP = 6,
}
pub type nzttKPUsage = ub4;
pub type nzttTStamp = [ub1; 4usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nzttBufferBlock {
    pub flags_nzttBufferBlock: uword,
    pub buflen_nzttBufferBlock: ub4,
    pub usedlen_nzttBufferBlock: ub4,
    pub buffer_nzttBufferBlock: *mut ub1,
}
#[test]
fn bindgen_test_layout_nzttBufferBlock() {
    assert_eq!(::std::mem::size_of::<nzttBufferBlock>(),
               24usize,
               concat!("Size of: ", stringify!(nzttBufferBlock)));
    assert_eq!(::std::mem::align_of::<nzttBufferBlock>(),
               8usize,
               concat!("Alignment of ", stringify!(nzttBufferBlock)));
    assert_eq!(unsafe {
                   &(*(0 as *const nzttBufferBlock)).flags_nzttBufferBlock as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(nzttBufferBlock),
                       "::",
                       stringify!(flags_nzttBufferBlock)));
    assert_eq!(unsafe {
                   &(*(0 as *const nzttBufferBlock)).buflen_nzttBufferBlock as *const _ as usize
               },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(nzttBufferBlock),
                       "::",
                       stringify!(buflen_nzttBufferBlock)));
    assert_eq!(unsafe {
                   &(*(0 as *const nzttBufferBlock)).usedlen_nzttBufferBlock as *const _ as usize
               },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(nzttBufferBlock),
                       "::",
                       stringify!(usedlen_nzttBufferBlock)));
    assert_eq!(unsafe {
                   &(*(0 as *const nzttBufferBlock)).buffer_nzttBufferBlock as *const _ as usize
               },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(nzttBufferBlock),
                       "::",
                       stringify!(buffer_nzttBufferBlock)));
}
impl Clone for nzttBufferBlock {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nzttB64Cert {
    pub b64Cert_nzttB64Cert: *mut ub1,
    pub b64Certlen_nzttB64Cert: ub4,
    pub next_nzttB64Cert: *mut nzttB64Cert,
}
#[test]
fn bindgen_test_layout_nzttB64Cert() {
    assert_eq!(::std::mem::size_of::<nzttB64Cert>(),
               24usize,
               concat!("Size of: ", stringify!(nzttB64Cert)));
    assert_eq!(::std::mem::align_of::<nzttB64Cert>(),
               8usize,
               concat!("Alignment of ", stringify!(nzttB64Cert)));
    assert_eq!(unsafe { &(*(0 as *const nzttB64Cert)).b64Cert_nzttB64Cert as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(nzttB64Cert),
                       "::",
                       stringify!(b64Cert_nzttB64Cert)));
    assert_eq!(unsafe {
                   &(*(0 as *const nzttB64Cert)).b64Certlen_nzttB64Cert as *const _ as usize
               },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(nzttB64Cert),
                       "::",
                       stringify!(b64Certlen_nzttB64Cert)));
    assert_eq!(unsafe { &(*(0 as *const nzttB64Cert)).next_nzttB64Cert as *const _ as usize },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(nzttB64Cert),
                       "::",
                       stringify!(next_nzttB64Cert)));
}
impl Clone for nzttB64Cert {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nzttPKCS7ProtInfo {
    pub mictype_nzttPKCS7ProtInfo: nzttCipherType,
    pub symmtype_nzttPKCS7ProtInfo: nzttCipherType,
    pub keylen_nzttPKCS7ProtInfo: ub4,
}
#[test]
fn bindgen_test_layout_nzttPKCS7ProtInfo() {
    assert_eq!(::std::mem::size_of::<nzttPKCS7ProtInfo>(),
               12usize,
               concat!("Size of: ", stringify!(nzttPKCS7ProtInfo)));
    assert_eq!(::std::mem::align_of::<nzttPKCS7ProtInfo>(),
               4usize,
               concat!("Alignment of ", stringify!(nzttPKCS7ProtInfo)));
    assert_eq!(unsafe {
                   &(*(0 as *const nzttPKCS7ProtInfo)).mictype_nzttPKCS7ProtInfo as *const _ as
                   usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(nzttPKCS7ProtInfo),
                       "::",
                       stringify!(mictype_nzttPKCS7ProtInfo)));
    assert_eq!(unsafe {
                   &(*(0 as *const nzttPKCS7ProtInfo)).symmtype_nzttPKCS7ProtInfo as *const _ as
                   usize
               },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(nzttPKCS7ProtInfo),
                       "::",
                       stringify!(symmtype_nzttPKCS7ProtInfo)));
    assert_eq!(unsafe {
                   &(*(0 as *const nzttPKCS7ProtInfo)).keylen_nzttPKCS7ProtInfo as *const _ as usize
               },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(nzttPKCS7ProtInfo),
                       "::",
                       stringify!(keylen_nzttPKCS7ProtInfo)));
}
impl Clone for nzttPKCS7ProtInfo {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Copy)]
pub union nzttProtInfo {
    pub pkcs7_nzttProtInfo: nzttPKCS7ProtInfo,
    _bindgen_union_align: [u32; 3usize],
}
#[test]
fn bindgen_test_layout_nzttProtInfo() {
    assert_eq!(::std::mem::size_of::<nzttProtInfo>(),
               12usize,
               concat!("Size of: ", stringify!(nzttProtInfo)));
    assert_eq!(::std::mem::align_of::<nzttProtInfo>(),
               4usize,
               concat!("Alignment of ", stringify!(nzttProtInfo)));
    assert_eq!(unsafe { &(*(0 as *const nzttProtInfo)).pkcs7_nzttProtInfo as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(nzttProtInfo),
                       "::",
                       stringify!(pkcs7_nzttProtInfo)));
}
impl Clone for nzttProtInfo {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nzttPersonaDesc {
    pub privlen_nzttPersonaDesc: ub4,
    pub priv_nzttPersonaDesc: *mut ub1,
    pub prllen_nzttPersonaDesc: ub4,
    pub prl_nzttPersonaDesc: *mut text,
    pub aliaslen_nzttPersonaDesc: ub4,
    pub alias_nzttPersonaDesc: *mut text,
    pub longlen_nzttPersonaDesc: ub4,
    pub long_nzttPersonaDesc: *mut text,
}
#[test]
fn bindgen_test_layout_nzttPersonaDesc() {
    assert_eq!(::std::mem::size_of::<nzttPersonaDesc>(),
               64usize,
               concat!("Size of: ", stringify!(nzttPersonaDesc)));
    assert_eq!(::std::mem::align_of::<nzttPersonaDesc>(),
               8usize,
               concat!("Alignment of ", stringify!(nzttPersonaDesc)));
    assert_eq!(unsafe {
                   &(*(0 as *const nzttPersonaDesc)).privlen_nzttPersonaDesc as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(nzttPersonaDesc),
                       "::",
                       stringify!(privlen_nzttPersonaDesc)));
    assert_eq!(unsafe {
                   &(*(0 as *const nzttPersonaDesc)).priv_nzttPersonaDesc as *const _ as usize
               },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(nzttPersonaDesc),
                       "::",
                       stringify!(priv_nzttPersonaDesc)));
    assert_eq!(unsafe {
                   &(*(0 as *const nzttPersonaDesc)).prllen_nzttPersonaDesc as *const _ as usize
               },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(nzttPersonaDesc),
                       "::",
                       stringify!(prllen_nzttPersonaDesc)));
    assert_eq!(unsafe {
                   &(*(0 as *const nzttPersonaDesc)).prl_nzttPersonaDesc as *const _ as usize
               },
               24usize,
               concat!("Alignment of field: ",
                       stringify!(nzttPersonaDesc),
                       "::",
                       stringify!(prl_nzttPersonaDesc)));
    assert_eq!(unsafe {
                   &(*(0 as *const nzttPersonaDesc)).aliaslen_nzttPersonaDesc as *const _ as usize
               },
               32usize,
               concat!("Alignment of field: ",
                       stringify!(nzttPersonaDesc),
                       "::",
                       stringify!(aliaslen_nzttPersonaDesc)));
    assert_eq!(unsafe {
                   &(*(0 as *const nzttPersonaDesc)).alias_nzttPersonaDesc as *const _ as usize
               },
               40usize,
               concat!("Alignment of field: ",
                       stringify!(nzttPersonaDesc),
                       "::",
                       stringify!(alias_nzttPersonaDesc)));
    assert_eq!(unsafe {
                   &(*(0 as *const nzttPersonaDesc)).longlen_nzttPersonaDesc as *const _ as usize
               },
               48usize,
               concat!("Alignment of field: ",
                       stringify!(nzttPersonaDesc),
                       "::",
                       stringify!(longlen_nzttPersonaDesc)));
    assert_eq!(unsafe {
                   &(*(0 as *const nzttPersonaDesc)).long_nzttPersonaDesc as *const _ as usize
               },
               56usize,
               concat!("Alignment of field: ",
                       stringify!(nzttPersonaDesc),
                       "::",
                       stringify!(long_nzttPersonaDesc)));
}
impl Clone for nzttPersonaDesc {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nzttIdentityDesc {
    pub publen_nzttIdentityDesc: ub4,
    pub pub_nzttIdentityDesc: *mut ub1,
    pub dnlen_nzttIdentityDesc: ub4,
    pub dn_nzttIdentityDesc: *mut text,
    pub longlen_nzttIdentityDesc: ub4,
    pub long_nzttIdentityDesc: *mut text,
    pub quallen_nzttIdentityDesc: ub4,
    pub trustqual_nzttIdentityDesc: *mut text,
}
#[test]
fn bindgen_test_layout_nzttIdentityDesc() {
    assert_eq!(::std::mem::size_of::<nzttIdentityDesc>(),
               64usize,
               concat!("Size of: ", stringify!(nzttIdentityDesc)));
    assert_eq!(::std::mem::align_of::<nzttIdentityDesc>(),
               8usize,
               concat!("Alignment of ", stringify!(nzttIdentityDesc)));
    assert_eq!(unsafe {
                   &(*(0 as *const nzttIdentityDesc)).publen_nzttIdentityDesc as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(nzttIdentityDesc),
                       "::",
                       stringify!(publen_nzttIdentityDesc)));
    assert_eq!(unsafe {
                   &(*(0 as *const nzttIdentityDesc)).pub_nzttIdentityDesc as *const _ as usize
               },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(nzttIdentityDesc),
                       "::",
                       stringify!(pub_nzttIdentityDesc)));
    assert_eq!(unsafe {
                   &(*(0 as *const nzttIdentityDesc)).dnlen_nzttIdentityDesc as *const _ as usize
               },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(nzttIdentityDesc),
                       "::",
                       stringify!(dnlen_nzttIdentityDesc)));
    assert_eq!(unsafe {
                   &(*(0 as *const nzttIdentityDesc)).dn_nzttIdentityDesc as *const _ as usize
               },
               24usize,
               concat!("Alignment of field: ",
                       stringify!(nzttIdentityDesc),
                       "::",
                       stringify!(dn_nzttIdentityDesc)));
    assert_eq!(unsafe {
                   &(*(0 as *const nzttIdentityDesc)).longlen_nzttIdentityDesc as *const _ as usize
               },
               32usize,
               concat!("Alignment of field: ",
                       stringify!(nzttIdentityDesc),
                       "::",
                       stringify!(longlen_nzttIdentityDesc)));
    assert_eq!(unsafe {
                   &(*(0 as *const nzttIdentityDesc)).long_nzttIdentityDesc as *const _ as usize
               },
               40usize,
               concat!("Alignment of field: ",
                       stringify!(nzttIdentityDesc),
                       "::",
                       stringify!(long_nzttIdentityDesc)));
    assert_eq!(unsafe {
                   &(*(0 as *const nzttIdentityDesc)).quallen_nzttIdentityDesc as *const _ as usize
               },
               48usize,
               concat!("Alignment of field: ",
                       stringify!(nzttIdentityDesc),
                       "::",
                       stringify!(quallen_nzttIdentityDesc)));
    assert_eq!(unsafe {
                   &(*(0 as *const nzttIdentityDesc)).trustqual_nzttIdentityDesc as *const _ as
                   usize
               },
               56usize,
               concat!("Alignment of field: ",
                       stringify!(nzttIdentityDesc),
                       "::",
                       stringify!(trustqual_nzttIdentityDesc)));
}
impl Clone for nzttIdentityDesc {
    fn clone(&self) -> Self {
        *self
    }
}
extern "C" {
    pub fn nztwOpenWallet(arg1: *mut nzctx,
                          arg2: ub4,
                          arg3: *mut text,
                          arg4: ub4,
                          arg5: *mut text,
                          arg6: *mut nzttWallet)
                          -> nzerror;
}
extern "C" {
    pub fn nztwCloseWallet(arg1: *mut nzctx, arg2: *mut nzttWallet) -> nzerror;
}
extern "C" {
    /// NOTE: This function is a temporary hack.****/
    /// /****DO NOT CALL.  It will soon disappear.
    pub fn nztwGetCertInfo(nz_context: *mut nzctx,
                           nzosCtx: *mut nzosContext,
                           walletRef: *mut nzttWallet,
                           peerCert: *mut ::std::os::raw::c_void)
                           -> nzerror;
}
extern "C" {
    pub fn nztwRetrievePersonaCopy(arg1: *mut nzctx,
                                   arg2: *mut nzttWallet,
                                   arg3: ub4,
                                   arg4: *mut *mut nzttPersona)
                                   -> nzerror;
}
extern "C" {
    pub fn nztwRetrievePersonaCopyByName(arg1: *mut nzctx,
                                         arg2: *mut nzttWallet,
                                         arg3: *mut ::std::os::raw::c_char,
                                         arg4: *mut *mut nzttPersona)
                                         -> nzerror;
}
extern "C" {
    pub fn nzteOpenPersona(arg1: *mut nzctx, arg2: *mut nzttPersona) -> nzerror;
}
extern "C" {
    pub fn nzteClosePersona(arg1: *mut nzctx, arg2: *mut nzttPersona) -> nzerror;
}
extern "C" {
    pub fn nzteDestroyPersona(arg1: *mut nzctx, arg2: *mut *mut nzttPersona) -> nzerror;
}
extern "C" {
    pub fn nzteRetrieveTrustedIdentCopy(arg1: *mut nzctx,
                                        arg2: *mut nzttPersona,
                                        arg3: ub4,
                                        arg4: *mut *mut nzttIdentity)
                                        -> nzerror;
}
extern "C" {
    pub fn nztePriKey(arg1: *mut nzctx,
                      arg2: *mut nzttPersona,
                      arg3: *mut *mut ub1,
                      arg4: *mut ub4)
                      -> nzerror;
}
extern "C" {
    pub fn nzteMyCert(arg1: *mut nzctx,
                      arg2: *mut nzttPersona,
                      arg3: *mut *mut ub1,
                      arg4: *mut ub4)
                      -> nzerror;
}
extern "C" {
    pub fn nzteX509CreatePersona(arg1: *mut nzctx,
                                 arg2: *mut ub1,
                                 arg3: ub4,
                                 arg4: *mut *mut nzttPersona)
                                 -> nzerror;
}
extern "C" {
    pub fn nztiCreateIdentity(arg1: *mut nzctx,
                              arg2: nzttVersion,
                              arg3: *mut nzttIdentityDesc,
                              arg4: *mut *mut nzttIdentity)
                              -> nzerror;
}
extern "C" {
    pub fn nztiAbortIdentity(arg1: *mut nzctx, arg2: *mut *mut nzttIdentity) -> nzerror;
}
extern "C" {
    pub fn nztific_FreeIdentityContent(ossctx: *mut nzctx, identity: *mut nzttIdentity) -> nzerror;
}
extern "C" {
    pub fn nztSign(arg1: *mut nzctx,
                   arg2: *mut nzttPersona,
                   arg3: nzttces,
                   arg4: ub4,
                   arg5: *mut ub1,
                   arg6: *mut nzttBufferBlock)
                   -> nzerror;
}
extern "C" {
    pub fn nztVerify(arg1: *mut nzctx,
                     arg2: *mut nzttPersona,
                     arg3: nzttces,
                     arg4: ub4,
                     arg5: *mut ub1,
                     arg6: *mut nzttBufferBlock,
                     arg7: *mut boolean,
                     arg8: *mut boolean,
                     arg9: *mut *mut nzttIdentity)
                     -> nzerror;
}
extern "C" {
    pub fn nztValidate(arg1: *mut nzctx,
                       arg2: *mut nzttPersona,
                       arg3: *mut nzttIdentity,
                       arg4: *mut boolean)
                       -> nzerror;
}
extern "C" {
    pub fn nztsd_SignDetached(arg1: *mut nzctx,
                              arg2: *mut nzttPersona,
                              arg3: nzttces,
                              arg4: ub4,
                              arg5: *mut ub1,
                              arg6: *mut nzttBufferBlock)
                              -> nzerror;
}
extern "C" {
    pub fn nztved_VerifyDetached(arg1: *mut nzctx,
                                 arg2: *mut nzttPersona,
                                 arg3: nzttces,
                                 arg4: ub4,
                                 arg5: *mut ub1,
                                 arg6: ub4,
                                 arg7: *mut ub1,
                                 arg8: *mut boolean,
                                 arg9: *mut boolean,
                                 arg10: *mut *mut nzttIdentity)
                                 -> nzerror;
}
extern "C" {
    pub fn nztkec_PKEncrypt(arg1: *mut nzctx,
                            arg2: *mut nzttPersona,
                            arg3: ub4,
                            arg4: *mut nzttIdentity,
                            arg5: nzttces,
                            arg6: ub4,
                            arg7: *mut ub1,
                            arg8: *mut nzttBufferBlock)
                            -> nzerror;
}
extern "C" {
    pub fn nztxkec_PKEncryptExpansion(arg1: *mut nzctx,
                                      arg2: *mut nzttPersona,
                                      arg3: ub4,
                                      arg4: ub4,
                                      arg5: *mut ub4)
                                      -> nzerror;
}
extern "C" {
    pub fn nztkdc_PKDecrypt(arg1: *mut nzctx,
                            arg2: *mut nzttPersona,
                            arg3: nzttces,
                            arg4: ub4,
                            arg5: *mut ub1,
                            arg6: *mut nzttBufferBlock)
                            -> nzerror;
}
extern "C" {
    pub fn nztHash(arg1: *mut nzctx,
                   arg2: *mut nzttPersona,
                   arg3: nzttces,
                   arg4: ub4,
                   arg5: *mut ub1,
                   arg6: *mut nzttBufferBlock)
                   -> nzerror;
}
extern "C" {
    pub fn nztSeedRandom(arg1: *mut nzctx,
                         arg2: *mut nzttPersona,
                         arg3: ub4,
                         arg4: *mut ub1)
                         -> nzerror;
}
extern "C" {
    pub fn nztrb_RandomBytes(arg1: *mut nzctx,
                             arg2: *mut nzttPersona,
                             arg3: ub4,
                             arg4: *mut nzttBufferBlock)
                             -> nzerror;
}
extern "C" {
    pub fn nztrn_RandomNumber(arg1: *mut nzctx,
                              arg2: *mut nzttPersona,
                              arg3: *mut uword)
                              -> nzerror;
}
extern "C" {
    pub fn nztbbInitBlock(arg1: *mut nzctx, arg2: *mut nzttBufferBlock) -> nzerror;
}
extern "C" {
    pub fn nztbbReuseBlock(arg1: *mut nzctx, arg2: *mut nzttBufferBlock) -> nzerror;
}
extern "C" {
    pub fn nztbbSizeBlock(arg1: *mut nzctx, arg2: ub4, arg3: *mut nzttBufferBlock) -> nzerror;
}
extern "C" {
    pub fn nztbbGrowBlock(arg1: *mut nzctx, arg2: ub4, arg3: *mut nzttBufferBlock) -> nzerror;
}
extern "C" {
    pub fn nztbbPurgeBlock(arg1: *mut nzctx, arg2: *mut nzttBufferBlock) -> nzerror;
}
extern "C" {
    pub fn nztbbSetBlock(arg1: *mut nzctx,
                         arg2: uword,
                         arg3: ub4,
                         arg4: ub4,
                         arg5: *mut ub1,
                         arg6: *mut nzttBufferBlock)
                         -> nzerror;
}
extern "C" {
    pub fn nztiGetSecInfo(arg1: *mut nzctx,
                          arg2: *mut nzttPersona,
                          arg3: *mut *mut text,
                          arg4: *mut ub4,
                          arg5: *mut *mut text,
                          arg6: *mut ub4,
                          arg7: *mut *mut ub1,
                          arg8: *mut ub4)
                          -> nzerror;
}
extern "C" {
    pub fn nztiGetDName(arg1: *mut nzctx,
                        arg2: *mut nzttIdentity,
                        arg3: *mut *mut text,
                        arg4: *mut ub4)
                        -> nzerror;
}
extern "C" {
    pub fn nztiGetIssuerName(arg1: *mut nzctx,
                             arg2: *mut nzttIdentity,
                             arg3: *mut *mut text,
                             arg4: *mut ub4)
                             -> nzerror;
}
extern "C" {
    pub fn nztgch_GetCertHash(arg1: *mut nzctx,
                              arg2: *mut nzttIdentity,
                              arg3: *mut *mut ub1,
                              arg4: *mut ub4)
                              -> nzerror;
}
extern "C" {
    pub fn nztdbuf_DestroyBuf(arg1: *mut nzctx, arg2: *mut *mut ::std::os::raw::c_void) -> nzerror;
}
extern "C" {
    pub fn nztGetCertChain(arg1: *mut nzctx, arg2: *mut nzttWallet) -> nzerror;
}
extern "C" {
    pub fn nztCompareDN(arg1: *mut nzctx,
                        arg2: *mut ub1,
                        arg3: ub4,
                        arg4: *mut ub1,
                        arg5: ub4,
                        arg6: *mut boolean)
                        -> nzerror;
}
extern "C" {
    pub fn nztCheckValidity(arg1: *mut nzctx, arg2: ub4, arg3: ub4) -> nzerror;
}
extern "C" {
    pub fn nztwCreateWallet(arg1: *mut nzctx,
                            arg2: ub4,
                            arg3: *mut text,
                            arg4: ub4,
                            arg5: *mut text,
                            arg6: *mut nzttWallet)
                            -> nzerror;
}
extern "C" {
    pub fn nztwDestroyWallet(arg1: *mut nzctx,
                             arg2: ub4,
                             arg3: *mut text,
                             arg4: ub4,
                             arg5: *mut text)
                             -> nzerror;
}
extern "C" {
    pub fn nzteStorePersona(arg1: *mut nzctx,
                            arg2: *mut *mut nzttPersona,
                            arg3: *mut nzttWallet)
                            -> nzerror;
}
extern "C" {
    pub fn nzteRemovePersona(arg1: *mut nzctx, arg2: *mut *mut nzttPersona) -> nzerror;
}
extern "C" {
    pub fn nzteCreatePersona(arg1: *mut nzctx,
                             arg2: nzttVersion,
                             arg3: nzttCipherType,
                             arg4: *mut nzttPersonaDesc,
                             arg5: *mut *mut nzttPersona)
                             -> nzerror;
}
extern "C" {
    pub fn nztiStoreTrustedIdentity(arg1: *mut nzctx,
                                    arg2: *mut *mut nzttIdentity,
                                    arg3: *mut nzttPersona)
                                    -> nzerror;
}
extern "C" {
    pub fn nzteSetProtection(arg1: *mut nzctx,
                             arg2: *mut nzttPersona,
                             arg3: nzttcef,
                             arg4: nztttdufmt,
                             arg5: *mut nzttProtInfo)
                             -> nzerror;
}
extern "C" {
    pub fn nzteGetProtection(arg1: *mut nzctx,
                             arg2: *mut nzttPersona,
                             arg3: nzttcef,
                             arg4: *mut nztttdufmt,
                             arg5: *mut nzttProtInfo)
                             -> nzerror;
}
extern "C" {
    pub fn nztiRemoveIdentity(arg1: *mut nzctx, arg2: *mut *mut nzttIdentity) -> nzerror;
}
extern "C" {
    pub fn nztifdn(ossctx: *mut nzctx,
                   length: ub4,
                   distinguished_name: *mut text,
                   ppidentity: *mut *mut nzttIdentity)
                   -> nzerror;
}
extern "C" {
    pub fn nztxSignExpansion(arg1: *mut nzctx,
                             arg2: *mut nzttPersona,
                             arg3: ub4,
                             arg4: *mut ub4)
                             -> nzerror;
}
extern "C" {
    pub fn nztxsd_SignDetachedExpansion(arg1: *mut nzctx,
                                        arg2: *mut nzttPersona,
                                        arg3: ub4,
                                        arg4: *mut ub4)
                                        -> nzerror;
}
extern "C" {
    pub fn nztEncrypt(arg1: *mut nzctx,
                      arg2: *mut nzttPersona,
                      arg3: nzttces,
                      arg4: ub4,
                      arg5: *mut ub1,
                      arg6: *mut nzttBufferBlock)
                      -> nzerror;
}
extern "C" {
    pub fn nztxEncryptExpansion(arg1: *mut nzctx,
                                arg2: *mut nzttPersona,
                                arg3: ub4,
                                arg4: *mut ub4)
                                -> nzerror;
}
extern "C" {
    pub fn nztDecrypt(arg1: *mut nzctx,
                      arg2: *mut nzttPersona,
                      arg3: nzttces,
                      arg4: ub4,
                      arg5: *mut ub1,
                      arg6: *mut nzttBufferBlock)
                      -> nzerror;
}
extern "C" {
    pub fn nztEnvelope(arg1: *mut nzctx,
                       arg2: *mut nzttPersona,
                       arg3: ub4,
                       arg4: *mut nzttIdentity,
                       arg5: nzttces,
                       arg6: ub4,
                       arg7: *mut ub1,
                       arg8: *mut nzttBufferBlock)
                       -> nzerror;
}
extern "C" {
    pub fn nztDeEnvelope(arg1: *mut nzctx,
                         arg2: *mut nzttPersona,
                         arg3: nzttces,
                         arg4: ub4,
                         arg5: *mut ub1,
                         arg6: *mut nzttBufferBlock,
                         arg7: *mut boolean,
                         arg8: *mut boolean,
                         arg9: *mut *mut nzttIdentity)
                         -> nzerror;
}
extern "C" {
    pub fn nztKeyedHash(arg1: *mut nzctx,
                        arg2: *mut nzttPersona,
                        arg3: nzttces,
                        arg4: ub4,
                        arg5: *mut ub1,
                        arg6: *mut nzttBufferBlock)
                        -> nzerror;
}
extern "C" {
    pub fn nztxKeyedHashExpansion(arg1: *mut nzctx,
                                  arg2: *mut nzttPersona,
                                  arg3: ub4,
                                  arg4: *mut ub4)
                                  -> nzerror;
}
extern "C" {
    pub fn nztxHashExpansion(arg1: *mut nzctx,
                             arg2: *mut nzttPersona,
                             arg3: ub4,
                             arg4: *mut ub4)
                             -> nzerror;
}
extern "C" {
    pub fn nztiae_IsAuthEnabled(ctx: *mut nzctx,
                                ncipher: ub2,
                                authEnabled: *mut boolean)
                                -> nzerror;
}
extern "C" {
    pub fn nztiee_IsEncrEnabled(ctx: *mut nzctx,
                                ncipher: ub2,
                                EncrEnabled: *mut boolean)
                                -> nzerror;
}
extern "C" {
    pub fn nztihe_IsHashEnabled(ctx: *mut nzctx,
                                ncipher: ub2,
                                hashEnabled: *mut boolean)
                                -> nzerror;
}
extern "C" {
    pub fn nztGetIssuerName(ctx: *mut nzctx,
                            identity: *mut nzttIdentity,
                            issuername: *mut *mut ub1,
                            issuernamelen: *mut ub4)
                            -> nzerror;
}
extern "C" {
    pub fn nztGetSubjectName(ctx: *mut nzctx,
                             identity: *mut nzttIdentity,
                             subjectname: *mut *mut ub1,
                             subjectnamelen: *mut ub4)
                             -> nzerror;
}
extern "C" {
    pub fn nztGetBase64Cert(ctx: *mut nzctx,
                            identity: *mut nzttIdentity,
                            b64cert: *mut *mut ub1,
                            b64certlen: *mut ub4)
                            -> nzerror;
}
extern "C" {
    pub fn nztGetSerialNumber(ctx: *mut nzctx,
                              identity: *mut nzttIdentity,
                              serialnum: *mut *mut ub1,
                              serialnumlen: *mut ub4)
                              -> nzerror;
}
extern "C" {
    pub fn nztGetValidDate(ctx: *mut nzctx,
                           identity: *mut nzttIdentity,
                           startdate: *mut ub4,
                           enddate: *mut ub4)
                           -> nzerror;
}
extern "C" {
    pub fn nztGetVersion(ctx: *mut nzctx,
                         identity: *mut nzttIdentity,
                         pVerStr: *mut nzstrc)
                         -> nzerror;
}
extern "C" {
    pub fn nztGetPublicKey(ctx: *mut nzctx,
                           identity: *mut nzttIdentity,
                           pubKey: *mut *mut ub1,
                           pubKeylen: *mut ub4)
                           -> nzerror;
}
extern "C" {
    pub fn nztGenericDestroy(ctx: *mut nzctx, var: *mut *mut ub1) -> nzerror;
}
extern "C" {
    pub fn nztSetAppDefaultLocation(ctx: *mut nzctx, arg1: *mut text, arg2: usize) -> nzerror;
}
extern "C" {
    pub fn nztSearchNZDefault(ctx: *mut nzctx, search: *mut boolean) -> nzerror;
}
extern "C" {
    pub fn nztSetLightWeight(ctx: *mut nzctx, flag: boolean) -> nzerror;
}
/// DESCRIPTION
///
/// Note: the descriptions of the functions are alphabetically arranged. Please
/// maintain the arrangement when adding a new function description. The actual
/// prototypes are below this comment section and donot follow any alphabetical
/// ordering.
///
///
/// --------------------------------OCIAttrGet------------------------------------
///
/// OCIAttrGet()
/// Name
/// OCI Attribute Get
/// Purpose
/// This call is used to get a particular attribute of a handle.
/// Syntax
/// sword OCIAttrGet ( const void    *trgthndlp,
/// ub4            trghndltyp,
/// void          *attributep,
/// ub4            *sizep,
/// ub4            attrtype,
/// OCIError       *errhp );
/// Comments
/// This call is used to get a particular attribute of a handle.
/// See Appendix B,  "Handle Attributes",  for a list of handle types and their
/// readable attributes.
/// Parameters
/// trgthndlp (IN) - is the pointer to a handle type.
/// trghndltyp (IN) - is the handle type.
/// attributep (OUT) - is a pointer to the storage for an attribute value. The
/// attribute value is filled in.
/// sizep (OUT) - is the size of the attribute value.
/// This can be passed in as NULL for most parameters as the size is well known.
/// For text* parameters, a pointer to a ub4 must be passed in to get the length
/// of the string.
/// attrtype (IN) - is the type of attribute.
/// errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
/// diagnostic information in the event of an error.
/// Related Functions
/// OCIAttrSet()
///
/// --------------------------------OCIAttrSet------------------------------------
///
///
/// OCIAttrSet()
/// Name
/// OCI Attribute Set
/// Purpose
/// This call is used to set a particular attribute of a handle or a descriptor.
/// Syntax
/// sword OCIAttrSet ( void       *trgthndlp,
/// ub4         trghndltyp,
/// void       *attributep,
/// ub4         size,
/// ub4         attrtype,
/// OCIError    *errhp );
/// Comments
/// This call is used to set a particular attribute of a handle or a descriptor.
/// See Appendix B for a list of handle types and their writeable attributes.
/// Parameters
/// trghndlp (IN/OUT) - the pointer to a handle type whose attribute gets
/// modified.
/// trghndltyp (IN/OUT) - is the handle type.
/// attributep (IN) - a pointer to an attribute value.
/// The attribute value is copied into the target handle. If the attribute value
/// is a pointer, then only the pointer is copied, not the contents of the pointer.
/// size (IN) - is the size of an attribute value. This can be passed in as 0 for
/// most attributes as the size is already known by the OCI library. For text*
/// attributes, a ub4 must be passed in set to the length of the string.
/// attrtype (IN) - the type of attribute being set.
/// errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
/// diagnostic information in the event of an error.
/// Related Functions
/// OCIAttrGet()
///
///
///
/// --------------------------------OCIBindArrayOfStruct--------------------------
///
///
///
/// OCIBindArrayOfStruct()
/// Name
/// OCI Bind for Array of Structures
/// Purpose
/// This call sets up the skip parameters for a static array bind.
/// Syntax
/// sword OCIBindArrayOfStruct ( OCIBind     *bindp,
/// OCIError    *errhp,
/// ub4         pvskip,
/// ub4         indskip,
/// ub4         alskip,
/// ub4         rcskip );
/// Comments
/// This call sets up the skip parameters necessary for a static array bind.
/// This call follows a call to OCIBindByName() or OCIBindByPos(). The bind
/// handle returned by that initial bind call is used as a parameter for the
/// OCIBindArrayOfStruct() call.
/// For information about skip parameters, see the section "Arrays of Structures"
/// on page 4-16.
/// Parameters
/// bindp (IN) - the handle to a bind structure.
/// errhp (IN) - an error handle which can be passed to OCIErrorGet() for
/// diagnostic information in the event of an error.
/// pvskip (IN) - skip parameter for the next data value.
/// indskip (IN) - skip parameter for the next indicator value or structure.
/// alskip (IN) - skip parameter for the next actual length value.
/// rcskip (IN) - skip parameter for the next column-level return code value.
/// Related Functions
/// OCIAttrGet()
///
///
/// --------------------------------OCIBindByName---------------------------------
///
/// OCIBindByName()
/// Name
/// OCI Bind by Name
/// Purpose
/// Creates an association between a program variable and a placeholder in a SQL
/// statement or PL/SQL block.
/// Syntax
/// sword OCIBindByName (
/// OCIStmt       *stmtp,
/// OCIBind       **bindp,
/// OCIError      *errhp,
/// const OraText    *placeholder,
/// sb4           placeh_len,
/// void         *valuep,
/// sb4           value_sz,
/// ub2           dty,
/// void         *indp,
/// ub2           *alenp,
/// ub2           *rcodep,
/// ub4           maxarr_len,
/// ub4           *curelep,
/// ub4           mode );
/// Description
/// This call is used to perform a basic bind operation. The bind creates an
/// association between the address of a program variable and a placeholder in a
/// SQL statement or PL/SQL block. The bind call also specifies the type of data
/// which is being bound, and may also indicate the method by which data will be
/// provided at runtime.
/// This function also implicitly allocates the bind handle indicated by the bindp
/// parameter.
/// Data in an OCI application can be bound to placeholders statically or
/// dynamically. Binding is static when all the IN bind data and the OUT bind
/// buffers are well-defined just before the execute. Binding is dynamic when the
/// IN bind data and the OUT bind buffers are provided by the application on
/// demand at execute time to the client library. Dynamic binding is indicated by
/// setting the mode parameter of this call to OCI_DATA_AT_EXEC.
/// Related Functions: For more information about dynamic binding, see
/// the section "Runtime Data Allocation and Piecewise Operations" on
/// page 5-16.
/// Both OCIBindByName() and OCIBindByPos() take as a parameter a bind handle,
/// which is implicitly allocated by the bind call A separate bind handle is
/// allocated for each placeholder the application is binding.
/// Additional bind calls may be required to specify particular attributes
/// necessary when binding certain data types or handling input data in certain
/// ways:
/// If arrays of structures are being utilized, OCIBindArrayOfStruct() must
/// be called to set up the necessary skip parameters.
/// If data is being provided dynamically at runtime, and the application
/// will be using user-defined callback functions, OCIBindDynamic() must
/// be called to register the callbacks.
/// If a named data type is being bound, OCIBindObject() must be called to
/// specify additional necessary information.
/// Parameters
/// stmth (IN/OUT) - the statement handle to the SQL or PL/SQL statement
/// being processed.
/// bindp (IN/OUT) - a pointer to a pointer to a bind handle which is implicitly
/// allocated by this call.  The bind handle  maintains all the bind information
/// for this particular input value. The handle is feed implicitly when the
/// statement handle is deallocated.
/// errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
/// diagnostic information in the event of an error.
/// placeholder (IN) - the placeholder attributes are specified by name if
/// ocibindn() is being called.
/// placeh_len (IN) - the length of the placeholder name specified in placeholder.
/// valuep (IN/OUT) - a pointer to a data value or an array of data values of the
/// type specified in the dty parameter. An array of data values can be specified
/// for mapping into a PL/SQL table or for providing data for SQL multiple-row
/// operations. When an array of bind values is provided, this is called an array
/// bind in OCI terms. Additional attributes of the array bind (not bind to a
/// column of ARRAY type) are set up in OCIBindArrayOfStruct() call.
/// For a REF, named data type  bind, the valuep parameter is used only for IN
/// bind data. The pointers to OUT buffers are set in the pgvpp parameter
/// initialized by OCIBindObject(). For named data type and REF binds, the bind
/// values are unpickled into the Object Cache. The OCI object navigational calls
/// can then be used to navigate the objects and the refs in the Object Cache.
/// If the OCI_DATA_AT_EXEC mode is specified in the mode parameter, valuep
/// is ignored for all data types. OCIBindArrayOfStruct() cannot be used and
/// OCIBindDynamic() must be invoked to provide callback functions if desired.
/// value_sz (IN) - the size of a data value. In the case of an array bind, this is
/// the maximum size of any element possible with the actual sizes being specified
/// in the alenp parameter.
/// If the OCI_DATA_AT_EXEC mode is specified, valuesz defines the maximum
/// size of the data that can be ever provided at runtime for data types other than
/// named data types or REFs.
/// dty (IN) - the data type of the value(s) being bound. Named data types
/// (SQLT_NTY) and REFs (SQLT_REF) are valid only if the application has been
/// initialized in object mode. For named data types, or REFs, additional calls
/// must be made with the bind handle to set up the datatype-specific attributes.
/// indp (IN/OUT) - pointer to an indicator variable or array. For scalar data
/// types, this is a pointer to sb2 or an array of sb2s. For named data types,
/// this pointer is ignored and the actual pointer to the indicator structure or
/// an array of indicator structures is initialized by OCIBindObject().
/// Ignored for dynamic binds.
/// See the section "Indicator Variables" on page 2-43 for more information about
/// indicator variables.
/// alenp (IN/OUT) - pointer to array of actual lengths of array elements. Each
/// element in alenp is the length of the data in the corresponding element in the
/// bind value array before and after the execute. This parameter is ignored for
/// dynamic binds.
/// rcodep (OUT) - pointer to array of column level return codes. This parameter
/// is ignored for dynamic binds.
/// maxarr_len (IN) - the maximum possible number of elements of type dty in a
/// PL/SQL binds. This parameter is not required for non-PL/SQL binds. If
/// maxarr_len is non-zero, then either OCIBindDynamic() or
/// OCIBindArrayOfStruct() can be invoked to set up additional bind attributes.
/// curelep(IN/OUT) - a pointer to the actual number of elements. This parameter
/// is only required for PL/SQL binds.
/// mode (IN) - the valid modes for this parameter are:
/// OCI_DEFAULT. This is default mode.
/// OCI_DATA_AT_EXEC. When this mode is selected, the value_sz
/// parameter defines the maximum size of the data that can be ever
/// provided at runtime. The application must be ready to provide the OCI
/// library runtime IN data buffers at any time and any number of times.
/// Runtime data is provided in one of the two ways:
/// callbacks using a user-defined function which must be registered
/// with a subsequent call to OCIBindDynamic().
/// a polling mechanism using calls supplied by the OCI. This mode
/// is assumed if no callbacks are defined.
/// For more information about using the OCI_DATA_AT_EXEC mode, see
/// the section "Runtime Data Allocation and Piecewise Operations" on
/// page 5-16.
/// When the allocated buffers are not required any more, they should be
/// freed by the client.
/// Related Functions
/// OCIBindDynamic(), OCIBindObject(), OCIBindArrayOfStruct(), OCIAttrGet()
///
///
///
/// -------------------------------OCIBindByPos-----------------------------------
///
///
/// OCIBindByPos()
/// Name
/// OCI Bind by Position
/// Purpose
/// Creates an association between a program variable and a placeholder in a SQL
/// statement or PL/SQL block.
/// Syntax
/// sword OCIBindByPos (
/// OCIStmt      *stmtp,
/// OCIBind      **bindp,
/// OCIError     *errhp,
/// ub4          position,
/// void        *valuep,
/// sb4          value_sz,
/// ub2          dty,
/// void        *indp,
/// ub2          *alenp,
/// ub2          *rcodep,
/// ub4          maxarr_len,
/// ub4          *curelep,
/// ub4          mode);
///
/// Description
/// This call is used to perform a basic bind operation. The bind creates an
/// association between the address of a program variable and a placeholder in a
/// SQL statement or PL/SQL block. The bind call also specifies the type of data
/// which is being bound, and may also indicate the method by which data will be
/// provided at runtime.
/// This function also implicitly allocates the bind handle indicated by the bindp
/// parameter.
/// Data in an OCI application can be bound to placeholders statically or
/// dynamically. Binding is static when all the IN bind data and the OUT bind
/// buffers are well-defined just before the execute. Binding is dynamic when the
/// IN bind data and the OUT bind buffers are provided by the application on
/// demand at execute time to the client library. Dynamic binding is indicated by
/// setting the mode parameter of this call to OCI_DATA_AT_EXEC.
/// Related Functions: For more information about dynamic binding, see
/// the section "Runtime Data Allocation and Piecewise Operations" on
/// page 5-16
/// Both OCIBindByName() and OCIBindByPos() take as a parameter a bind handle,
/// which is implicitly allocated by the bind call A separate bind handle is
/// allocated for each placeholder the application is binding.
/// Additional bind calls may be required to specify particular attributes
/// necessary when binding certain data types or handling input data in certain
/// ways:
/// If arrays of structures are being utilized, OCIBindArrayOfStruct() must
/// be called to set up the necessary skip parameters.
/// If data is being provided dynamically at runtime, and the application
/// will be using user-defined callback functions, OCIBindDynamic() must
/// be called to register the callbacks.
/// If a named data type is being bound, OCIBindObject() must be called to
/// specify additional necessary information.
/// Parameters
/// stmth (IN/OUT) - the statement handle to the SQL or PL/SQL statement
/// being processed.
/// bindp (IN/OUT) - a pointer to a pointer to a bind handle which is implicitly
/// allocated by this call.  The bind handle  maintains all the bind information
/// for this particular input value. The handle is feed implicitly when the
/// statement handle is deallocated.
/// errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
/// diagnostic information in the event of an error.
/// position (IN) - the placeholder attributes are specified by position if
/// ocibindp() is being called.
/// valuep (IN/OUT) - a pointer to a data value or an array of data values of the
/// type specified in the dty parameter. An array of data values can be specified
/// for mapping into a PL/SQL table or for providing data for SQL multiple-row
/// operations. When an array of bind values is provided, this is called an array
/// bind in OCI terms. Additional attributes of the array bind (not bind to a
/// column of ARRAY type) are set up in OCIBindArrayOfStruct() call.
/// For a REF, named data type  bind, the valuep parameter is used only for IN
/// bind data. The pointers to OUT buffers are set in the pgvpp parameter
/// initialized by OCIBindObject(). For named data type and REF binds, the bind
/// values are unpickled into the Object Cache. The OCI object navigational calls
/// can then be used to navigate the objects and the refs in the Object Cache.
/// If the OCI_DATA_AT_EXEC mode is specified in the mode parameter, valuep
/// is ignored for all data types. OCIBindArrayOfStruct() cannot be used and
/// OCIBindDynamic() must be invoked to provide callback functions if desired.
/// value_sz (IN) - the size of a data value. In the case of an array bind, this is
/// the maximum size of any element possible with the actual sizes being specified
/// in the alenp parameter.
/// If the OCI_DATA_AT_EXEC mode is specified, valuesz defines the maximum
/// size of the data that can be ever provided at runtime for data types other than
/// named data types or REFs.
/// dty (IN) - the data type of the value(s) being bound. Named data types
/// (SQLT_NTY) and REFs (SQLT_REF) are valid only if the application has been
/// initialized in object mode. For named data types, or REFs, additional calls
/// must be made with the bind handle to set up the datatype-specific attributes.
/// indp (IN/OUT) - pointer to an indicator variable or array. For scalar data
/// types, this is a pointer to sb2 or an array of sb2s. For named data types,
/// this pointer is ignored and the actual pointer to the indicator structure or
/// an array of indicator structures is initialized by OCIBindObject(). Ignored
/// for dynamic binds.
/// See the section "Indicator Variables" on page 2-43 for more information about
/// indicator variables.
/// alenp (IN/OUT) - pointer to array of actual lengths of array elements. Each
/// element in alenp is the length of the data in the corresponding element in the
/// bind value array before and after the execute. This parameter is ignored for
/// dynamic binds.
/// rcodep (OUT) - pointer to array of column level return codes. This parameter
/// is ignored for dynamic binds.
/// maxarr_len (IN) - the maximum possible number of elements of type dty in a
/// PL/SQL binds. This parameter is not required for non-PL/SQL binds. If
/// maxarr_len is non-zero, then either OCIBindDynamic() or
/// OCIBindArrayOfStruct() can be invoked to set up additional bind attributes.
/// curelep(IN/OUT) - a pointer to the actual number of elements. This parameter
/// is only required for PL/SQL binds.
/// mode (IN) - the valid modes for this parameter are:
/// OCI_DEFAULT. This is default mode.
/// OCI_DATA_AT_EXEC. When this mode is selected, the value_sz
/// parameter defines the maximum size of the data that can be ever
/// provided at runtime. The application must be ready to provide the OCI
/// library runtime IN data buffers at any time and any number of times.
/// Runtime data is provided in one of the two ways:
/// callbacks using a user-defined function which must be registered
/// with a subsequent call to OCIBindDynamic() .
/// a polling mechanism using calls supplied by the OCI. This mode
/// is assumed if no callbacks are defined.
/// For more information about using the OCI_DATA_AT_EXEC mode, see
/// the section "Runtime Data Allocation and Piecewise Operations" on
/// page 5-16.
/// When the allocated buffers are not required any more, they should be
/// freed by the client.
/// Related Functions
/// OCIBindDynamic(), OCIBindObject(), OCIBindArrayOfStruct(), OCIAttrGet()
///
///
///
/// -------------------------------OCIBindDynamic---------------------------------
///
/// OCIBindDynamic()
/// Name
/// OCI Bind Dynamic Attributes
/// Purpose
/// This call is used to register user callbacks for dynamic data allocation.
/// Syntax
/// sword OCIBindDynamic( OCIBind     *bindp,
/// OCIError    *errhp,
/// void       *ictxp,
/// OCICallbackInBind         (icbfp)(
/// void            *ictxp,
/// OCIBind          *bindp,
/// ub4              iter,
/// ub4              index,
/// void            **bufpp,
/// ub4              *alenp,
/// ub1              *piecep,
/// void            **indp ),
/// void       *octxp,
/// OCICallbackOutBind         (ocbfp)(
/// void            *octxp,
/// OCIBind          *bindp,
/// ub4              iter,
/// ub4              index,
/// void            **bufp,
/// ub4              **alenpp,
/// ub1              *piecep,
/// void            **indpp,
/// ub2              **rcodepp)   );
/// Comments
/// This call is used to register user-defined callback functions for providing
/// data for an UPDATE or INSERT if OCI_DATA_AT_EXEC mode was specified in a
/// previous call to OCIBindByName() or OCIBindByPos().
/// The callback function pointers must return OCI_CONTINUE if it the call is
/// successful. Any return code other than OCI_CONTINUE signals that the client
/// wishes to abort processing immediately.
/// For more information about the OCI_DATA_AT_EXEC mode, see the section
/// "Runtime Data Allocation and Piecewise Operations" on page 5-16.
/// Parameters
/// bindp (IN/OUT) - a bind handle returned by a call to OCIBindByName() or
/// OCIBindByPos().
/// errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
/// diagnostic information in the event of an error.
/// ictxp (IN) - the context pointer required by the call back function icbfp.
/// icbfp (IN) - the callback function which returns a pointer to the IN bind
/// value or piece at run time. The callback takes in the following parameters.
/// ictxp (IN/OUT) - the context pointer for this callback function.
/// bindp (IN) - the bind handle passed in to uniquely identify this bind
/// variable.
/// iter (IN) - 1-based execute iteration value.
/// index (IN) - index of the current array, for an array bind. 1 based not
/// greater than curele parameter of the bind call.
/// index (IN) - index of the current array, for an array bind. This parameter
/// is 1-based, and may not be greater than curele parameter of the bind call.
/// bufpp (OUT) - the pointer to the buffer.
/// piecep (OUT) - which piece of the bind value. This can be one of the
/// following values - OCI_ONE_PIECE, OCI_FIRST_PIECE,
/// OCI_NEXT_PIECE and OCI_LAST_PIECE.
/// indp (OUT) - contains the indicator value. This is apointer to either an
/// sb2 value or a pointer to an indicator structure for binding named data
/// types.
/// indszp (OUT) - contains the indicator value size. A pointer containing
/// the size of either an sb2 or an indicator structure pointer.
/// octxp (IN) - the context pointer required by the callback function ocbfp.
/// ocbfp (IN) - the callback function which returns a pointer to the OUT bind
/// value or piece at run time. The callback takes in the following parameters.
/// octxp (IN/OUT) - the context pointer for this call back function.
/// bindp (IN) - the bind handle passed in to uniquely identify this bind
/// variable.
/// iter (IN) - 1-based execute iteration value.
/// index (IN) - index of the current array, for an array bind. This parameter
/// is 1-based, and must not be greater than curele parameter of the bind call.
/// bufpp (OUT) - a pointer to a buffer to write the bind value/piece.
/// buflp (OUT) - returns the buffer size.
/// alenpp (OUT) - a pointer to a storage for OCI to fill in the size of the bind
/// value/piece after it has been read.
/// piecep (IN/OUT) - which piece of the bind value. It will be set by the
/// library to be one of the following values - OCI_ONE_PIECE or
/// OCI_NEXT_PIECE. The callback function can leave it unchanged or set
/// it to OCI_FIRST_PIECE or OCI_LAST_PIECE. By default -
/// OCI_ONE_PIECE.
/// indpp (OUT) - returns a pointer to contain the indicator value which
/// either an sb2 value or a pointer to an indicator structure for named data
/// types.
/// indszpp (OUT) - returns a pointer to return the size of the indicator
/// value which is either size of an sb2 or size of an indicator structure.
/// rcodepp (OUT) - returns a pointer to contains the return code.
/// Related Functions
/// OCIAttrGet()
///
///
/// ---------------------------------OCIBindObject--------------------------------
///
///
/// OCIBindObject()
/// Name
/// OCI Bind Object
/// Purpose
/// This function sets up additional attributes which are required for a named
/// data type (object)  bind.
/// Syntax
/// sword OCIBindObject ( OCIBind          *bindp,
/// OCIError         *errhp,
/// const OCIType    *type,
/// void            **pgvpp,
/// ub4              *pvszsp,
/// void            **indpp,
/// ub4              *indszp, );
/// Comments
/// This function sets up additional attributes which binding a named data type
/// or a REF. An error will be returned if this function is called when the OCI
/// environment has been initialized in non-object mode.
/// This call takes as a paramter a type descriptor object (TDO) of datatype
/// OCIType for the named data type being defined.  The TDO can be retrieved
/// with a call to OCITypeByName().
/// If the OCI_DATA_AT_EXEC mode was specified in ocibindn() or ocibindp(), the
/// pointers to the IN buffers are obtained either using the callback icbfp
/// registered in the OCIBindDynamic() call or by the OCIStmtSetPieceInfo() call.
/// The buffers are dynamically allocated for the OUT data and the pointers to
/// these buffers are returned either by calling ocbfp() registered by the
/// OCIBindDynamic() or by setting the pointer to the buffer in the buffer passed
/// in by OCIStmtSetPieceInfo() called when OCIStmtExecute() returned
/// OCI_NEED_DATA. The memory of these client library- allocated buffers must be
/// freed when not in use anymore by using the OCIObjectFreee() call.
/// Parameters
/// bindp ( IN/OUT) - the bind handle returned by the call to OCIBindByName()
/// or OCIBindByPos().
/// errhp ( IN/OUT) - an error handle which can be passed to OCIErrorGet() for
/// diagnostic information in the event of an error.
/// type ( IN) - points to the TDO which describes the type of the program
/// variable being bound. Retrieved by calling OCITypeByName().
/// pgvpp ( IN/OUT) - points to a pointer to the program variable buffer. For an
/// array, pgvpp points to an array of pointers. When the bind variable is also an
/// OUT variable, the OUT Named Data Type value or REF is allocated
/// (unpickled) in the Object Cache, and a pointer to the value or REF is returned,
/// At the end of execute, when all OUT values have been received, pgvpp points
/// to an array of pointer(s) to these newly allocated named data types in the
/// object cache.
/// pgvpp is ignored if the OCI_DATA_AT_EXEC mode is set. Then the Named
/// Data Type buffers are requested at runtime. For static array binds, skip
/// factors may be specified using the OCIBindArrayOfStruct() call. The skip
/// factors are used to compute the address of the next pointer to the value, the
/// indicator structure and their sizes.
/// pvszsp ( IN/OUT) - points to the size of the program variable. The size of the
/// named data type is not required on input. For an array, pvszsp is an array of
/// ub4s. On return, for OUT bind variables, this points to size(s) of the Named
/// Data Types and REFs received. pvszsp is ignored if the OCI_DATA_AT_EXEC
/// mode is set. Then the size of the buffer is taken at runtime.
/// indpp ( IN/OUT) - points to a pointer to the program variable buffer
/// containing the parallel indicator structure. For an array, points to an array
/// of pointers. When the bind variable is also an OUT bind variable, memory is
/// allocated in the object cache, to store the unpickled OUT indicator values. At
/// the end of the execute when all OUT values have been received, indpp points
/// to the pointer(s) to these newly allocated indicator structure(s).
/// indpp is ignored if the OCI_DATA_AT_EXEC mode is set. Then the indicator
/// is requested at runtime.
/// indszp ( IN/OUT) - points to the size of the IN indicator structure program
/// variable. For an array, it is an array of sb2s. On return for OUT bind
/// variables, this points to size(s) of the received OUT indicator structures.
/// indszp is ignored if the OCI_DATA_AT_EXEC mode is set. Then the indicator
/// size is requested at runtime.
/// Related Functions
/// OCIAttrGet()
///
///
///
/// ----------------------------------OCIBreak------------------------------------
///
///
/// OCIBreak()
/// Name
/// OCI Break
/// Purpose
/// This call performs an immediate (asynchronous) abort of any currently
/// executing OCI function that is associated with a server .
/// Syntax
/// sword OCIBreak ( void      *hndlp,
/// OCIError   *errhp);
/// Comments
/// This call performs an immediate (asynchronous) abort of any currently
/// executing OCI function that is associated with a server. It is normally used
/// to stop a long-running OCI call being processed on the server.
/// This call can take either the service context handle or the server context
/// handle as a parameter to identify the function to be aborted.
/// Parameters
/// hndlp (IN) - the service context handle or the server context handle.
/// errhp (IN) - an error handle which can be passed to OCIErrorGet() for
/// diagnostic information in the event of an error.
/// Related Functions
///
/// -----------------------------OCIConnectionPoolCreate --------------------------
/// Name:
/// OCIConnectionPoolCreate
///
/// Purpose:
/// Creates the connections in the pool
///
/// Syntax:
/// OCIConnectionPoolCreate (OCIEnv *envhp, OCIError *errhp, OCICPool *poolhp,
/// OraText **poolName, sb4 *poolNameLen,
/// const Oratext *dblink, sb4 dblinkLen,
/// ub4 connMin, ub4 connMax, ub4 connIncr,
/// const OraText *poolUsername, sb4 poolUserLen,
/// const OraText *poolPassword, sb4 poolPassLen,
/// ub4 mode)
/// Comments:
/// This call is used to create a connection pool. conn_min connections
/// to the database are started on calling OCIConnectionPoolCreate.
///
/// Parameters:
/// envhp (IN/OUT)  - A pointer to the environment where the Conencton Pool
/// is to be created
/// errhp (IN/OUT)  - An error handle which can be passed to OCIErrorGet().
/// poolhp (IN/OUT) - An uninitialiazed pool handle.
/// poolName (OUT) - The connection pool name.
/// poolNameLen (OUT) - The length of the connection pool name
/// dblink (IN/OUT) - Specifies the database(server) to connect. This will also
/// be used as the default pool name.
/// dblinkLen (IN)  - The length of the string pointed to by dblink.
/// connMin (IN)    - Specifies the minimum number of connections in the
/// Connection Pool at any instant.
/// connMin number of connections are started when
/// OCIConnectionPoolCreate() is called.
/// connMax (IN)    - Specifies the maximum number of connections that can be
/// opened to the database. Once this value is reached, no
/// more connections are opened.
/// connIncr (IN)   - Allows application to set the next increment for
/// connections to be opened to the database if the current
/// number of connections are less than conn_max.
/// poolUsername (IN/OUT) - Connection pooling requires an implicit proxy
/// session and this attribute provides a username
/// for that session.
/// poolUserLen (IN) - This represents the length of pool_username.
/// poolPassword (IN/OUT) - The password for the parameter pool_username passed
/// above.
/// poolPassLen (IN) - This represents the length of pool_password.
///
/// mode (IN) - The modes supported are OCI_DEFAULT and
/// OCI_CPOOL_REINITIALIZE
///
/// Related Functions
/// OCIConnectionPoolDestroy()
///
/// ---------------------------------------------------------------------------
///
/// ----------------------------OCIConnectionPoolDestroy-------------------------
/// Name:
/// OCIConnectionPoolDestroy
///
/// Purpose:
/// Terminates the connections in the pool
///
/// Syntax:
/// OCIConnectionPoolDestroy (OCICPool *poolhp, OCIError *errhp, ub4 mode)
///
/// Comments:
/// On calling OCIConnectionPoolDestroy, all the open connections in the pool
/// are closed and the pool is destroyed.
///
/// Parameters:
/// poolhp (IN/OUT) - An initialiazed pool handle.
/// errhp (IN/OUT)  - An error handle which can be passed to OCIErrorGet().
/// mode (IN)       - Currently, OCIConnectionPoolDestroy() will support only
/// the OCI_DEFAULT mode.
///
/// Related Functions:
/// OCIConnectionPoolCreate()
///
/// -----------------------------------------------------------------------------
/// ----------------------------OCISessionPoolCreate-----------------------------
/// Name:
/// OCISessionPoolCreate
///
/// Purpose:
/// Creates the sessions in the session pool.
///
/// Syntax:
/// sword OCISessionPoolCreate (OCIEnv *envhp, OCIError *errhp, OCISpool *spoolhp,
/// OraText **poolName, ub4 *poolNameLen,
/// const OraText *connStr, ub4 connStrLen,
/// ub4 sessMin, ub4 sessMax, ub4 sessIncr,
/// OraText *userid,  ub4 useridLen,
/// OraText *password, ub4 passwordLen,
/// ub4 mode)
///
/// Comments:
/// When OCISessionPoolCreate is called, a session pool is initialized for
/// the associated environment and the database specified by the
/// connStr parameter. This pool is named uniquely and the name
/// is returned to the user in the poolname parameter.
///
/// Parameters:
/// envhp (IN/OUT) - A pointer to the environment handle in which the session
/// pool needs to be created.
/// errhp (IN/OUT) - An error handle which can be passed to OCIErrorGet().
/// spoolhp (IN/OUT) - A pointer to the session pool handle that is created.
/// poolName (OUT) - Session pool name returned to the user.
/// poolNameLen (OUT) - Length of the PoolName
/// connStr (IN) - The TNS alias of the database to connect to.
/// connStrLen (IN) - Length of the connStr.
/// sessMin (IN) - Specifies the minimum number of sessions in the Session Pool.
/// These are the number of sessions opened in the beginning, if
/// in Homogeneous mode. Else, the parameter is ignored.
/// sessMax (IN) - Specifies the maximum number of sessions in the Session Pool.
/// Once this value is reached, no more sessions are opened,
/// unless the OCI_ATTR_SPOOL_FORCEGET is set.
/// userid (IN) - Specifies the userid with which to start up the sessions.
/// useridLen (IN) - Length of userid.
/// password (IN) - Specifies the password for the corresponding userid.
/// passwordLen (IN) - Specifies the length of the password
/// mode(IN) - May be OCI_DEFAULT, OCI_SPC_SPOOL_REINITIALIZE, or
/// OCI_SPC_SPOOL_HOMOGENEOUS.
///
/// Returns:
/// SUCCESS - If pool could be allocated and created successfully.
/// ERROR - If above conditions could not be met.
///
/// Related Functions:
/// OCISessionPoolDestroy()
/// -----------------------------------------------------------------------------
/// -----------------------------OCISessionPoolDestroy---------------------------
/// Name:
/// OCISessionPoolDestroy
///
/// Purpose:
/// Terminates all the sessions in the session pool.
///
/// Syntax:
/// sword OCISessionPoolDestroy (OCISPool *spoolhp, OCIError *errhp, ub4 mode)
///
/// Comments:
/// spoolhp (IN/OUT) - The pool handle of the session pool to be destroyed.
/// errhp (IN/OUT) - An error handle which can be passed to OCIErrorGet().
/// mode (IN) - Currently only OCI_DEFAULT mode is supported.
///
/// Returns:
/// SUCCESS - All the sessions could be closed.
/// ERROR - If the above condition is not met.
///
/// Related Functions:
/// OCISessionPoolCreate()
/// -----------------------------------------------------------------------------
/// -------------------------------OCISessionGet---------------------------------
/// Name:
/// OCISessionGet
///
/// Purpose:
/// Get a session. This could be from a session pool, connection pool or
/// a new standalone session.
///
/// Syntax:
/// sword OCISessionGet(OCIenv *envhp, OCIError *errhp, OCISvcCtx **svchp,
/// OCIAuthInfo *authhp,
/// OraText *poolName, ub4 poolName_len,
/// const OraText *tagInfo, ub4 tagInfo_len,
/// OraText **retTagInfo, ub4 *retTagInfo_len,
/// boolean *found,
/// ub4 mode)
///
/// Comments:
/// envhp (IN/OUT) - OCI environment handle.
/// errhp (IN/OUT) - OCI error handle to be passed to OCIErrorGet().
/// svchp (IN/OUT) - Address of an OCI service context pointer. This will be
/// filled with a server and session handle, attached to the
/// pool.
/// authhp (IN/OUT) - OCI Authentication Information handle.
/// poolName (IN) - This indicates the session/connection pool to get the
/// session/connection from in the OCI_SPOOL/OCI_CPOOL mode.
/// In the OCI_DEFAULT mode it refers to the connect string.
/// poolName_len (IN) - length of poolName.
/// tagInfo (IN) - indicates the tag of the session that the user wants. If the
/// user wants a default session, he must specify a NULL here.
/// Only used for Session Pooling.
/// tagInfo_len (IN) - the length of tagInfo.
/// retTagInfo (OUT) - This indicates the type of session that is returned to
/// the user. Only used for Session Pooling.
/// retTagInfo_len (OUT) - the length of retTagInfo.
/// found (OUT) - set to true if the user gets a session he had requested, else
/// set to false. Only used for Session Pooling.
/// mode (IN) - The supported modes are OCI_DEFAULT, OCI_CRED_PROXY and
/// OCI_GET_SPOOL_MATCHANY, OCI_SPOOL and OCI_CPOOL. OCI_SPOOL and
/// OCI_CPOOL are mutually exclusive.
///
/// Returns:
/// SUCCESS -  if a session was successfully returned into svchp.
/// SUCCESS_WITH_INFO - if a session was successfully returned into svchp and the
/// total number of sessions > maxsessions. Only valid for
/// Session Pooling.
/// ERROR - If a session could not be retrieved.
///
/// Related Functions:
/// OCISessionRelease()
/// -----------------------------------------------------------------------------
/// ---------------------------OCISessionRelease---------------------------------
/// Name:
/// OCISessionRelease
///
/// Purpose:
/// Release the session.
///
/// Syntax:
/// sword OCISessionRelease ( OCISvcCtx *svchp, OCIError *errhp,
/// OraText *tag, ub4 tag_len,
/// ub4 mode);
///
/// Comments:
/// svchp (IN/OUT) - The service context associated with the session/connection.
/// errhp (IN/OUT) - OCI error handle to be passed to OCIErrorGet().
/// tag (IN) - Only used for Session Pooling.
/// This parameter will be ignored unless mode OCI_RLS_SPOOL_RETAG is
/// specified. In this case, the session is labelled with this tag and
/// returned to the pool. If this is NULL, then the session is untagged.
/// tag_len (IN) - Length of the tag. This is ignored unless mode
/// OCI_RLS_SPOOL_RETAG is set.
/// mode (IN) - The supported modes are OCI_DEFAULT, OCI_RLS_SPOOL_DROPSESS,
/// OCI_RLS_SPOOL_RETAG. The last 2 are only valid for Session Pooling.
/// When OCI_RLS_SPOOL_DROPSESS is specified, the session
/// will be removed from the session pool. If OCI_RLS_SPOOL_RETAG
/// is set, the tag on the session will be altered. If this mode is
/// not set, the tag and tag_len parameters will be ignored.
///
/// Returns:
/// ERROR - If the session could not be released successfully.
/// SUCCESS - In all other cases.
///
/// Related Functions:
/// OCISessionGet().
/// -----------------------------------------------------------------------------
/// ------------------------------OCIDateTimeAssign --------------------------
/// sword OCIDateTimeAssign(void *hndl, OCIError *err, const OCIDateTime *from,
/// OCIDateTime *to);
/// NAME: OCIDateTimeAssign - OCIDateTime Assignment
/// PARAMETERS:
/// hndl (IN) - Session/Env handle.
/// err (IN/OUT) - error handle. If there is an error, it is
/// recorded in 'err' and this function returns OCI_ERROR.
/// The error recorded in 'err' can be retrieved by calling
/// OCIErrorGet().
/// from (IN) - datetime to be assigned
/// to (OUT) - lhs of assignment
/// DESCRIPTION:
/// Performs date assignment. The type of the output will be same as that
/// of input
///
/// ------------------------------OCIDateTimeCheck----------------------------
/// sword OCIDateTimeCheck(void *hndl, OCIError *err, const OCIDateTime *date,
/// ub4 *valid );
/// NAME: OCIDateTimeCheck - OCIDateTime CHecK if the given date is valid
/// PARAMETERS:
/// hndl (IN) - Session/Env handle.
/// err (IN/OUT) - error handle. If there is an error, it is
/// recorded in 'err' and this function returns OCI_ERROR.
/// The error recorded in 'err' can be retrieved by calling
/// OCIErrorGet().
/// date (IN) - date to be checked
/// valid (OUT) -  returns zero for a valid date, otherwise
/// the ORed combination of all error bits specified below:
/// Macro name                   Bit number      Error
/// ----------                   ----------      -----
/// OCI_DATE_INVALID_DAY         0x1             Bad day
/// OCI_DATE_DAY_BELOW_VALID     0x2             Bad DAy Low/high bit (1=low)
/// OCI_DATE_INVALID_MONTH       0x4             Bad MOnth
/// OCI_DATE_MONTH_BELOW_VALID   0x8             Bad MOnth Low/high bit (1=low)
/// OCI_DATE_INVALID_YEAR        0x10            Bad YeaR
/// OCI_DATE_YEAR_BELOW_VALID    0x20            Bad YeaR Low/high bit (1=low)
/// OCI_DATE_INVALID_HOUR        0x40            Bad HouR
/// OCI_DATE_HOUR_BELOW_VALID    0x80            Bad HouR Low/high bit (1=low)
/// OCI_DATE_INVALID_MINUTE      0x100           Bad MiNute
/// OCI_DATE_MINUTE_BELOW_VALID  0x200           Bad MiNute Low/high bit (1=low)
/// OCI_DATE_INVALID_SECOND      0x400           Bad SeCond
/// OCI_DATE_SECOND_BELOW_VALID  0x800           bad second Low/high bit (1=low)
/// OCI_DATE_DAY_MISSING_FROM_1582 0x1000        Day is one of those "missing"
/// from 1582
/// OCI_DATE_YEAR_ZERO           0x2000          Year may not equal zero
/// OCI_DATE_INVALID_TIMEZONE    0x4000          Bad Timezone
/// OCI_DATE_INVALID_FORMAT      0x8000          Bad date format input
///
/// So, for example, if the date passed in was 2/0/1990 25:61:10 in
/// (month/day/year hours:minutes:seconds format), the error returned
/// would be OCI_DATE_INVALID_DAY | OCI_DATE_DAY_BELOW_VALID |
/// OCI_DATE_INVALID_HOUR | OCI_DATE_INVALID_MINUTE
///
/// DESCRIPTION:
/// Check if the given date is valid.
/// RETURNS:
/// OCI_SUCCESS if the function completes successfully.
/// OCI_INVALID_HANDLE if 'err' is NULL.
/// OCI_ERROR if
/// 'date' and 'valid' pointers are NULL pointers
///
/// ------------------------------- OCIDateTimeCompare----------------------------
/// sword OCIDateTimeCompare(void *hndl, OCIError *err, const OCIDateTime *date1,
/// const OCIDateTime *date2,  sword *result );
/// NAME: OCIDateTimeCompare - OCIDateTime CoMPare dates
/// PARAMETERS:
/// hndl (IN) - Session/Env handle.
/// err (IN/OUT) - error handle. If there is an error, it is
/// recorded in 'err' and this function returns OCI_ERROR.
/// The error recorded in 'err' can be retrieved by calling
/// OCIErrorGet().
/// date1, date2 (IN) - dates to be compared
/// result (OUT) - comparison result, 0 if equal, -1 if date1 < date2,
/// 1 if date1 > date2
/// DESCRIPTION:
/// The function OCIDateCompare compares two dates. It returns -1 if
/// date1 is smaller than date2, 0 if they are equal, and 1 if date1 is
/// greater than date2.
/// RETURNS:
/// OCI_SUCCESS if the function completes successfully.
/// OCI_INVALID_HANDLE if 'err' is NULL.
/// OCI_ERROR if
/// invalid date
/// input dates are not mutually comparable
///
/// ------------------------------OCIDateTimeConvert----------------------
/// sword OCIDateTimeConvert(void *hndl, OCIError *err, OCIDateTime *indate,
/// OCIDateTime *outdate);
/// NAME: OCIDateTimeConvert - Conversion between different DATETIME types
/// PARAMETERS:
/// hndl (IN) - Session/Env handle.
/// err (IN/OUT) - error handle. If there is an error, it is
/// recorded in 'err' and this function returns OCI_ERROR.
/// The error recorded in 'err' can be retrieved by calling
/// OCIErrorGet().
/// indate (IN) - pointer to input date
/// outdate (OUT) - pointer to output datetime
/// DESCRIPTION: Converts one datetime type to another. The result type is
/// the type of the 'outdate' descriptor.
/// RETURNS:
/// OCI_SUCCESS if the function completes successfully.
/// OCI_INVALID_HANDLE if 'err' is NULL.
/// OCI_ERROR if
/// conversion not possible.
///
/// ---------------------------- OCIDateTimeFromText-----------------------
/// sword OCIDateTimeFromText(void *hndl, OCIError *err, const OraText *date_str,
/// size_t d_str_length, const OraText *fmt, ub1 fmt_length,
/// const OraText *lang_name, size_t lang_length, OCIDateTime *date );
/// NAME: OCIDateTimeFromText - OCIDateTime convert String FROM Date
/// PARAMETERS:
/// hndl (IN) - Session/Env handle. If Session Handle is passed, the
/// conversion takes place in session NLS_LANGUAGE and
/// session NLS_CALENDAR, otherwise the default is used.
/// err (IN/OUT) - error handle. If there is an error, it is
/// recorded in 'err' and this function returns OCI_ERROR.
/// The error recorded in 'err' can be retrieved by calling
/// OCIErrorGet().
/// date_str (IN) - input string to be converted to Oracle date
/// d_str_length (IN) - size of the input string, if the length is -1
/// then 'date_str' is treated as a null terminated  string
/// fmt (IN) - conversion format; if 'fmt' is a null pointer, then
/// the string is expected to be in the default format for
/// the datetime type.
/// fmt_length (IN) - length of the 'fmt' parameter
/// lang_name (IN) - language in which the names and abbreviations of
/// days and months are specified, if null i.e. (OraText *)0,
/// the default language of session is used,
/// lang_length (IN) - length of the 'lang_name' parameter
/// date (OUT) - given string converted to date
/// DESCRIPTION:
/// Converts the given string to Oracle datetime type set in the
/// OCIDateTime descriptor according to the specified format. Refer to
/// "TO_DATE" conversion function described in "Oracle SQL Language
/// Reference Manual" for a description of format.
/// RETURNS:
/// OCI_SUCCESS if the function completes successfully.
/// OCI_INVALID_HANDLE if 'err' is NULL.
/// OCI_ERROR if
/// invalid format
/// unknown language
/// invalid input string
///
/// --------------------------- OCIDateTimeGetDate-------------------------
/// sword OCIDateTimeGetDate(void *hndl, OCIError *err,  const OCIDateTime *date,
/// sb2 *year, ub1 *month, ub1 *day );
/// NAME: OCIDateTimeGetDate - OCIDateTime Get Date (year, month, day)
/// portion of DATETIME.
/// PARAMETERS:
/// hndl (IN) - Session/Env handle.
/// err (IN/OUT) - error handle. If there is an error, it is
/// recorded in 'err' and this function returns OCI_ERROR.
/// The error recorded in 'err' can be retrieved by calling
/// OCIErrorGet().
/// datetime (IN) - Pointer to OCIDateTime
/// year      (OUT) - year value
/// month     (OUT) - month value
/// day       (OUT) - day value
///
/// --------------------------- OCIDateTimeGetTime ------------------------
/// sword OCIDateTimeGetTime(void *hndl, OCIError *err, OCIDateTime *datetime,
/// ub1 *hour, ub1 *minute, ub1 *sec, ub4 *fsec);
/// NAME: OCIDateTimeGetTime - OCIDateTime Get Time (hour, min, second,
/// fractional second)  of DATETIME.
/// PARAMETERS:
/// hndl (IN) - Session/Env handle.
/// err (IN/OUT) - error handle. If there is an error, it is
/// recorded in 'err' and this function returns OCI_ERROR.
/// The error recorded in 'err' can be retrieved by calling
/// OCIErrorGet().
/// datetime (IN) - Pointer to OCIDateTime
/// hour      (OUT) - hour value
/// minute       (OUT) - minute value
/// sec       (OUT) - second value
/// fsec      (OUT) - Fractional Second value
///
/// --------------------------- OCIDateTimeGetTimeZoneOffset ----------------------
/// sword OCIDateTimeGetTimeZoneOffset(void *hndl,OCIError *err,const
/// OCIDateTime *datetime,sb1 *hour,sb1  *minute);
///
/// NAME: OCIDateTimeGetTimeZoneOffset - OCIDateTime Get TimeZone (hour, minute)
/// portion of DATETIME.
/// PARAMETERS:
/// hndl (IN) - Session/Env handle.
/// err (IN/OUT) - error handle. If there is an error, it is
/// recorded in 'err' and this function returns OCI_ERROR.
/// The error recorded in 'err' can be retrieved by calling
/// OCIErrorGet().
/// datetime (IN) - Pointer to OCIDateTime
/// hour      (OUT) - TimeZone Hour value
/// minute     (OUT) - TimeZone Minute value
///
/// --------------------------- OCIDateTimeSysTimeStamp---------------------
/// sword OCIDateTimeSysTimeStamp(void *hndl, OCIError *err,
/// OCIDateTime *sys_date );
///
/// NAME: OCIDateTimeSysTimeStamp - Returns system date/time as a TimeStamp with
/// timezone
/// PARAMETERS:
/// hndl (IN) - Session/Env handle.
/// err (IN/OUT) - error handle. If there is an error, it is
/// recorded in 'err' and this function returns OCI_ERROR.
/// The error recorded in 'err' can be retrieved by calling
/// OCIErrorGet().
/// sys_date (OUT) - Pointer to output timestamp
///
/// DESCRIPTION:
/// Gets the system current date and time as a timestamp with timezone
/// RETURNS:
/// OCI_SUCCESS if the function completes successfully.
/// OCI_INVALID_HANDLE if 'err' is NULL.
///
///
/// ------------------------------OCIDateTimeIntervalAdd----------------------
/// sword OCIDateTimeIntervalAdd(void *hndl, OCIError *err, OCIDateTime *datetime,
/// OCIInterval *inter, OCIDateTime *outdatetime);
/// NAME: OCIDateTimeIntervalAdd - Adds an interval to datetime
/// PARAMETERS:
/// hndl (IN) - Session/Env handle.
/// err (IN/OUT) - error handle. If there is an error, it is
/// recorded in 'err' and this function returns OCI_ERROR.
/// The error recorded in 'err' can be retrieved by calling
/// OCIErrorGet().
/// datetime (IN) - pointer to input datetime
/// inter    (IN) - pointer to interval
/// outdatetime (IN) - pointer to output datetime. The output datetime
/// will be of same type as input datetime
/// DESCRIPTION:
/// Adds an interval to a datetime to produce a resulting datetime
/// RETURNS:
/// OCI_SUCCESS if the function completes successfully.
/// OCI_INVALID_HANDLE if 'err' is NULL.
/// OCI_ERROR if:
/// resulting date is before Jan 1, -4713
/// resulting date is after Dec 31, 9999
///
/// ------------------------------OCIDateTimeIntervalSub----------------------
/// sword OCIDateTimeIntervalSub(void *hndl, OCIError *err, OCIDateTime *datetime,
/// OCIInterval *inter, OCIDateTime *outdatetime);
/// NAME: OCIDateTimeIntervalSub - Subtracts an interval from a datetime
/// PARAMETERS:
/// hndl (IN) - Session/Env handle.
/// err (IN/OUT) - error handle. If there is an error, it is
/// recorded in 'err' and this function returns OCI_ERROR.
/// The error recorded in 'err' can be retrieved by calling
/// OCIErrorGet().
/// datetime (IN) - pointer to input datetime
/// inter    (IN) - pointer to interval
/// outdatetime (IN) - pointer to output datetime. The output datetime
/// will be of same type as input datetime
/// DESCRIPTION:
/// Subtracts an interval from a datetime and stores the result in a
/// datetime
/// RETURNS:
/// OCI_SUCCESS if the function completes successfully.
/// OCI_INVALID_HANDLE if 'err' is NULL.
/// OCI_ERROR if:
/// resulting date is before Jan 1, -4713
/// resulting date is after Dec 31, 9999
///
/// --------------------------- OCIDateTimeConstruct-------------------------
/// sword OCIDateTimeConstruct(void  *hndl,OCIError *err,OCIDateTime *datetime,
/// sb2 year,ub1 month,ub1 day,ub1 hour,ub1 min,ub1 sec,ub4 fsec,
/// OraText  *timezone,size_t timezone_length);
///
/// NAME: OCIDateTimeConstruct - Construct an OCIDateTime. Only the relevant
/// fields for the OCIDateTime descriptor types are used.
/// PARAMETERS:
/// hndl (IN) - Session/Env handle.
/// err (IN/OUT) - error handle. If there is an error, it is
/// recorded in 'err' and this function returns OCI_ERROR.
/// The error recorded in 'err' can be retrieved by calling
/// OCIErrorGet().
/// datetime (IN) - Pointer to OCIDateTime
/// year      (IN) - year value
/// month     (IN) - month value
/// day       (IN) - day value
/// hour      (IN) - hour value
/// min       (IN) - minute value
/// sec       (IN) - second value
/// fsec      (IN) - Fractional Second value
/// timezone  (IN) - Timezone string
/// timezone_length(IN) - Length of timezone string
///
/// DESCRIPTION:
/// Constructs a DateTime descriptor. The type of the datetime is the
/// type of the OCIDateTime descriptor. Only the relevant fields based
/// on the type are used. For Types with timezone, the date and time
/// fields are assumed to be in the local time of the specified timezone.
/// If timezone is not specified, then session default timezone is
/// assumed.
/// RETURNS:
/// OCI_SUCCESS if the function completes successfully.
/// OCI_ERROR if datetime is not valid.
///
/// ------------------------------OCIDateTimeSubtract-----------------------
/// sword OCIDateTimeSubtract(void *hndl, OCIError *err, OCIDateTime *indate1,
/// OCIDateTime *indate2, OCIInterval *inter);
/// NAME: OCIDateTimeSubtract - subtracts two datetimes to return an interval
/// PARAMETERS:
/// hndl (IN) - Session/Env handle.
/// err (IN/OUT) - error handle. If there is an error, it is
/// recorded in 'err' and this function returns OCI_ERROR.
/// The error recorded in 'err' can be retrieved by calling
/// OCIErrorGet().
/// indate1(IN) - pointer to subtrahend
/// indate2(IN) - pointer to minuend
/// inter  (OUT) - pointer to output interval
/// DESCRIPTION:
/// Takes two datetimes as input and stores their difference in an
/// interval. The type of the interval is the type of the 'inter'
/// descriptor.
/// RETURNS:
/// OCI_SUCCESS if the function completes successfully.
/// OCI_INVALID_HANDLE if 'err' is NULL.
/// OCI_ERROR if
/// datetimes are not comparable.
///
/// --------------------------- OCIDateTimeToText--------------------------
/// sword OCIDateTimeToText(void *hndl, OCIError *err, const OCIDateTime *date,
/// const OraText *fmt, ub1 fmt_length, ub1 fsprec,
/// const OraText *lang_name, size_t lang_length,
/// ub4 *buf_size, OraText *buf );
/// NAME: OCIDateTimeToText - OCIDateTime convert date TO String
/// PARAMETERS:
/// hndl (IN) - Session/Env handle. If Session Handle is passed, the
/// conversion takes place in session NLS_LANGUAGE and
/// session NLS_CALENDAR, otherwise the default is used.
/// err (IN/OUT) - error handle. If there is an error, it is
/// recorded in 'err' and this function returns OCI_ERROR.
/// The error recorded in 'err' can be retrieved by calling
/// OCIErrorGet().
/// date (IN) - Oracle datetime to be converted
/// fmt (IN) - conversion format, if null string pointer (OraText*)0, then
/// the date is converted to a character string in the
/// default format for that type.
/// fmt_length (IN) - length of the 'fmt' parameter
/// fsprec (IN) - specifies the fractional second precision in which the
/// fractional seconds is returned.
/// lang_name (IN) - specifies the language in which the names and
/// abbreviations of months and days are returned;
/// default language of session is used if 'lang_name'
/// is null i.e. (OraText *)0
/// lang_length (IN) - length of the 'nls_params' parameter
/// buf_size (IN/OUT) - size of the buffer; size of the resulting string
/// is returned via this parameter
/// buf (OUT) - buffer into which the converted string is placed
/// DESCRIPTION:
/// Converts the given date to a string according to the specified format.
/// Refer to "TO_DATE" conversion function described in
/// "Oracle SQL Language Reference Manual" for a description of format
/// and NLS arguments. The converted null-terminated date string is
/// stored in the buffer 'buf'.
/// RETURNS:
/// OCI_SUCCESS if the function completes successfully.
/// OCI_INVALID_HANDLE if 'err' is NULL.
/// OCI_ERROR if
/// buffer too small
/// invalid format
/// unknown language
/// overflow error
///
/// ----------------------------OCIDateTimeGetTimeZoneName------------------------
/// sword OCIDateTimeGetTimeZoneName(void *hndl,
/// OCIError *err,
/// const OCIDateTime *datetime,
/// ub1 *buf,
/// ub4 *buflen);
/// NAME OCIDateTimeGetTimeZoneName - OCI DateTime Get the Time Zone Name
/// PARAMETERS:
/// hndl (IN)      - Session/Env handle.
/// err (IN/OUT)   - error handle. If there is an error, it is
/// recorded in 'err' and this function returns OCI_ERROR.
/// The error recorded in 'err' can be retrieved by calling
/// OCIErrorGet().
/// datetime (IN)   - Pointer to an OCIDateTime.
/// buf (OUT)       - User allocated storage for name string.
/// buflen (IN/OUT) - length of buf on input, length of name on out
/// DESCRIPTION:
/// Returns either the timezone region name or the absolute hour and minute
/// offset. If the DateTime was created with a region id then the region
/// name will be returned in the buf.  If the region id is zero, then the
/// hour and minute offset is returned as "[-]HH:MM".
/// RETURNS:
/// OCI_SUCCESS if the function completes successfully.
/// OCI_INVALID_HANDLE if 'err' is NULL.
/// OCI_ERROR if
/// buffer too small
/// error retrieving timezone data
/// invalid region
/// invalid LdiDateTime type
///
/// ---------------------------------OCIDateTimeToArray----------------------------
/// sword OCIDateTimeToArray(void *hndl,
/// OCIError *err,
/// const OCIDateTime *datetime,
/// const OCIInterval *reftz,
/// ub1 *outarray,
/// ub4 *len
/// ub1 *fsprec);
/// NAME OCIDateTimeToArray - OCI DateTime convert To Array format
/// PARAMETERS:
/// hndl (IN)      - Session/Env handle.
/// err (IN/OUT)   - error handle. If there is an error, it is
/// recorded in 'err' and this function returns OCI_ERROR.
/// The error recorded in 'err' can be retrieved by calling
/// OCIErrorGet().
/// datetime (IN)   - Pointer to OCIDateTime to be converted.
/// outarray (OUT)  - Result array storage
/// len (OUT)        - pointer to  length of outarray.
/// fsprec (IN)     - Number of fractional seconds digits.
/// DESCRIPTION:
/// Returns an array representing the input DateTime descriptor.
/// RETURNS:
/// OCI_SUCCESS if the function completes successfully.
/// OCI_INVALID_HANDLE if 'err' is NULL.
/// OCI_ERROR if
/// buffer too small
/// error retrieving timezone data
/// invalid region
/// invalid LdiDateTime type
///
/// --------------------------------OCIDateTimeFromArray---------------------------
/// sword OCIDateTimeFromArray(void *hndl,
/// OCIError *err,
/// ub1 *inarray,
/// ub4 len
/// ub1 type
/// OCIDateTime *datetime,
/// OCIInterval *reftz,
/// ub1 fsprec);
/// NAME OCIDateTimeFromArray - OCI DateTime convert From Array format
/// PARAMETERS:
/// hndl (IN)      - Session/Env handle.
/// err (IN/OUT)   - error handle. If there is an error, it is
/// recorded in 'err' and this function returns OCI_ERROR.
/// The error recorded in 'err' can be retrieved by calling
/// OCIErrorGet().
/// inarray (IN)   - Pointer to input array representtion of DateTime
/// len (IN)       - len of inarray.
/// type (IN)      - One of SQLT_DATE, SQLT_TIME, SQLT_TIME_TZ, SQLT_TIMESTAMP,
/// SQLT_TIMESTAMP_TZ, or SQLT_TIMESTAMP_LTZ.
/// datetime (OUT) - Pointer to the result OCIDateTime.
/// reftz (IN)     - timezone interval used with SQLT_TIMESTAMP_LTZ.
/// fsprec (IN)    - fractionl seconds digits of precision (0-9).
/// DESCRIPTION:
/// Returns a pointer to an OCIDateTime of type type converted from
/// the inarray.
/// RETURNS:
/// OCI_SUCCESS if the function completes successfully.
/// OCI_INVALID_HANDLE if 'err' is NULL.
/// OCI_ERROR if
/// buffer too small
/// error retrieving timezone data
/// invalid region
/// invalid LdiDateTime type
///
/// ----------------------------------OCIRowidToChar-----------------------------
/// Name
/// OCIRowidToChar
///
/// Purpose
/// Converts physical/logical (universal) ROWID to chracter extended (Base 64)
/// representation into user provided buffer outbfp of length outbflp. After
/// execution outbflp contains amount of bytes converted.In case of truncation
/// error, outbflp contains required size to make this conversion successful
/// and returns ORA-1405.
///
/// Syntax
/// sword OCIRowidToChar( OCIRowid *rowidDesc,
/// OraText *outbfp,
/// ub2 *outbflp,
/// OCIError *errhp)
///
/// Comments
/// After this conversion, ROWID in character format can be bound using
/// OCIBindByPos or OCIBindByName call and used to query a row at a
/// desired ROWID.
///
/// Parameters
/// rowidDesc (IN)   - rowid DESCriptor which is allocated from OCIDescritorAlloc
/// and populated by a prior SQL statement execution
/// outbfp (OUT)     - pointer to the buffer where converted rowid in character
/// representation is stored after successful execution.
/// outbflp (IN/OUT) - pointer to output buffer length variable.
/// Before execution (IN mode) *outbflp contains the size of
/// outbfp, after execution (OUT mode) *outbflp contains amount
/// of bytes converted. In an event of truncation during
/// conversion *outbflp contains the required length to make
/// conversion successful.
/// errhp (IN/OUT)   - an error handle which can be passed to OCIErrorGet() for
/// diagnostic information in the event of an error.
///
/// ------------------------------OCIDefineArrayOfStruct--------------------------
///
///
/// OCIDefineArrayOfStruct()
/// Name
/// OCI Define for Array of Structures
/// Purpose
/// This call specifies additional attributes necessary for a static array define.
/// Syntax
/// sword OCIDefineArrayOfStruct ( OCIDefine   *defnp,
/// OCIError    *errhp,
/// ub4         pvskip,
/// ub4         indskip,
/// ub4         rlskip,
/// ub4         rcskip );
/// Comments
/// This call specifies additional attributes necessary for an array define,
/// used in an array of structures (multi-row, multi-column) fetch.
/// For more information about skip parameters, see the section "Skip Parameters"
/// on page 4-17.
/// Parameters
/// defnp (IN) - the handle to the define structure which was returned by a call
/// to OCIDefineByPos().
/// errhp (IN) - an error handle which can be passed to OCIErrorGet() for
/// diagnostic information in the event of an error.
/// pvskip (IN) - skip parameter for the next data value.
/// indskip (IN) - skip parameter for the next indicator location.
/// rlskip (IN) - skip parameter for the next return length value.
/// rcskip (IN) - skip parameter for the next return code.
/// Related Functions
/// OCIAttrGet()
///
///
///
///
///
/// OCIDefineByPos()
/// Name
/// OCI Define By Position
/// Purpose
/// Associates an item in a select-list with the type and output data buffer.
/// Syntax
/// sb4 OCIDefineByPos (
/// OCIStmt     *stmtp,
/// OCIDefine   **defnp,
/// OCIError    *errhp,
/// ub4         position,
/// void       *valuep,
/// sb4         value_sz,
/// ub2         dty,
/// void       *indp,
/// ub2         *rlenp,
/// ub2         *rcodep,
/// ub4         mode );
/// Comments
/// This call defines an output buffer which will receive data retreived from
/// Oracle. The define is a local step which is necessary when a SELECT statement
/// returns data to your OCI application.
/// This call also implicitly allocates the define handle for the select-list item.
/// Defining attributes of a column for a fetch is done in one or more calls. The
/// first call is to OCIDefineByPos(), which defines the minimal attributes
/// required to specify the fetch.
/// This call takes as a parameter a define handle, which must have been
/// previously allocated with a call to OCIHandleAlloc().
/// Following the call to OCIDefineByPos() additional define calls may be
/// necessary for certain data types or fetch modes:
/// A call to OCIDefineArrayOfStruct() is necessary to set up skip parameters
/// for an array fetch of multiple columns.
/// A call to OCIDefineObject() is necessary to set up the appropriate
/// attributes of a named data type fetch. In this case the data buffer pointer
/// in ocidefn() is ignored.
/// Both OCIDefineArrayOfStruct() and OCIDefineObject() must be called
/// after ocidefn() in order to fetch multiple rows with a column of named
/// data types.
/// For a LOB define, the buffer pointer must be a lob locator of type
/// OCILobLocator , allocated by the OCIDescAlloc() call. LOB locators, and not
/// LOB values, are always returned for a LOB column. LOB values can then be
/// fetched using OCI LOB calls on the fetched locator.
/// For NCHAR (fixed and varying length), the buffer pointer must point to an
/// array of bytes sufficient for holding the required NCHAR characters.
/// Nested table columns are defined and fetched like any other named data type.
/// If the mode parameter is this call is set to OCI_DYNAMIC_FETCH, the client
/// application can fetch data dynamically at runtime.
/// Runtime data can be provided in one of two ways:
/// callbacks using a user-defined function which must be registered with a
/// subsequent call to OCIDefineDynamic(). When the client library needs a
/// buffer to return the fetched data, the callback will be invoked and the
/// runtime buffers provided will return a piece or the whole data.
/// a polling mechanism using calls supplied by the OCI. This mode is
/// assumed if no callbacks are defined. In this case, the fetch call returns the
/// OCI_NEED_DATA error code, and a piecewise polling method is used
/// to provide the data.
/// Related Functions: For more information about using the
/// OCI_DYNAMIC_FETCH mode, see the section "Runtime Data
/// Allocation and Piecewise Operations" on page 5-16 of Volume 1..
/// For more information about the define step, see the section "Defining"
/// on page 2-30.
/// Parameters
/// stmtp (IN) - a handle to the requested SQL query operation.
/// defnp (IN/OUT) - a pointer to a pointer to a define handle which is implicitly
/// allocated by this call.  This handle is used to  store the define information
/// for this column.
/// errhp (IN) - an error handle which can be passed to OCIErrorGet() for
/// diagnostic information in the event of an error.
/// position (IN) - the position of this value in the select list. Positions are
/// 1-based and are numbered from left to right. For example, in the SELECT
/// statement
/// SELECT empno, ssn, mgrno FROM employees;
/// empno is at position 1, ssn is at position 2, and mgrno is at position 3.
/// valuep (IN/OUT) - a pointer to a buffer or an array of buffers of the type
/// specified in the dty parameter. A number of buffers can be specified when
/// results for more than one row are desired in a single fetch call.
/// value_sz (IN) - the size of each valuep buffer in bytes. If the data is stored
/// internally in VARCHAR2 format, the number of characters desired, if different
/// from the buffer size in bytes, may be additionally specified by the using
/// OCIAttrSet().
/// In an NLS conversion environment, a truncation error will be generated if the
/// number of bytes specified is insufficient to handle the number of characters
/// desired.
/// dty (IN) - the data type. Named data type (SQLT_NTY) and REF (SQLT_REF)
/// are valid only if the environment has been intialized with in object mode.
/// indp - pointer to an indicator variable or array. For scalar data types,
/// pointer to sb2 or an array of sb2s. Ignored for named data types. For named
/// data types, a pointer to a named data type indicator structure or an array of
/// named data type indicator structures is associated by a subsequent
/// OCIDefineObject() call.
/// See the section "Indicator Variables" on page 2-43 for more information about
/// indicator variables.
/// rlenp (IN/OUT) - pointer to array of length of data fetched. Each element in
/// rlenp is the length of the data in the corresponding element in the row after
/// the fetch.
/// rcodep (OUT) - pointer to array of column-level return codes
/// mode (IN) - the valid modes are:
/// OCI_DEFAULT. This is the default mode.
/// OCI_DYNAMIC_FETCH. For applications requiring dynamically
/// allocated data at the time of fetch, this mode must be used. The user may
/// additionally call OCIDefineDynamic() to set up a callback function that
/// will be invoked to receive the dynamically allocated buffers and to set
/// up the memory allocate/free callbacks and the context for the callbacks.
/// valuep and value_sz are ignored in this mode.
/// Related Functions
/// OCIDefineArrayOfStruct(), OCIDefineDynamic(), OCIDefineObject()
///
///
///
///
/// OCIDefineDynamic()
/// Name
/// OCI Define Dynamic Fetch Attributes
/// Purpose
/// This call is used to set the additional attributes required if the
/// OCI_DYNAMIC_FETCH mode was selected in OCIDefineByPos().
/// Syntax
/// sword OCIDefineDynamic( OCIDefine   *defnp,
/// OCIError    *errhp,
/// void       *octxp,
/// OCICallbackDefine (ocbfp)(
/// void             *octxp,
/// OCIDefine         *defnp,
/// ub4               iter,
/// void             **bufpp,
/// ub4               **alenpp,
/// ub1               *piecep,
/// void             **indpp,
/// ub2               **rcodep)  );
/// Comments
/// This call is used to set the additional attributes required if the
/// OCI_DYNAMIC_FETCH mode has been selected in a call to
/// OCIDefineByPos().
/// When the OCI_DYNAMIC_FETCH mode is selected, buffers will be
/// dynamically allocated for REF, and named data type, values to receive the
/// data. The pointers to these buffers will be returned.
/// If OCI_DYNAMIC_FETCH mode was selected, and the call to
/// OCIDefineDynamic() is skipped, then the application can fetch data piecewise
/// using OCI calls.
/// For more information about OCI_DYNAMIC_FETCH mode, see the section
/// "Runtime Data Allocation and Piecewise Operations" on page 5-16.
/// Parameters
/// defnp (IN/OUT) - the handle to a define structure returned by a call to
/// OCIDefineByPos().
/// errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
/// diagnostic information in the event of an error.
/// octxp (IN) - points to a context for the callback function.
/// ocbfp (IN) - points to a callback function. This is invoked at runtime to get
/// a pointer to the buffer into which the fetched data or a piece of it will be
/// retreived. The callback also specifies the indicator, the return code and the
/// lengths of the data piece and indicator. The callback has the following
/// parameters:
/// octxp (IN) - a context pointer passed as an argument to all the callback
/// functions.
/// defnp (IN) - the define handle.
/// iter (IN) - which row of this current fetch.
/// bufpp (OUT) - returns a pointer to a buffer to store the column value, ie.
/// bufp points to some appropriate storage for the column value.
/// alenpp (OUT) - returns a pointer to the length of the buffer. *alenpp
/// contains the size of the buffer after return from callback. Gets set to
/// actual data size after fetch.
/// piecep (IN/OUT) - returns a piece value, as follows:
/// The IN value can be OCI_ONE_PIECE, OCI_FIRST_PIECE or
/// OCI_NEXT_PIECE.
/// The OUT value can be OCI_ONE_PIECE if the IN value was
/// OCI_ONE_PIECE.
/// The OUT value can be OCI_ONE_PIECE or OCI_FIRST_PIECE if
/// the IN value was OCI_FIRST_PIECE.
/// The OUT value can only be OCI_NEXT_PIECE or
/// OCI_LAST_PIECE if the IN value was OCI_NEXT_PIECE.
/// indpp (IN) - indicator variable pointer
/// rcodep (IN) - return code variable pointer
/// Related Functions
/// OCIAttrGet()
/// OCIDefineObject()
///
///
///
///
/// OCIDefineObject()
/// Name
/// OCI Define Named Data Type attributes
/// Purpose
/// Sets up additional attributes necessary for a Named Data Type define.
/// Syntax
/// sword OCIDefineObject ( OCIDefine       *defnp,
/// OCIError        *errhp,
/// const OCIType   *type,
/// void           **pgvpp,
/// ub4             *pvszsp,
/// void           **indpp,
/// ub4             *indszp );
/// Comments
/// This call sets up additional attributes necessary for a Named Data Type define.
/// An error will be returned if this function is called when the OCI environment
/// has been initialized in non-Object mode.
/// This call takes as a paramter a type descriptor object (TDO) of datatype
/// OCIType for the named data type being defined.  The TDO can be retrieved
/// with a call to OCITypeByName().
/// See the description of OCIInitialize() on page 13 - 43 for more information
/// about initializing the OCI process environment.
/// Parameters
/// defnp (IN/OUT) - a define handle previously allocated in a call to
/// OCIDefineByPos().
/// errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
/// diagnostic information in the event of an error.
/// type (IN, optional) - points to the Type Descriptor Object (TDO) which
/// describes the type of the program variable. Only used for program variables
/// of type SQLT_NTY. This parameter is optional, and may be passed as NULL
/// if it is not being used.
/// pgvpp (IN/OUT) - points to a pointer to a program variable buffer. For an
/// array, pgvpp points to an array of pointers. Memory for the fetched named data
/// type instance(s) is dynamically allocated in the object cache. At the end of
/// the fetch when all the values have been received, pgvpp points to the
/// pointer(s) to these newly allocated named data type instance(s). The
/// application must call OCIObjectMarkDel() to deallocate the named data type
/// instance(s) when they are no longer needed.
/// pvszsp (IN/OUT) - points to the size of the program variable. For an array, it
/// is an array of ub4s. On return points to the size(s) of unpickled fetched
/// values.
/// indpp (IN/OUT) - points to a pointer to the program variable buffer
/// containing the parallel indicator structure. For an array, points to an array
/// of pointers. Memory is allocated to store the indicator structures in the
/// object cache. At the end of the fetch when all values have been received,
/// indpp points to the pointer(s) to these newly allocated indicator structure(s).
/// indszp (IN/OUT) - points to the size(s) of the indicator structure program
/// variable. For an array, it is an array of ub4s. On return points to the size(s)
/// of the unpickled fetched indicator values.
/// Related Functions
/// OCIAttrGet()
///
///
///
/// OCIDescAlloc()
/// Name
/// OCI Get DESCriptor or lob locator
/// Purpose
/// Allocates storage to hold certain data types. The descriptors can be used as
/// bind or define variables.
/// Syntax
/// sword OCIDescAlloc ( const void   *parenth,
/// void         **descpp,
/// ub4           type,
/// size_t        xtramem_sz,
/// void         **usrmempp);
/// Comments
/// Returns a pointer to an allocated and initialized structure, corresponding to
/// the type specified in type. A non-NULL descriptor or LOB locator is returned
/// on success. No diagnostics are available on error.
/// This call returns OCI_SUCCESS if successful, or OCI_INVALID_HANDLE if
/// an out-of-memory error occurs.
/// Parameters
/// parenth (IN) - an environment handle.
/// descpp (OUT) - returns a descriptor or LOB locator of desired type.
/// type (IN) - specifies the type of descriptor or LOB locator to be allocated.
/// The specific types are:
/// OCI_DTYPE_SNAP - specifies generation of snapshot descriptor of C
/// type - OCISnapshot
/// OCI_DTYPE_LOB - specifies generation of a LOB data type locator of C
/// type - OCILobLocator
/// OCI_DTYPE_RSET - specifies generation of a descriptor of C type
/// OCIResult that references a result set (a number of rows as a result of a
/// query). This descriptor is bound to a bind variable of data type
/// SQLT_RSET (result set). The descriptor has to be converted into a
/// statement handle using a function - OCIResultSetToStmt() - which can
/// then be passed to OCIDefineByPos() and OCIStmtFetch() to retrieve the
/// rows of the result set.
/// OCI_DTYPE_ROWID - specifies generation of a ROWID descriptor of C
/// type OCIRowid.
/// OCI_DTYPE_COMPLEXOBJECTCOMP - specifies generation of a
/// complex object retrieval descriptor of C type
/// OCIComplexObjectComp.
/// xtramemsz (IN) - specifies an amount of user memory to be allocated for use
/// by the application.
/// usrmempp (OUT) - returns a pointer to the user memory of size xtramemsz
/// allocated by the call for the user.
/// Related Functions
/// OCIDescFree()
///
///
///
///
/// OCIDescFree()
/// Name
/// OCI Free DESCriptor
/// Purpose
/// Deallocates a previously allocated descriptor.
/// Syntax
/// sword OCIDescFree ( void    *descp,
/// ub4      type);
/// Comments
/// This call frees up storage associated with the descriptor, corresponding to the
/// type specified in type. Returns OCI_SUCCESS or OCI_INVALID_HANDLE.
/// All descriptors must be explicitly deallocated. OCI will not deallocate a
/// descriptor if the environment handle is deallocated.
/// Parameters
/// descp (IN) - an allocated descriptor.
/// type (IN) - specifies the type of storage to be freed. The specific types are:
/// OCI_DTYPE_SNAP - snapshot descriptor
/// OCI_DTYPE_LOB - a LOB data type descriptor
/// OCI_DTYPE_RSET - a descriptor that references a result set (a number
/// of rows as a result of a query).
/// OCI_DTYPE_ROWID - a ROWID descriptor
/// OCI_DTYPE_COMPLEXOBJECTCOMP - a complex object retrieval
/// descriptor
/// Related Functions
/// OCIDescAlloc()
///
///
///
/// OCIDescribeAny()
/// Name
/// OCI DeSCribe Any
/// Purpose
/// Describes existing schema objects.
/// Syntax
/// sword OCIDescribeAny ( OCISvcCtx     *svchp,
/// OCIError      *errhp,
/// void         *objptr,
/// ub4           objnm_len,
/// ub1           objptr_typ,
/// ub1           info_level,
/// ub1           objtype,
/// OCIDesc       *dschp );
/// Comments
/// This is a generic describe call that describes existing schema objects: tables,
/// views, synonyms, procedures, functions, packages, sequences, and types. As a
/// result of this call, the describe handle is populated with the object-specific
/// attributes which can be obtained through an OCIAttrGet() call.
/// An OCIParamGet() on the describe handle returns a parameter descriptor for a
/// specified position. Parameter positions begin with 1. Calling OCIAttrGet() on
/// the parameter descriptor returns the specific attributes of a stored procedure
/// or function parameter or a table column descriptor as the case may be.
/// These subsequent calls do not need an extra round trip to the server because
/// the entire schema object description cached on the client side by
/// OCIDescribeAny(). Calling OCIAttrGet() on the describe handle can also return
/// the total number of positions.
/// See the section "Describing" on page 2-33 for more information about describe
/// operations.
/// Parameters
/// TO BE UPDATED
/// svchp (IN/OUT) - a service context handle.
/// errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
/// diagnostic information in the event of an error.
/// objptr (IN) - the name of the object (a null-terminated string) to be
/// described. Only procedure or function names are valid when connected to an
/// Oracle7 Server.
/// objptr_len (IN) - the length of the string. Must be non-zero.
/// objptr_typ (IN) - Must be OCI_OTYPE_NAME, OCI_OTYPE_REF, or OCI_OTYPE_PTR.
/// info_level (IN) - reserved for future extensions. Pass OCI_DEFAULT.
/// objtype (IN/OUT) - object type.
/// dschp (IN/OUT) - a describe handle that is populated with describe
/// information about the object after the call.
/// Related Functions
/// OCIAttrGet()
///
///
///
/// OCIEnvCreate()
/// Name
/// OCI ENVironment CREATE
/// Purpose
/// This function creates and initializes an environment for the rest of
/// the OCI functions to work under.  This call is a replacement for both
/// the OCIInitialize and OCIEnvInit calls.
/// Syntax
/// sword OCIEnvCreate  ( OCIEnv        **envhpp,
/// ub4           mode,
/// const void   *ctxp,
/// const void   *(*malocfp)
/// (void *ctxp,
/// size_t size),
/// const void   *(*ralocfp)
/// (void *ctxp,
/// void *memptr,
/// size_t newsize),
/// const void    (*mfreefp)
/// ( void *ctxp,
/// void *memptr))
/// size_t    xtramemsz,
/// void     **usrmempp );
///
/// Comments
/// This call creates an environment for all the OCI calls using the modes
/// specified by the user. This call can be used instead of the two calls
/// OCIInitialize and OCIEnvInit. This function returns an environment handle
/// which is then used by the remaining OCI functions. There can be multiple
/// environments in OCI each with its own environment modes.  This function
/// also performs any process level initialization if required by any mode.
/// For example if the user wants to initialize an environment as OCI_THREADED,
/// then all libraries that are used by OCI are also initialized in the
/// threaded mode.
///
/// This call should be invoked before anny other OCI call and should be used
/// instead of the OCIInitialize and OCIEnvInit calls. This is the recommended
/// call, although OCIInitialize and OCIEnvInit calls will still be supported
/// for backward compatibility.
///
/// envpp (OUT) - a pointer to a handle to the environment.
/// mode (IN) - specifies initialization of the mode. The valid modes are:
/// OCI_DEFAULT - default mode.
/// OCI_THREADED - threaded environment. In this mode, internal data
/// structures are protected from concurrent accesses by multiple threads.
/// OCI_OBJECT - will use navigational object interface.
/// ctxp (IN) - user defined context for the memory call back routines.
/// malocfp (IN) - user-defined memory allocation function. If mode is
/// OCI_THREADED, this memory allocation routine must be thread safe.
/// ctxp - context pointer for the user-defined memory allocation function.
/// size - size of memory to be allocated by the user-defined memory
/// allocation function
/// ralocfp (IN) - user-defined memory re-allocation function. If mode is
/// OCI_THREADED, this memory allocation routine must be thread safe.
/// ctxp - context pointer for the user-defined memory reallocation
/// function.
/// memp - pointer to memory block
/// newsize - new size of memory to be allocated
/// mfreefp (IN) - user-defined memory free function. If mode is
/// OCI_THREADED, this memory free routine must be thread safe.
/// ctxp - context pointer for the user-defined memory free function.
/// memptr - pointer to memory to be freed
/// xtramemsz (IN) - specifies the amount of user memory to be allocated.
/// usrmempp (OUT) - returns a pointer to the user memory of size xtramemsz
/// allocated by the call for the user.
///
/// Example
///
/// Related Functions
/// OCIInitialize, OCIEnvInit
///
/// OCIEnvNlsCreate()
/// Name
/// OCI ENVironment CREATE with NLS info
/// Purpose
/// This function does almost everything OCIEnvCreate does, plus enabling setting
/// of charset and ncharset programmatically, except OCI_UTF16 mode.
/// Syntax
/// sword OCIEnvNlsCreate(OCIEnv        **envhpp,
/// ub4           mode,
/// void         *ctxp,
/// void         *(*malocfp)
/// (void *ctxp,
/// size_t size),
/// void         *(*ralocfp)
/// (void *ctxp,
/// void *memptr,
/// size_t newsize),
/// void          (*mfreefp)
/// (void *ctxp,
/// void *memptr),
/// size_t        xtramemsz,
/// void         **usrmempp,
/// ub2           charset,
/// ub2           ncharset)
/// Comments
/// The charset and ncharset must be both zero or non-zero.
/// The parameters have the same meaning as the ones in OCIEnvCreate().
/// When charset or ncharset is non-zero, the corresponding character set will
/// be used to replace the ones specified in NLS_LANG or NLS_NCHAR. Moreover,
/// OCI_UTF16ID is allowed to be set as charset and ncharset.
/// On the other hand, OCI_UTF16 mode is deprecated with this function.
/// Applications can achieve the same effects by setting
/// both charset and ncharset as OCI_UTF16ID.
///
///
/// OCIEnvInit()
/// Name
/// OCI INITialize environment
/// Purpose
/// This call initializes the OCI environment handle.
/// Syntax
/// sword OCIEnvInit ( OCIEnv    **envp,
/// ub4       mode,
/// size_t    xtramemsz,
/// void     **usrmempp );
/// Comments
/// Initializes the OCI environment handle. No changes are done on an initialized
/// handle. If OCI_ERROR or OCI_SUCCESS_WITH_INFO is returned, the
/// environment handle can be used to obtain ORACLE specific errors and
/// diagnostics.
/// This call is processed locally, without a server round-trip.
/// Parameters
/// envpp (OUT) - a pointer to a handle to the environment.
/// mode (IN) - specifies initialization of an environment mode. The only valid
/// mode is OCI_DEFAULT for default mode
/// xtramemsz (IN) - specifies the amount of user memory to be allocated.
/// usrmempp (OUT) - returns a pointer to the user memory of size xtramemsz
/// allocated by the call for the user.
/// Example
/// See the description of OCISessionBegin() on page 13-84 for an example showing
/// the use of OCIEnvInit().
/// Related Functions
///
///
///
///
/// OCIErrorGet()
/// Name
/// OCI Get Diagnostic Record
/// Purpose
/// Returns an error message in the buffer provided and an ORACLE error.
/// Syntax
/// sword OCIErrorGet ( void      *hndlp,
/// ub4        recordno,
/// OraText       *sqlstate,
/// ub4        *errcodep,
/// OraText       *bufp,
/// ub4        bufsiz,
/// ub4        type );
/// Comments
/// Returns an error message in the buffer provided and an ORACLE error.
/// Currently does not support SQL state. This call can be called a multiple
/// number of times if there are more than one diagnostic record for an error.
/// The error handle is originally allocated with a call to OCIHandleAlloc().
/// Parameters
/// hndlp (IN) - the error handle, in most cases, or the environment handle (for
/// errors on OCIEnvInit(), OCIHandleAlloc()).
/// recordno (IN) - indicates the status record from which the application seeks
/// info. Starts from 1.
/// sqlstate (OUT) - Not supported in Version 8.0.
/// errcodep (OUT) - an ORACLE Error is returned.
/// bufp (OUT) - the error message text is returned.
/// bufsiz (IN) - the size of the buffer provide to get the error message.
/// type (IN) - the type of the handle.
/// Related Functions
/// OCIHandleAlloc()
///
/// OCIExtractInit
/// Name
/// OCI Extract Initialize
/// Purpose
/// This function initializes the parameter manager.
/// Syntax
/// sword OCIExtractInit(void *hndl, OCIError *err);
/// Comments
/// It must be called before calling any other parameter manager routine. The NLS
/// information is stored inside the parameter manager context and used in
/// subsequent calls to OCIExtract routines.
/// Returns OCI_SUCCESS, OCI_INVALID_HANDLE, or OCI_ERROR
/// Parameters
/// hndl (IN/OUT) - The OCI environment or session handle.
/// err (IN/OUT) - The OCI error handle. If there is an error, it is recorded in
/// err and this function returns OCI_ERROR. Diagnostic information
/// can be obtained by calling OCIErrorGet().
/// Related Functions
/// OCIExtractTerm()
///
/// OCIExtractTerm
/// Name
/// OCI Extract Terminate
/// Purpose
/// This function releases all dynamically allocated storage and may perform
/// other internal bookkeeping functions.
/// Syntax
/// sword OCIExtractTerm(void *hndl, OCIError *err);
/// Comments
/// It must be called when the parameter manager is no longer being used.
/// Returns OCI_SUCCESS, OCI_INVALID_HANDLE, or OCI_ERROR
/// Parameters
/// hndl (IN/OUT) - The OCI environment or session handle.
/// err (IN/OUT) - The OCI error handle. If there is an error, it is recorded in
/// err and this function returns OCI_ERROR. Diagnostic information
/// can be obtained by calling OCIErrorGet().
/// Related Functions
/// OCIExtractInit()
///
/// OCIExtractReset
/// Name
/// OCI Extract Reset
/// Purpose
/// The memory currently used for parameter storage, key definition storage, and
/// parameter value lists is freed and the structure is reinitialized.
/// Syntax
/// sword OCIExtractReset(void *hndl, OCIError *err);
/// Comments
/// Returns OCI_SUCCESS, OCI_INVALID_HANDLE, or OCI_ERROR
/// Parameters
/// hndl (IN/OUT) - The OCI environment or session handle.
/// err (IN/OUT) - The OCI error handle. If there is an error, it is recorded in
/// err and this function returns OCI_ERROR. Diagnostic information
/// can be obtained by calling OCIErrorGet().
/// Related Functions
///
/// OCIExtractSetNumKeys
/// Name
/// OCI Extract Set Number of Keys
/// Purpose
/// Informs the parameter manager of the number of keys that will be registered.
/// Syntax
/// sword OCIExtractSetNumKeys(void *hndl, OCIError *err, uword numkeys);
/// Comments
/// This routine must be called prior to the first call of OCIExtractSetKey().
/// Returns OCI_SUCCESS, OCI_INVALID_HANDLE, or OCI_ERROR
/// Parameters
/// hndl (IN/OUT) - The OCI environment or session handle.
/// err (IN/OUT) - The OCI error handle. If there is an error, it is recorded in
/// err and this function returns OCI_ERROR. Diagnostic information
/// can be obtained by calling OCIErrorGet().
/// numkeys (IN) - The number of keys that will be registered with
/// OCIExtractSetKey().
/// Related Functions
/// OCIExtractSetKey()
///
/// OCIExtractSetKey
/// Name
/// OCI Extract Set Key definition
/// Purpose
/// Registers information about a key with the parameter manager.
/// Syntax
/// sword OCIExtractSetKey(void *hndl, OCIError *err, const OraText *name,
/// ub1 type, ub4 flag, const void *defval,
/// const sb4 *intrange, const OraText *const *strlist);
/// Comments
/// This routine must be called after calling OCIExtractSetKey() and before
/// calling OCIExtractFromFile() or OCIExtractFromStr().
/// Returns OCI_SUCCESS, OCI_INVALID_HANDLE, or OCI_ERROR
/// Parameters
/// hndl (IN/OUT) - The OCI environment or session handle.
/// err (IN/OUT) - The OCI error handle. If there is an error, it is recorded in
/// err and this function returns OCI_ERROR. Diagnostic information
/// can be obtained by calling OCIErrorGet().
/// name (IN) - The name of the key.
/// type (IN) - The type of the key (OCI_EXTRACT_TYPE_INTEGER,
/// OCI_EXTRACT_TYPE_OCINUM, OCI_EXTRACT_TYPE_STRING, or
/// OCI_EXTRACT_TYPE_BOOLEAN).
/// flag (IN) - Set to OCI_EXTRACT_MULTIPLE if the key can take multiple values
/// or 0 otherwise.
/// defval (IN) - Set to the default value for the key.  May be NULL if there is
/// no default.  A string default must be a (text*) type, an
/// integer default must be an (sb4*) type, and a boolean default
/// must be a (ub1*) type.
/// intrange (IN) - Starting and ending values for the allowable range of integer
/// values.  May be NULL if the key is not an integer type or if
/// all integer values are acceptable.
/// strlist (IN) - List of all acceptable text strings for the key.  May be NULL
/// if the key is not a string type or if all text values are
/// acceptable.
/// Related Functions
/// OCIExtractSetNumKeys()
///
/// OCIExtractFromFile
/// Name
/// OCI Extract parameters From File
/// Purpose
/// The keys and their values in the given file are processed.
/// Syntax
/// sword OCIExtractFromFile(void *hndl, OCIError *err, ub4 flag,
/// OraText *filename);
/// Comments
/// Returns OCI_SUCCESS, OCI_INVALID_HANDLE, or OCI_ERROR
/// Parameters
/// hndl (IN/OUT) - The OCI environment or session handle.
/// err (IN/OUT) - The OCI error handle. If there is an error, it is recorded in
/// err and this function returns OCI_ERROR. Diagnostic information
/// can be obtained by calling OCIErrorGet().
/// flag (IN) - Zero or has one or more of the following bits set:
/// OCI_EXTRACT_CASE_SENSITIVE, OCI_EXTRACT_UNIQUE_ABBREVS, or
/// OCI_EXTRACT_APPEND_VALUES.
/// filename (IN) - Null-terminated filename string.
/// Related Functions
///
/// OCIExtractFromStr
/// Name
/// OCI Extract parameters From String
/// Purpose
/// The keys and their values in the given string are processed.
/// Syntax
/// sword OCIExtractFromStr(void *hndl, OCIError *err, ub4 flag, OraText *input);
/// Comments
/// Returns OCI_SUCCESS, OCI_INVALID_HANDLE, or OCI_ERROR
/// Parameters
/// hndl (IN/OUT) - The OCI environment or session handle.
/// err (IN/OUT) - The OCI error handle. If there is an error, it is recorded in
/// err and this function returns OCI_ERROR. Diagnostic information
/// can be obtained by calling OCIErrorGet().
/// flag (IN) - Zero or has one or more of the following bits set:
/// OCI_EXTRACT_CASE_SENSITIVE, OCI_EXTRACT_UNIQUE_ABBREVS, or
/// OCI_EXTRACT_APPEND_VALUES.
/// input (IN) - Null-terminated input string.
/// Related Functions
///
/// OCIExtractToInt
/// Name
/// OCI Extract To Integer
/// Purpose
/// Gets the integer value for the specified key.
/// Syntax
/// sword OCIExtractToInt(void *hndl, OCIError *err, OraText *keyname,
/// uword valno, sb4 *retval);
/// Comments
/// The valno'th value (starting with 0) is returned.
/// Returns OCI_SUCCESS, OCI_INVALID_HANDLE, OCI_NO_DATA, or OCI_ERROR.
/// OCI_NO_DATA means that there is no valno'th value for this key.
/// Parameters
/// hndl (IN) - The OCI environment or session handle.
/// err (IN/OUT) - The OCI error handle. If there is an error, it is recorded in
/// err and this function returns OCI_ERROR. Diagnostic information
/// can be obtained by calling OCIErrorGet().
/// keyname (IN) - Key name.
/// valno (IN) - Which value to get for this key.
/// retval (OUT) - The actual integer value.
/// Related Functions
///
/// OCIExtractToBool
/// Name
/// OCI Extract To Boolean
/// Purpose
/// Gets the boolean value for the specified key.
/// Syntax
/// sword OCIExtractToBool(void *hndl, OCIError *err, OraText *keyname,
/// uword valno, ub1 *retval);
/// Comments
/// The valno'th value (starting with 0) is returned.
/// Returns OCI_SUCCESS, OCI_INVALID_HANDLE, OCI_NO_DATA, or OCI_ERROR.
/// OCI_NO_DATA means that there is no valno'th value for this key.
/// Parameters
/// hndl (IN) - The OCI environment or session handle.
/// err (IN/OUT) - The OCI error handle. If there is an error, it is recorded in
/// err and this function returns OCI_ERROR. Diagnostic information
/// can be obtained by calling OCIErrorGet().
/// keyname (IN) - Key name.
/// valno (IN) - Which value to get for this key.
/// retval (OUT) - The actual boolean value.
/// Related Functions
///
/// OCIExtractToStr
/// Name
/// OCI Extract To String
/// Purpose
/// Gets the string value for the specified key.
/// Syntax
/// sword OCIExtractToStr(void *hndl, OCIError *err, OraText *keyname,
/// uword valno, OraText *retval, uword buflen);
/// Comments
/// The valno'th value (starting with 0) is returned.
/// Returns OCI_SUCCESS, OCI_INVALID_HANDLE, OCI_NO_DATA, or OCI_ERROR.
/// OCI_NO_DATA means that there is no valno'th value for this key.
/// Parameters
/// hndl (IN) - The OCI environment or session handle.
/// err (IN/OUT) - The OCI error handle. If there is an error, it is recorded in
/// err and this function returns OCI_ERROR. Diagnostic information
/// can be obtained by calling OCIErrorGet().
/// keyname (IN) - Key name.
/// valno (IN) - Which value to get for this key.
/// retval (OUT) - The actual null-terminated string value.
/// buflen (IN) - The length of the buffer for retval.
/// Related Functions
///
/// Note: The following OCIExtract functions are unavailable in this release
///
/// OCIExtractToOCINum
/// Name
/// OCI Extract To OCI Number
/// Purpose
/// Gets the OCINumber value for the specified key.
/// Syntax
/// sword OCIExtractToOCINum(void *hndl, OCIError *err, OraText *keyname,
/// uword valno, OCINumber *retval);
/// Comments
/// The valno'th value (starting with 0) is returned.
/// Returns OCI_SUCCESS, OCI_INVALID_HANDLE, OCI_NO_DATA, or OCI_ERROR.
/// OCI_NO_DATA means that there is no valno'th value for this key.
/// Parameters
/// hndl (IN) - The OCI environment or session handle.
/// err (IN/OUT) - The OCI error handle. If there is an error, it is recorded in
/// err and this function returns OCI_ERROR. Diagnostic information
/// can be obtained by calling OCIErrorGet().
/// keyname (IN) - Key name.
/// valno (IN) - Which value to get for this key.
/// retval (OUT) - The actual OCINumber value.
/// Related Functions
///
/// OCIExtractToList
/// Name
/// OCI Extract To parameter List
/// Purpose
/// Generates a list of parameters from the parameter structures that are stored
/// in memory.
/// Syntax
/// sword OCIExtractToList(void *hndl, OCIError *err, uword *numkeys);
/// Comments
/// Must be called before OCIExtractValues() is called.
/// Returns OCI_SUCCESS, OCI_INVALID_HANDLE, or OCI_ERROR
/// Parameters
/// hndl (IN) - The OCI environment or session handle.
/// err (IN/OUT) - The OCI error handle. If there is an error, it is recorded in
/// err and this function returns OCI_ERROR. Diagnostic information
/// can be obtained by calling OCIErrorGet().
/// numkeys (OUT) - Number of distinct keys stored in memory.
/// Related Functions
/// OCIExtractFromList()
///
/// OCIExtractFromList
/// Name
/// OCI Extract From parameter List
/// Purpose
/// Generates a list of values for the a parameter in the parameter list.
/// Syntax
/// sword OCIExtractFromList(void *hndl, OCIError *err, uword index,
/// OraText *name, ub1 *type, uword *numvals,
/// void ***values);
/// Comments
/// Parameters are specified by an index. OCIExtractToList() must be called prior
/// to calling this routine to generate the parameter list from the parameter
/// structures that are stored in memory.
/// Returns OCI_SUCCESS, OCI_INVALID_HANDLE, or OCI_ERROR
/// Parameters
/// hndl (IN) - The OCI environment or session handle.
/// err (IN/OUT) - The OCI error handle. If there is an error, it is recorded in
/// err and this function returns OCI_ERROR. Diagnostic information
/// can be obtained by calling OCIErrorGet().
/// name (OUT) - Name of the key for the current parameter.
/// type (OUT) - Type of the current parameter (OCI_EXTRACT_TYPE_STRING,
/// OCI_EXTRACT_TYPE_INTEGER, OCI_EXTRACT_TYPE_OCINUM, or
/// OCI_EXTRACT_TYPE_BOOLEAN)
/// numvals (OUT) - Number of values for this parameter.
/// values (OUT) - The values for this parameter.
/// Related Functions
/// OCIExtractToList()
///
///
/// OCIFileClose() ***********************************
///
/// Name
/// OCIFileClose - Oracle Call Interface FILE i/o CLOSE
///
/// Purpose
/// Close a previously opened file.
///
/// Syntax
/// sword OCIFileClose ( void             *hndl,
/// OCIError          *err,
/// OCIFileObject     *filep )
///
/// Comments
/// This function will close a previously opened file. If the function succeeds
/// then OCI_SUCCESS will be returned, else OCI_ERROR.
///
/// Parameters
/// hndl  (IN) - the OCI environment or session handle.
/// err (OUT) - the OCI error handle
/// filep (IN) - the OCIFile file object
///
/// Related Functions
/// OCIFileOpen.
///
///
///
/// OCIFileExists() **************************************
///
/// Name
/// OCIFileExists - Oracle Call Interface FILE i/o EXIST
///
/// Purpose
/// Check to see if the file exists.
///
/// Syntax
/// sword OCIFileExists ( void           *hndl,
/// OCIError         *err,
/// OraText          *filename,
/// OraText          *path,
/// ub1              *flag )
///
/// Comments
/// This function will set the flag to TRUE if the file exists else it will
/// be set to FALSE.
/// The function will return OCI_ERROR if any error is encountered, else
/// it will return OCI_ERROR.
///
/// Parameters
/// hndl(IN) - OCI environment or session handle
/// err(OUT) - OCI error handle
/// filename(IN) - filename
/// path(IN) - path of the file
/// flag(OUT) - whether the file exists or not
///
/// Related Functions.
/// None.
///
///
/// OCIFileFlush() ******************************
///
///
/// Name
/// OCIFileFlush - Oracle Call Interface File i/o FLUSH
///
/// Purpose
/// Flush the buffers associated with the file to the disk.
///
/// Syntax
/// sword OCIFileFlush ( void             *hndl,
/// OCIError          *err,
/// OCIFileObject     *filep )
///
/// Comments
/// The function will return OCI_ERROR if any error is encountered, else
/// it will return OCI_ERROR.
///
/// Parameters
/// hndl (IN) - the OCI environment or session handle.
/// err (OUT) - the OCI error handle
/// filep (IN) - the OCIFile file object
///
/// Related Functions
/// OCIFileOpen, OCIFileWrite
///
///
///
/// OCIFileGetLength() ****************************
///
/// Name
/// OCIFileGetLength - Oracle Call Interface FILE i/o GET file LENGTH
///
/// Purpose
/// Get the length of a file.
///
/// Syntax
/// OCIFileGetLength(void           *hndl,
/// OCIError        *err,
/// OraText         *filename,
/// OraText         *path,
/// ubig_ora        *lenp )
///
/// Comments
/// The length of the file will be returned in lenp.
/// The function will return OCI_ERROR if any error is encountered, else
/// it will return OCI_ERROR.
///
/// Parameters
/// hndl (IN) - the OCI environment or session handle.
/// err (OUT) - the OCI error handle.  If  there is an error, it is recorded
/// in err and this function returns OCI_ERROR.  Diagnostic information can be
/// obtained by calling OCIErrorGet().
/// filename (IN) - file name.
/// path (IN) - path of the file.
/// lenp (OUT) - On output, it is the length of the file in bytes.
/// is the number of bytes in the file.
///
/// Related Functions
/// None.
///
///
///
/// OCIFileInit() *****************************
///
/// Name
/// OCIFileInit - Oracle Call Interface FILE i/o INITialize
///
/// Purpose
/// Initialize the OCI File I/O package and create the OCIFile context.
///
/// Syntax
/// sword OCIFileInit ( void *hndl,
/// OCIError *err)
///
/// Comments
/// This function should be called before any of the OCIFile functions are
/// used.
/// The function will return OCI_ERROR if any error is encountered, else
/// it will return OCI_ERROR.
///
/// Parameters
/// hndl(IN) - OCI environment or session handle.
/// err(OUT) - OCI error structure.
///
/// Related Functions
/// OCIFileTerm
///
///
///
/// OCIFileOpen() *****************************
///
/// Name
/// OCIFileOpen - Oracle Call Interface File i/o OPEN
///
/// Purpose
/// Open a file.
///
/// Syntax
/// sword OCIFileOpen ( void               *hndl,
/// OCIError            *err,
/// OCIFileObject      **filep,
/// OraText             *filename,
/// OraText             *path,
/// ub4                  mode,
/// ub4                  create,
/// ub4                  type )
///
/// Comments
/// OCIFileOpen returns a handle to the open file in filep if the file is
/// successfully opened.
/// If one wants to use the standard file objects (stdin, stdout & stderr)
/// then OCIFileOpen whould be called with the type filed containing the
/// appropriate type (see the parameter type). If any of the standard files
/// are specified then filename, path, mode and create are ignored.
/// The function will return OCI_ERROR if any error is encountered, else
/// it will return OCI_ERROR.
///
/// Parameters
/// hndl (OUT) - the OCI environment or session handle.
/// err (OUT) - the OCI error handle.  If  there is an error, it is recorded
/// in err and this function returns OCI_ERROR.  Diagnostic information can be
/// obtained by calling OCIErrorGet().
/// filep (OUT) - the file object to be returned.
/// filename (IN) - file name (NULL terminated string).
/// path (IN) - path of the file (NULL terminated string).
/// mode - mode in which to open the file (valid modes are OCI_FILE_READONLY,
/// OCI_FILE_WRITEONLY, OCI_FILE_READ_WRITE).
/// create - should the file be created if it does not exist. Valid values
/// are:
/// OCI_FILE_TRUNCATE - create a file regardless of whether or not it exists.
/// If the file already exists overwrite it.
/// OCI_FILE_EXIST - open it if it exists, else fail.
/// OCI_FILE_EXCL - fail if the file exists, else create.
/// OCI_FILE_CREATE - open the file if it exists, and create it if it doesn't.
/// OCI_FILE_APPEND - set the file pointer to the end of the file prior to
/// writing(this flag can be OR'ed with OCI_FILE_EXIST or
/// OCI_FILE_CREATE).
/// type - file type. Valid values are OCI_FILE_TEXT, OCI_FILE_BIN,
/// OCI_FILE_STDIN, OCI_FILE_STDOUT and OCI_FILE_STDERR.
/// If any of the standard files are specified then filename, path, mode
/// and create are ignored.
///
/// Related Functions.
/// OCIFileClose
///
///
///
/// OCIFileRead() ************************************
///
/// Name
/// OCIFileRead - Oracle Call Interface FILE i/o READ
///
/// Purpose
/// Read from a file into a buffer.
///
/// Syntax
/// sword OCIFileRead ( void            *hndl,
/// OCIError         *err,
/// OCIFileObject    *filep,
/// void            *bufp,
/// ub4               bufl,
/// ub4              *bytesread )
///
/// Comments
/// Upto bufl bytes from the file will be read into bufp. The user should
/// allocate memory for the buffer.
/// The number of bytes read would be in bytesread.
/// The function will return OCI_ERROR if any error is encountered, else
/// it will return OCI_ERROR.
///
/// Parameters
/// hndl (IN) - the OCI environment or session handle.
/// err (OUT) - the OCI error handle.  If  there is an error, it is recorded
/// in err and this function returns OCI_ERROR.  Diagnostic information can be
/// obtained by calling OCIErrorGet().
/// filep (IN/OUT) - a File Object that uniquely references the file.
/// bufp (IN) - the pointer to a buffer into which the data will be read. The
/// length of the allocated memory is assumed to be bufl.
/// bufl - the length of the buffer in bytes.
/// bytesread (OUT) - the number of bytes read.
///
/// Related Functions
/// OCIFileOpen, OCIFileSeek, OCIFileWrite
///
///
///
/// OCIFileSeek() ******************************
///
/// Name
/// OCIFileSeek - Oracle Call Interface FILE i/o SEEK
///
/// Purpose
/// Perfom a seek to a byte position.
///
/// Syntax
/// sword OCIFileSeek ( void           *hndl,
/// OCIError        *err,
/// OCIFileObject   *filep,
/// uword            origin,
/// ubig_ora         offset,
/// sb1              dir)
///
/// Comments
/// The function will return OCI_ERROR if any error is encountered, else
/// it will return OCI_ERROR.
///
/// Parameters
/// hndl (IN) - the OCI environment or session handle.
/// err (OUT) - the OCI error handle.  If  there is an error, it is recorded
/// in err and this function returns OCI_ERROR.  Diagnostic information can be
/// obtained by calling OCIErrorGet().
/// filep (IN/OUT) - a file handle that uniquely references the file.
/// origin - The starting point we want to seek from. NOTE: The starting
/// point may be OCI_FILE_SEEK_BEGINNING (beginning), OCI_FILE_SEEK_CURRENT
/// (current position), or OCI_FILE_SEEK_END (end of file).
/// offset - The number of bytes from the origin we want to start reading from.
/// dir - The direction we want to go from the origin. NOTE: The direction
/// can be either OCI_FILE_FORWARD or OCI_FILE_BACKWARD.
///
/// Related Function
/// OCIFileOpen, OCIFileRead, OCIFileWrite
///
///
///
/// OCIFileTerm() **********************************
///
/// Name
/// OCIFileTerm - Oracle Call Interface FILE i/o TERMinate
///
/// Purpose
/// Terminate the OCI File I/O package and destroy the OCI File context.
///
/// Syntax
/// sword OCIFileTerm ( void *hndl,
/// OCIError *err )
///
/// Comments
/// After this function has been called no OCIFile function should be used.
/// The function will return OCI_ERROR if any error is encountered, else
/// it will return OCI_ERROR.
///
/// Parameters
/// hndl(IN) - OCI environment or session handle.
/// err(OUT) - OCI error structure.
///
/// Related Functions
/// OCIFileInit
///
///
/// OCIFileWrite() ****************************
///
/// Name
/// OCIFileWrite - Oracle Call Interface FILE i/o WRITE
///
/// Purpose
/// Write data from buffer into a file.
///
/// Syntax
/// sword OCIFileWrite ( void            *hndl,
/// OCIError         *err,
/// OCIFileObject    *filep,
/// void            *bufp,
/// ub4               buflen
/// ub4              *byteswritten )
///
/// Comments
/// The number of bytes written will be in *byteswritten.
/// The function will return OCI_ERROR if any error is encountered, else
/// it will return OCI_ERROR.
///
/// Parameters
/// hndl (IN) - the OCI environment or session handle.
/// err (OUT) - the OCI error handle.  If  there is an error, it is recorded
/// in err and this function returns OCI_ERROR.  Diagnostic information can be
/// obtained by calling OCIErrorGet().
/// filep (IN/OUT) - a file handle that uniquely references the file.
/// bufp (IN) - the pointer to a buffer from which the data will be written.
/// The length of the allocated memory is assumed to be the value passed
/// in bufl.
/// bufl - the length of the buffer in bytes.
/// byteswritten (OUT) - the number of bytes written.
///
/// Related Functions
/// OCIFileOpen, OCIFileSeek, OCIFileRead
///
///
///
///
///
/// OCIHandleAlloc()
/// Name
/// OCI Get HaNDLe
/// Purpose
/// This call returns a pointer to an allocated and initialized handle.
/// Syntax
/// sword OCIHandleAlloc ( const void   *parenth,
/// void         **hndlpp,
/// ub4           type,
/// size_t        xtramem_sz,
/// void         **usrmempp);
/// Comments
/// Returns a pointer to an allocated and initialized structure, corresponding to
/// the type specified in type. A non-NULL handle is returned on success. Bind
/// handle and define handles are allocated with respect to a statement handle. All
/// other handles are allocated with respect to an environment handle which is
/// passed in as a parent handle.
/// No diagnostics are available on error. This call returns OCI_SUCCESS if
/// successful, or OCI_INVALID_HANDLE if an out-of-memory error occurs.
/// Handles must be allocated using OCIHandleAlloc() before they can be passed
/// into an OCI call.
/// Parameters
/// parenth (IN) - an environment or a statement handle.
/// hndlpp (OUT) - returns a handle to a handle type.
/// type (IN) - specifies the type of handle to be allocated. The specific types
/// are:
/// OCI_HTYPE_ERROR - specifies generation of an error report handle of
/// C type OCIError
/// OCI_HTYPE_SVCCTX - specifies generation of a service context handle
/// of C type OCISvcCtx
/// OCI_HTYPE_STMT - specifies generation of a statement (application
/// request) handle of C type OCIStmt
/// OCI_HTYPE_BIND - specifies generation of a bind information handle
/// of C type OCIBind
/// OCI_HTYPE_DEFINE - specifies generation of a column definition
/// handle of C type OCIDefine
/// OCI_HTYPE_DESCRIBE  - specifies generation of a select list
/// description handle of C type OCIDesc
/// OCI_HTYPE_SERVER - specifies generation of a server context handle
/// of C type OCIServer
/// OCI_HTYPE_SESSION - specifies generation of an authentication
/// context handle of C type OCISession
/// OCI_HTYPE_TRANS - specifies generation of a transaction context
/// handle of C type OCITrans
/// OCI_HTYPE_COMPLEXOBJECT - specifies generation of a complex
/// object retrieval handle of C type OCIComplexObject
/// OCI_HTYPE_SECURITY - specifies generation of a security handle of C
/// type OCISecurity
/// xtramem_sz (IN) - specifies an amount of user memory to be allocated.
/// usrmempp (OUT) - returns a pointer to the user memory of size xtramemsz
/// allocated by the call for the user.
/// Related Functions
/// OCIHandleFree()
///
///
///
/// OCIHandleFree()
/// Name
/// OCI Free HaNDLe
/// Purpose
/// This call explicitly deallocates a handle.
/// Syntax
/// sword OCIHandleFree ( void     *hndlp,
/// ub4       type);
/// Comments
/// This call frees up storage associated with a handle, corresponding to the type
/// specified in the type parameter.
/// This call returns either OCI_SUCCESS or OCI_INVALID_HANDLE.
/// All handles must be explicitly deallocated. OCI will not deallocate a child
/// handle if the parent is deallocated.
/// Parameters
/// hndlp (IN) - an opaque pointer to some storage.
/// type (IN) - specifies the type of storage to be allocated. The specific types
/// are:
/// OCI_HTYPE_ENV - an environment handle
/// OCI_HTYPE_ERROR - an error report handle
/// OCI_HTYPE_SVCCTX - a service context handle
/// OCI_HTYPE_STMT - a statement (application request) handle
/// OCI_HTYPE_BIND - a bind information handle
/// OCI_HTYPE_DEFINE - a column definition handle
/// OCI_HTYPE_DESCRIBE  - a select list description handle
/// OCI_HTYPE_SERVER - a server handle
/// OCI_HTYPE_SESSION - a user authentication handle
/// OCI_HTYPE_TRANS - a transaction handle
/// OCI_HTYPE_COMPLEXOBJECT - a complex object retrieval handle
/// OCI_HTYPE_SECURITY - a security handle
/// Related Functions
/// OCIHandleAlloc()
///
///
///
///
/// OCIInitialize()
/// Name
/// OCI Process Initialize
/// Purpose
/// Initializes the OCI process environment.
/// Syntax
/// sword OCIInitialize ( ub4           mode,
/// const void   *ctxp,
/// const void   *(*malocfp)
/// ( void *ctxp,
/// size_t size ),
/// const void   *(*ralocfp)
/// ( void *ctxp,
/// void *memp,
/// size_t newsize ),
/// const void    (*mfreefp)
/// ( void *ctxp,
/// void *memptr ));
/// Comments
/// This call initializes the OCI process environment.
/// OCIInitialize() must be invoked before any other OCI call.
/// Parameters
/// mode (IN) - specifies initialization of the mode. The valid modes are:
/// OCI_DEFAULT - default mode.
/// OCI_THREADED - threaded environment. In this mode, internal data
/// structures are protected from concurrent accesses by multiple threads.
/// OCI_OBJECT - will use navigational object interface.
/// ctxp (IN) - user defined context for the memory call back routines.
/// malocfp (IN) - user-defined memory allocation function. If mode is
/// OCI_THREADED, this memory allocation routine must be thread safe.
/// ctxp - context pointer for the user-defined memory allocation function.
/// size - size of memory to be allocated by the user-defined memory
/// allocation function
/// ralocfp (IN) - user-defined memory re-allocation function. If mode is
/// OCI_THREADED, this memory allocation routine must be thread safe.
/// ctxp - context pointer for the user-defined memory reallocation
/// function.
/// memp - pointer to memory block
/// newsize - new size of memory to be allocated
/// mfreefp (IN) - user-defined memory free function. If mode is
/// OCI_THREADED, this memory free routine must be thread safe.
/// ctxp - context pointer for the user-defined memory free function.
/// memptr - pointer to memory to be freed
/// Example
/// See the description of OCIStmtPrepare() on page 13-96 for an example showing
/// the use of OCIInitialize().
/// Related Functions
///
/// -------------------------------OCITerminate------------------------------------
///
/// OCITerminate()
/// Name
/// OCI process Terminate
/// Purpose
/// Do cleanup before process termination
/// Syntax
/// sword OCITerminate (ub4 mode);
///
/// Comments
/// This call performs  OCI related clean up before the OCI process terminates.
/// If the process is running in shared mode then the OCI process is disconnected
/// from the shared memory subsystem.
///
/// OCITerminate() should be the last OCI call in any process.
///
/// Parameters
/// mode (IN) - specifies different termination modes.
///
/// OCI_DEFAULT - default mode.
///
/// Example
///
/// Related Functions
/// OCIInitialize()
///
/// ------------------------ OCIAppCtxSet--------------------------------------
/// Name
/// OCI Application context Set
/// Purpose
/// Set an attribute and its value for a particular application context
/// namespace
/// Syntax
/// (sword) OCIAppCtxSet((void *) sesshndl, (void *)nsptr,(ub4) nsptrlen,
/// (void *)attrptr, (ub4) attrptrlen, (void *)valueptr,
/// (ub4) valueptrlen,  errhp, (ub4)mode);
///
/// Comments
/// Please note that the information set on the session handle is sent to the
/// server during the next OCIStatementExecute or OCISessionBegin.
///
/// This information is cleared from the session handle, once the information
/// has been sent over to the server,and should be setup again if needed.
///
/// Parameters
/// sesshndl   (IN/OUT) - Pointer to a session handle
/// nsptr      (IN)     - Pointer to namespace string
/// nsptrlen   (IN)     - length of the nsptr
/// attrptr    (IN)     - Pointer to attribute string
/// attrptrlen (IN)     - length of the attrptr
/// valueptr   (IN)     - Pointer to value string
/// valueptrlen(IN)     - length of the valueptr
/// errhp      (OUT)    - Error from the API
/// mode       (IN)     - mode of operation (OCI_DEFAULT)
///
/// Returns
/// error if any
/// Example
///
/// Related Functions
/// OCIAppCtxClearAll
///
///
/// ------------------------ OCIAppCtxClearAll---------------------------------
/// Name
/// OCI Application Context Clear all attributes in a namespace
/// Purpose
/// To clear the  values all attributes in a namespace
/// Syntax
/// (sword) OCIAppCtxClearAll((void *) sesshndl, (void *)nsptr, (ub4) nsptrlen,
/// (OCIError *)errhp, (ub4)mode);
///
/// Comments
/// This will clean up the context information on the server side during the
/// next piggy-back to the server.
///
/// Parameters
/// sesshndl (IN/OUT) - Pointer to a session handle
/// nsptr    (IN)     - Pointer to namespace string where the values of all
/// attributes are cleared
/// nsptrlen (IN)     - length of the nsptr
/// errhp    (OUT)    - Error from the API
/// mode     (IN)     - mode of operation (OCI_DEFAULT)
/// Example
///
/// Returns
/// error if any
///
/// Related Functions
/// OCIAppCtxSet
/// ---------------------- OCIIntervalAssign ---------------------------------
/// sword OCIIntervalAssign(void *hndl, OCIError *err,
/// const OCIInterval *inpinter, OCIInterval *outinter );
///
/// DESCRIPTION
/// Copies one interval to another to create a replica
/// PARAMETERS
/// hndl (IN) - Session/Env handle.
/// err (IN/OUT) - error handle. If there is an error, it is
/// recorded in 'err' and this function returns OCI_ERROR.
/// The error recorded in 'err' can be retrieved by calling
/// OCIErrorGet().
/// (IN)  inpinter - Input Interval
/// (OUT) outinter - Output Interval
/// RETURNS
/// OCI_INVALID_HANDLE if 'err' is NULL.
/// OCI_SUCCESS otherwise
///
/// ---------------------- OCIIntervalCheck ------------------------------------
/// sword OCIIntervalCheck(void *hndl, OCIError *err, const OCIInterval *interval,
/// ub4 *valid );
///
/// DESCRIPTION
/// Checks the validity of an interval
/// PARAMETERS
/// hndl (IN) - Session/Env handle.
/// err (IN/OUT) - error handle. If there is an error, it is
/// recorded in 'err' and this function returns OCI_ERROR.
/// The error recorded in 'err' can be retrieved by calling
/// OCIErrorGet().
/// (IN)  interval - Interval to be checked
/// (OUT) valid     - Zero if the interval is valid, else returns an Ored
/// combination of the following codes.
///
/// Macro name                   Bit number      Error
/// ----------                   ----------      -----
/// OCI_INTER_INVALID_DAY         0x1           Bad day
/// OCI_INTER_DAY_BELOW_VALID     0x2           Bad DAy Low/high bit (1=low)
/// OCI_INTER_INVALID_MONTH       0x4           Bad MOnth
/// OCI_INTER_MONTH_BELOW_VALID   0x8           Bad MOnth Low/high bit (1=low)
/// OCI_INTER_INVALID_YEAR        0x10          Bad YeaR
/// OCI_INTER_YEAR_BELOW_VALID    0x20          Bad YeaR Low/high bit (1=low)
/// OCI_INTER_INVALID_HOUR        0x40          Bad HouR
/// OCI_INTER_HOUR_BELOW_VALID    0x80          Bad HouR Low/high bit (1=low)
/// OCI_INTER_INVALID_MINUTE      0x100         Bad MiNute
/// OCI_INTER_MINUTE_BELOW_VALID  0x200         Bad MiNute Low/high bit(1=low)
/// OCI_INTER_INVALID_SECOND      0x400         Bad SeCond
/// OCI_INTER_SECOND_BELOW_VALID  0x800         bad second Low/high bit(1=low)
/// OCI_INTER_INVALID_FRACSEC     0x1000        Bad Fractional second
/// OCI_INTER_FRACSEC_BELOW_VALID 0x2000        Bad fractional second Low/High
///
///
/// RETURNS
/// OCI_SUCCESS if interval is okay
/// OCI_INVALID_HANDLE if 'err' is NULL.
///
/// ---------------------- OCIIntervalCompare -----------------------------------
/// sword OCIIntervalCompare(void *hndl, OCIError *err, OCIInterval *inter1,
/// OCIInterval *inter2, sword *result );
///
/// DESCRIPTION
/// Compares two intervals, returns 0 if equal, -1 if inter1 < inter2,
/// 1 if inter1 > inter2
/// PARAMETERS
/// hndl (IN) - Session/Env handle.
/// err (IN/OUT) - error handle. If there is an error, it is
/// recorded in 'err' and this function returns OCI_ERROR.
/// The error recorded in 'err' can be retrieved by calling
/// OCIErrorGet().
/// inter1  (IN)   - Interval to be compared
/// inter2  (IN)   - Interval to be compared
/// result  (OUT)  -   comparison result, 0 if equal, -1 if inter1 < inter2,
/// 1 if inter1 > inter2
///
/// RETURNS
/// OCI_SUCCESS on success
/// OCI_INVALID_HANDLE if 'err' is NULL.
/// OCI_ERROR if
/// the two input datetimes are not mutually comparable.
///
/// ---------------------- OCIIntervalDivide ------------------------------------
/// sword OCIIntervalDivide(void *hndl, OCIError *err, OCIInterval *dividend,
/// OCINumber *divisor, OCIInterval *result );
///
/// DESCRIPTION
/// Divides an interval by an Oracle Number to produce an interval
/// PARAMETERS
/// hndl (IN) - Session/Env handle.
/// err (IN/OUT) - error handle. If there is an error, it is
/// recorded in 'err' and this function returns OCI_ERROR.
/// The error recorded in 'err' can be retrieved by calling
/// OCIErrorGet().
/// dividend  (IN)   - Interval to be divided
/// divisor   (IN)   - Oracle Number dividing `dividend'
/// result    (OUT)  - resulting interval (dividend / divisor)
/// RETURNS
/// OCI_SUCCESS on success
/// OCI_INVALID_HANDLE if 'err' is NULL.
///
/// ---------------------- OCIIntervalFromNumber --------------------
/// sword OCIIntervalFromNumber(void *hndl, OCIError *err,
/// OCIInterval *inter, OCINumber *number);
/// DESCRIPTION
/// Converts an interval to an Oracle Number
/// PARAMETERS
/// hndl (IN) - Session/Env handle.
/// err (IN/OUT) - error handle. If there is an error, it is
/// recorded in 'err' and this function returns OCI_ERROR.
/// The error recorded in 'err' can be retrieved by calling
/// OCIErrorGet().
/// (OUT)  interval - Interval to be converted
/// (IN) number - Oracle number result  (in years for YEARMONTH interval
/// and in days for DAYSECOND)
/// RETURNS
/// OCI_SUCCESS on success
/// OCI_INVALID_HANDLE if 'err' is NULL.
/// OCI_ERROR on error.
/// NOTES
/// Fractional portions of the date (for instance, minutes and seconds if
/// the unit chosen is hours) will be included in the Oracle number produced.
/// Excess precision will be truncated.
///
/// ---------------------- OCIIntervalFromText ---------------------------------
/// sword OCIIntervalFromText( void *hndl, OCIError *err, const OraText *inpstr,
/// size_t str_len, OCIInterval *result );
///
/// DESCRIPTION
/// Given an interval string produce the interval represented by the string.
/// The type of the interval is the type of the 'result' descriptor.
/// PARAMETERS
///
/// hndl (IN) - Session/Env handle.
/// err (IN/OUT) - error handle. If there is an error, it is
/// recorded in 'err' and this function returns OCI_ERROR.
/// The error recorded in 'err' can be retrieved by calling
/// OCIErrorGet().
/// (IN)  inpstr - Input string
/// (IN)  str_len - Length of input string
/// (OUT) result - Resultant interval
/// RETURNS
/// OCI_SUCCESS on success
/// OCI_INVALID_HANDLE if 'err' is NULL.
/// OCI_ERROR if
/// there are too many fields in the literal string
/// the year is out of range (-4713 to 9999)
/// if the month is out of range (1 to 12)
/// if the day of month is out of range (1 to 28...31)
/// if hour is not in range (0 to 23)
/// if hour is not in range (0 to 11)
/// if minute is not in range (0 to 59)
/// if seconds in minute not in range (0 to 59)
/// if seconds in day not in range (0 to 86399)
/// if the interval is invalid
///
///
/// ---------------------- OCIIntervalGetDaySecond --------------------
///
/// DESCRIPTION
/// Gets values of day second interval
/// PARAMETERS
/// hndl (IN) - Session/Env handle.
/// err (IN/OUT) - error handle. If there is an error, it is
/// recorded in 'err' and this function returns OCI_ERROR.
/// The error recorded in 'err' can be retrieved by calling
/// OCIErrorGet().
/// day     (OUT) - number of days
/// hour    (OUT) - number of hours
/// min     (OUT) - number of mins
/// sec     (OUT) - number of secs
/// fsec    (OUT) - number of fractional seconds
/// result     (IN)  - resulting interval
/// RETURNS
/// OCI_SUCCESS on success
/// OCI_INVALID_HANDLE if 'err' is NULL.
///
///
/// ---------------------- OCIIntervalGetYearMonth --------------------
///
/// DESCRIPTION
/// Gets year month from an interval
/// PARAMETERS
/// hndl (IN) - Session/Env handle.
/// err (IN/OUT) - error handle. If there is an error, it is
/// recorded in 'err' and this function returns OCI_ERROR.
/// The error recorded in 'err' can be retrieved by calling
/// OCIErrorGet().
/// year    (OUT)   - year value
/// month   (OUT)   - month value
/// result     (IN)  - resulting interval
/// RETURNS
/// OCI_SUCCESS on success
/// OCI_INVALID_HANDLE if 'err' is NULL.
///
///
///
/// -------------------------- OCIIntervalAdd ------------------------------
/// sword OCIIntervalAdd(void *hndl, OCIError *err, OCIInterval *addend1,
/// OCIInterval *addend2, OCIInterval *result );
/// NAME OCIIntervalAdd - Adds two intervals
/// PARAMETERS
/// hndl (IN) - Session/Env handle.
/// err (IN/OUT) - error handle. If there is an error, it is
/// recorded in 'err' and this function returns OCI_ERROR.
/// The error recorded in 'err' can be retrieved by calling
/// OCIErrorGet().
/// addend1  (IN)   - Interval to be added
/// addend2  (IN)   - Interval to be added
/// result   (OUT)  - resulting interval (addend1 + addend2)
/// DESCRIPTION
/// Adds two intervals to produce a resulting interval
/// RETURNS
/// OCI_SUCCESS on success
/// OCI_ERROR if:
/// the two input intervals are not mutually comparable.
/// the resulting year would go above SB4MAXVAL
/// the resulting year would go below SB4MINVAL
/// OCI_INVALID_HANDLE if 'err' is NULL.
/// NOTES
/// The two input intervals must be mutually comparable
///
/// ---------------------- OCIIntervalSubtract -------------------------------
/// sword OCIIntervalSubtract(void *hndl, OCIError *err, OCIInterval *minuend,
/// OCIInterval *subtrahend, OCIInterval *result );
/// NAME - OCIIntervalSubtract - subtracts two intervals
/// PARAMETERS
/// hndl (IN) - Session/Env handle.
/// err (IN/OUT) - error handle. If there is an error, it is
/// recorded in 'err' and this function returns OCI_ERROR.
/// The error recorded in 'err' can be retrieved by calling
/// OCIErrorGet().
/// minuend    (IN)   - interval to be subtracted from
/// subtrahend (IN)   - interval subtracted from minuend
/// result     (OUT)  - resulting interval (minuend - subtrahend)
/// DESCRIPTION
/// Subtracts two intervals and stores the result in an interval
/// RETURNS
/// OCI_SUCCESS on success
/// OCI_INVALID_HANDLE if 'err' is NULL.
/// OCI_ERROR if:
/// the two input intervals are not mutually comparable.
/// the resulting leading field would go below SB4MINVAL
/// the resulting leading field would go above SB4MAXVAL
///
/// ---------------------- OCIIntervalMultiply ---------------------------------
/// sword OCIIntervalMultiply(void *hndl, OCIError *err, const OCIInterval *inter,
/// OCINumber *nfactor, OCIInterval *result );
///
/// DESCRIPTION
/// Multiplies an interval by an Oracle Number to produce an interval
/// PARAMETERS
/// hndl (IN) - Session/Env handle.
/// err (IN/OUT) - error handle. If there is an error, it is
/// recorded in 'err' and this function returns OCI_ERROR.
/// The error recorded in 'err' can be retrieved by calling
/// OCIErrorGet().
/// inter  (IN)   - Interval to be multiplied
/// nfactor  (IN)   - Oracle Number to be multiplied
/// result   (OUT)  - resulting interval (ifactor * nfactor)
/// RETURNS
/// OCI_SUCCESS on success
/// OCI_INVALID_HANDLE if 'err' is NULL.
/// OCI_ERROR if:
/// the resulting year would go above SB4MAXVAL
/// the resulting year would go below SB4MINVAL
///
///
/// ---------------------- OCIIntervalSetDaySecond --------------------
///
/// DESCRIPTION
/// Sets day second interval
/// PARAMETERS
/// hndl (IN) - Session/Env handle.
/// err (IN/OUT) - error handle. If there is an error, it is
/// recorded in 'err' and this function returns OCI_ERROR.
/// The error recorded in 'err' can be retrieved by calling
/// OCIErrorGet().
/// day     (IN) - number of days
/// hour    (IN) - number of hours
/// min     (IN) - number of mins
/// sec     (IN) - number of secs
/// fsec    (IN) - number of fractional seconds
/// result     (OUT)  - resulting interval
/// RETURNS
/// OCI_SUCCESS on success
/// OCI_INVALID_HANDLE if 'err' is NULL.
///
///
/// ---------------------- OCIIntervalSetYearMonth --------------------
///
/// DESCRIPTION
/// Sets year month interval
/// PARAMETERS
/// hndl (IN) - Session/Env handle.
/// err (IN/OUT) - error handle. If there is an error, it is
/// recorded in 'err' and this function returns OCI_ERROR.
/// The error recorded in 'err' can be retrieved by calling
/// OCIErrorGet().
/// year    (IN)   - year value
/// month   (IN)   - month value
/// result     (OUT)  - resulting interval
/// RETURNS
/// OCI_SUCCESS on success
/// OCI_INVALID_HANDLE if 'err' is NULL.
///
///
/// ----------------------- OCIIntervalToNumber ---------------------------------
/// sword OCIIntervalToNumber(void *hndl, OCIError *err, const OCIInterval *inter,
/// OCINumber *number);
///
/// DESCRIPTION
/// Converts an interval to an Oracle Number
/// PARAMETERS
/// hndl (IN) - Session/Env handle.
/// err (IN/OUT) - error handle. If there is an error, it is
/// recorded in 'err' and this function returns OCI_ERROR.
/// The error recorded in 'err' can be retrieved by calling
/// OCIErrorGet().
/// (IN)  inter - Interval to be converted
/// (OUT) number - Oracle number result  (in years for YEARMONTH interval
/// and in days for DAYSECOND)
/// RETURNS
/// OCI_INVALID_HANDLE if 'err' is NULL.
/// OCI_SUCCESS on success
/// NOTES
/// Fractional portions of the date (for instance, minutes and seconds if
/// the unit chosen is hours) will be included in the Oracle number produced.
/// Excess precision will be truncated.
///
/// ------------------------------- OCIIntervalToText -------------------------
/// sword OCIIntervalToText( void *hndl, OCIError *err, const OCIInterval *inter,
/// ub1 lfprec, ub1 fsprec, OraText *buffer,
/// size_t buflen, size_t *resultlen );
///
/// DESCRIPTION
/// Given an interval, produces a string representing the interval.
/// PARAMETERS
/// hndl (IN) - Session/Env handle.
/// err (IN/OUT) - error handle. If there is an error, it is
/// recorded in 'err' and this function returns OCI_ERROR.
/// The error recorded in 'err' can be retrieved by calling
/// OCIErrorGet().
/// (IN)  inter - Interval to be converted
/// (IN)  lfprec  - Leading field precision. Number of digits used to
/// represent the leading field.
/// (IN)  fsprec  - Fractional second precision of the interval. Number of
/// digits used to represent the fractional seconds.
/// (OUT) buffer - buffer to hold result
/// (IN)  buflen - length of above buffer
/// (OUT) resultlen - length of result placed into buffer
///
/// RETURNS
/// OCI_SUCCESS on success
/// OCI_INVALID_HANDLE if 'err' is NULL.
/// OCI_ERROR
/// if the buffer is not large enough to hold the result
/// NOTES
/// The interval literal will be output as `year' or `[year-]month' for
/// YEAR-MONTH intervals and as `seconds' or `minutes[:seconds]' or
/// `hours[:minutes[:seconds]]' or `days[ hours[:minutes[:seconds]]]' for
/// DAY-TIME intervals (where optional fields are surrounded by brackets).
///
/// ---------------------- OCIIntervalFromTZ --------------------
/// sword OCIIntervalFromTZ(void *hndl, OCIError *err, const oratext *inpstring,
/// size_t str_len, OCIInterval *result);
///
/// DESCRIPTION
/// Retuns an OCI_DTYPE_INTERVAL_DS OCIInterval with the region id (if
/// the region is specified in the input string) set and the current
/// absolute offset or an absolut offset with the region id set to 0.
/// PARAMETERS
/// hndl (IN) - Session/Env handle.
/// err (IN/OUT) - error handle. If there is an error, it is
/// recorded in 'err' and this function returns OCI_ERROR.
/// The error recorded in 'err' can be retrieved by calling
/// OCIErrorGet().
/// inpstring (IN) - pointer to the input string
/// str_len (IN) - inpstring length
/// result - Output Interval
/// RETURNS
/// OCI_SUCCESS on success
/// OCI_INVALID_HANDLE if 'err' is NULL.
/// OCI_ERROR on error
/// Bad interval type
/// Timezone errors
/// NOTES
/// The input string must be of the form [+/-]TZH:TZM or 'TZR [TZD]'
///
/// ----------------------- OCIKerbAttrSet ---------------------
/// sword OCIKerbAttrSet(OCISession *trgthndlp, ub4 auth_mode,
/// ub1 *ftgt_ticket, ub4 ftgt_ticket_len,
/// ub1 *ftgt_sesskey, ub4 ftgt_sesskey_len,
/// ub2 ftgt_keytype, ub4 ftgt_ticket_flags,
/// sb4 ftgt_auth_time, sb4 ftgt_start_time,
/// sb4 ftgt_end_time, sb4 ftgt_renew_time,
/// oratext *ftgt_principal, ub4 ftgt_principal_len,
/// oratext *ftgt_realm, ub4 ftgt_realm_len,
/// OCIError *errhp);
///
/// DESCRIPTION
/// This call sets the attributes required for Kerberos authentication
/// on the user handle.
///
/// PARAMETERS
/// trgthndlp (IN) - The pointer to a user handle.
/// auth_mode (IN) - Indicates what type of Kerberos credentials should
/// be set. Options are:
///
/// OCI_KERBCRED_PROXY
/// - Set Kerberos credentials for use with
/// proxy authentication.
/// OCI_KERBCRED_CLIENT_IDENTIFIER
/// - Set Kerberos credentials for use
/// with secure client identifier.
///
/// ftgt_ticket (IN) - Forwardable Ticket Granting Ticket (FTGT).
/// ftgt_ticket_len (IN) - Length of FTGT.
/// ftgt_sesskey(IN) - Session Key associated with FTGT.
/// ftgt_sesskey_len (IN) - Length of session key.
/// ftgt_keytype (IN) -  Type of encryption key used to encrypt FTGT.
/// ftgt_ticket_flags (IN) - Flags associated with  encryption of FTGT.
/// ftgt_auth_time (IN) - Authentication time compatible with that in FTGT.
/// ftgt_start_time (IN) - Start time compatible with that indicated in FTGT.
/// ftgt_end_time (IN) - End time compatible with that indicated in FTGT.
/// ftgt_renew_time (IN) - Renew time compatible with that indicated in FTGT.
/// ftgt_principal (IN) - Client principal name from FTGT.
/// ftgt_principal_len (IN) - Length of client principal name.
/// ftgt_realm (IN) - Client realm name from FTGT.
/// ftgt_realm_len (IN) - Client realm name length.
/// errhp (IN/OUT) - error handle. If there is an error, it is
/// recorded in 'err' and this function returns OCI_ERROR.
/// The error recorded in 'err' can be retrieved by calling
/// OCIErrorGet().
/// RETURNS
/// OCI_SUCCESS on success
/// OCI_ERROR on error
/// NOTES
///
/// OCILdaToSvcCtx()
/// Name
/// OCI toggle version 7 Lda_Def to SerVice context handle
/// Purpose
/// Converts a V7 Lda_Def to a V8 service context handle.
/// Syntax
/// sword OCILdaToSvcCtx ( OCISvcCtx  **svchpp,
/// OCIError   *errhp,
/// Lda_Def    *ldap );
/// Comments
/// Converts a V7 Lda_Def to a V8 service context handle. The action of this call
/// can be reversed by passing the resulting service context handle to the
/// OCISvcCtxToLda() function.
/// Parameters
/// svchpp (IN/OUT) - the service context handle.
/// errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
/// diagnostic information in the event of an error.
/// ldap (IN/OUT) - the V7 logon data area returned by OCISvcCtxToLda() from
/// this service context.
/// Related Functions
/// OCISvcCtxToLda()
///
///
///
///
/// OCILobAppend()
///
/// Name
/// OCI Lob APpend
///
/// Purpose
/// Appends a LOB value at the end of another LOB.
///
/// Syntax
/// sword OCILobAppend ( OCISvcCtx        *svchp,
/// OCIError         *errhp,
/// OCILobLocator    *dst_locp,
/// OCILobLocator    *src_locp );
/// Comments
/// Appends a LOB value at the end of LOB. The data is
/// copied from the source to the destination at the end of the destination. The
/// source and the destination must already exist. The destination LOB is
/// extended to accommodate the newly written data.
///
/// It is an error to extend the destination LOB beyond the maximum length
/// allowed or to try to copy from a NULL LOB.
///
/// Parameters
/// svchp (IN) - the service context handle.
/// errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
/// diagnostic information in the event of an error.
/// dst_locp (IN/OUT) - a locator uniquely referencing the destination LOB.
/// src_locp (IN/OUT) - a locator uniquely referencing the source LOB.
///
/// Related Functions
/// OCILobTrim()
/// OCIErrorGet()
/// OCILobWrite()
/// OCILobCopy()
///
///
///
/// OCILobAssign()
///
/// Name
/// OCI Lob ASsiGn
///
/// Purpose
/// Assigns one LOB/FILE locator to another.
///
/// Syntax
/// sword OCILobAssign ( OCIEnv                *envhp,
/// OCIError              *errhp,
/// const OCILobLocator   *src_locp,
/// OCILobLocator         **dst_locpp );
///
/// Comments
/// Assign source locator to destination locator.  After the assignment, both
/// locators refer to the same LOB data.  For internal LOBs, the source locator's
/// LOB data gets copied to the destination locator's LOB data only when the
/// destination locator gets stored in the table.  Therefore, issuing a flush of
/// the object containing the destination locator will copy the LOB data. For
/// FILEs only the locator that refers to the OS file is copied to the table. The
/// OS file is not copied.
/// Note: The only difference between this and OCILobLocatorAssign is that this
/// takes an environment handle whereas OCILobLocatorAssign takes an OCI service
/// handle
///
/// Parameters
/// envhp (IN/OUT) - OCI environment handle initialized in object mode.
/// errhp (IN/OUT) - The OCI error handle. If there is an error, it is recorded
/// in errhp and this function returns OCI_ERROR. Diagnostic information can be
/// obtained by calling OCIErrorGet().
/// src_locp (IN) - LOB locator to copy from.
/// dst_locpp (IN/OUT) - LOB locator to copy to.  The caller must allocate space
/// for the OCILobLocator by calling OCIDescriptorAlloc().
///
/// See also
/// OCIErrorGet()
/// OCILobIsEqual()
/// OCILobLocatorIsInit()
/// OCILobLocatorAssign()
///
///
/// OCILobCharSetForm()
///
/// Name
/// OCI Lob Get Character Set Form
///
/// Purpose
/// Gets the LOB locator's character set fpr,, if any.
///
/// Syntax
/// sword OCILobCharSetForm ( OCIEnv                    *envhp,
/// OCIError                  *errhp,
/// const OCILobLocator       *locp,
/// ub1                       *csfrm );
///
/// Comments
/// Returns the character set form of the input LOB locator in the csfrm output
/// parameter.
///
/// Parameters
/// envhp (IN/OUT) - OCI environment handle initialized in object mode.
/// errhp (IN/OUT) - error handle. The OCI error handle. If there is an error, it
/// is recorded in err and this function returns OCI_ERROR. Diagnostic
/// information can be obtained by calling OCIErrorGet().
/// locp (IN) - LOB locator for which to get the character set form.
/// csfrm(OUT) - character set form of the input LOB locator.  If the input
/// locator is for a BLOB or a BFILE, csfrm is set to 0 since there is no concept
/// of a character set for binary LOBs/FILEs.  The caller must allocate space for
/// the csfrm (ub1) and not write into the space.
/// See also
/// OCIErrorGet(), OCILobCharSetId(), OCILobLocatorIsInit
///
///
///
/// OCILobCharSetId()
///
/// Name
/// OCI Lob get Character Set IDentifier
///
/// Purpose
/// Gets the LOB locator's character set ID, if any.
///
/// Syntax
/// sword OCILobCharSetId ( OCIEnv                    *envhp,
/// OCIError                  *errhp,
/// const OCILobLocator       *locp,
/// ub2                       *csid );
///
/// Comments
/// Returns the character set ID of the input LOB locator in the cid output
/// parameter.
///
/// Parameters
/// envhp (IN/OUT) - OCI environment handle initialized in object mode.
/// errhp (IN/OUT) - error handle. The OCI error handle. If there is an error, it
/// is recorded in err and this function returns OCI_ERROR. Diagnostic
/// information can be obtained by calling OCIErrorGet().
/// locp (IN) - LOB locator for which to get the character set ID.
/// csid (OUT) - character set ID of the input LOB locator.  If the input locator
/// is for a BLOB or a BFILE, csid is set to 0 since there is no concept of a
/// character set for binary LOBs/FILEs.  The caller must allocate space for the
/// character set id of type ub2 and not write into the space.
///
/// See also
/// OCIErrorGet(), OCILobCharSetForm(), OCILobLocatorIsInit()
///
///
///
/// OCILobCopy()
///
/// Name
/// OCI Lob Copy
///
/// Purpose
/// Copies a portion of a LOB value into another LOB value.
///
/// Syntax
/// sword OCILobCopy ( OCISvcCtx        *svchp,
/// OCIError         *errhp,
/// OCILobLocator    *dst_locp,
/// OCILobLocator    *src_locp,
/// ub4              amount,
/// ub4              dst_offset,
/// ub4              src_offset );
///
/// Comments
/// Copies a portion of a LOB value into another LOB as specified. The data
/// is copied from the source to the destination. The source (src_locp) and the
/// destination (dlopb) LOBs must already exist.
/// If the data already exists at the destination's start position, it is
/// overwritten with the source data. If the destination's start position is
/// beyond the end of the current data, a hole is created from the end of the data
/// to the beginning of the newly written data from the source. The destination
/// LOB is extended to accommodate the newly written data if it extends
/// beyond the current length of the destination LOB.
/// It is an error to extend the destination LOB beyond the maximum length
/// allowed or to try to copy from a NULL LOB.
/// Parameters
/// svchp (IN) - the service context handle.
/// errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
/// diagnostic information in the event of an error.
/// dst_locp (IN/OUT) - a locator uniquely referencing the destination LOB.
/// src_locp (IN/OUT) - a locator uniquely referencing the source LOB.
/// amount (IN) - the number of character or bytes, as appropriate, to be copied.
/// dst_offset (IN) - this is the absolute offset for the destination LOB.
/// For character LOBs it is the number of characters from the beginning of the
/// LOB at which to begin writing. For binary LOBs it is the number of bytes from
/// the beginning of the lob from which to begin reading. The offset starts at 1.
/// src_offset (IN) - this is the absolute offset for the source LOB.
/// For character LOBs it is the number of characters from the beginning of the
/// LOB, for binary LOBs it is the number of bytes. Starts at 1.
///
/// See Also
/// OCIErrorGet(), OCILobAppend(), OCILobWrite(), OCILobTrim()
///
/// OCILobCreateTemporary()
///
/// Name
/// OCI Lob Create Temporary
///
/// Purpose
/// Create a Temporary Lob
///
/// Syntax
/// sword OCILobCreateTemporary(OCISvcCtx          *svchp,
/// OCIError           *errhp,
/// OCILobLocator      *locp,
/// ub2                 csid,
/// ub1                 csfrm,
/// ub1                 lobtype,
/// boolean             cache,
/// OCIDuration         duration);
///
///
/// Comments
/// svchp (IN) - the service context handle.
/// errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
/// diagnostic information in the event of an error.
/// locp (IN/OUT) - a locator which points to the temporary Lob
/// csid (IN) - the character set id
/// csfrm(IN) - the character set form
/// lobtype (IN) - the lob type - one of the three constants OCI_TEMP_BLOB,
/// OCI_TEMP_CLOB and OCI_TEMP_NCLOB
/// cache(IN)-  TRUE if the temporary LOB goes through the cache; FALSE, if not.
/// duration(IN)- duration of the temporary LOB; Can be a valid duration id or one
/// of the values: OCI_DURATION_SESSION, OCI_DURATION_CALL
/// Note: OCI_DURATION_TRANSACTION is NOT supported in 8.1
/// Related functions
/// OCILobFreeTemporary()
/// OCILobIsTemporary()
///
/// OCILobDisableBuffering()
///
/// Name
/// OCI Lob Disable Buffering
///
/// Purpose
/// Disable lob buffering for the input locator.
///
///
/// Syntax
/// sword OCILobDisableBuffering ( OCISvcCtx      *svchp,
/// OCIError       *errhp,
/// OCILobLocator  *locp);
///
/// Comments
///
/// Disable lob buffering for the input locator.  The next time data is
/// read/written from/to the lob through the input locator, the lob
/// buffering subsystem is *not* used.  Note that this call does *not*
/// implicitly flush the changes made in the buffering subsystem.  The
/// user must explicitly call OCILobFlushBuffer() to do this.
///
/// Parameters
/// svchp (IN) - the service context handle.
/// errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
/// diagnostic information in the event of an error.
/// locp (IN/OUT) - a locator uniquely referencing the LOB.
///
/// Related Functions
/// OCILobEnableBuffering()
/// OCIErrorGet()
/// OCILobFlushBuffer()
///
///
///
///
/// OCILobEnableBuffering()
///
/// Name
/// OCI Lob Enable Buffering
///
/// Purpose
/// Enable lob buffering for the input locator.
///
///
/// Syntax
/// sword OCILobEnableBuffering ( OCISvcCtx      *svchp,
/// OCIError       *errhp,
/// OCILobLocator  *locp);
///
/// Comments
///
/// Enable lob buffering for the input locator.  The next time data is
/// read/written from/to the lob through the input locator, the lob
/// buffering subsystem is used.
///
/// Once lob buffering is enabled for a locator, if that locator is passed to
/// one of the following routines, an error is returned:
/// OCILobCopy, OCILobAppend, OCILobErase, OCILobGetLength, OCILobTrim
///
/// Parameters
/// svchp (IN) - the service context handle.
/// errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
/// diagnostic information in the event of an error.
/// locp (IN/OUT) - a locator uniquely referencing the LOB.
///
/// Related Functions
/// OCILobDisableBuffering()
/// OCIErrorGet()
/// OCILobWrite()
/// OCILobRead()
/// OCILobFlushBuffer()
///
///
///
///
/// OCILobErase()
///
/// Name
/// OCI Lob ERase
///
/// Purpose
/// Erases a specified portion of the LOB data starting at a specified offset.
///
/// Syntax
/// sword OCILobErase ( OCISvcCtx       *svchp,
/// OCIError        *errhp,
/// OCILobLocator   *locp,
/// ub4             *amount,
/// ub4             offset );
///
/// Comments
/// Erases a specified portion of the LOB data starting at a specified offset.
/// The actual number of characters/bytes erased is returned. The actual number
/// of characters/bytes and the requested number of characters/bytes will differ
/// if the end of the LOB data is reached before erasing the requested number of
/// characters/bytes.
/// If a section of data from the middle of the LOB data is erased, a hole is
/// created. When data from that hole is read, 0's are returned. If the LOB is
/// NULL, this routine will indicate that 0 characters/bytes were erased.
///
/// Parameters
/// svchp (IN) - the service context handle.
/// errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
/// diagnostic information in the event of an error.
/// locp (IN/OUT) - the LOB for which to erase a section of data.
/// amount (IN/OUT) - On IN, the number of characters/bytes to erase. On OUT,
/// the actual number of characters/bytes erased.
/// offset (IN) - absolute offset from the beginning of the LOB data from which
/// to start erasing data. Starts at 1.
///
/// See Also
/// OCIErrorGet(), OCILobRead(), OCILobWrite()
///
/// OCILobOpen()
///
/// Name
/// OCI Lob Open
///
/// Purpose
/// Opens an internal or external Lob.
///
/// Syntax
/// sword OCILobOpen( OCISvcCtx        *svchp,
/// OCIError         *errhp,
/// OCILobLocator    *locp,
/// ub1               mode );
///
/// Comments
/// It is an error if the same lob is opened more than once in
/// the same transaction. Lobs are opened implicitly if they are
/// not opened before using them. A LOB has to be closed before
/// the transaction commits else the transaction is rolled back.
/// Open locators are closed if the transaction aborts. Multiple
/// users can open the same lob on different locators.
/// Parameters
/// svchp (IN) - the service context handle.
/// errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
/// diagnostic information in the event of an error.
/// locp (IN/OUT) - locator points to the LOB to be opened
/// mode (IN) - mode in which to open the lob. The valid modes are
/// read-only - OCI_FILE_READONLY, read-write - OCI_FILE_READWRITE
///
/// OCILobClose()
///
/// Name
/// OCI Lob Close
///
/// Purpose
/// Closes an open internal or external Lob.
///
/// Syntax
/// sword OCILobClose( OCISvcCtx        *svchp,
/// OCIError         *errhp,
/// OCILobLocator    *locp );
///
///
/// Comments
/// It is an error if the lob is not open at this time. All LOBs
/// that have been opened in a transaction have to be closed
/// before the transaction commits, else the transaction gets
/// rolled back.
///
/// Parameters
/// svchp (IN) - the service context handle.
/// errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
/// diagnostic information in the event of an error.
/// locp  (IN)  - A locator that was opened using OCILobOpen()
///
///
/// OCILobFileClose()
///
/// Name
/// OCI Lob File CLoSe
///
/// Purpose
/// Closes a previously opened FILE.
///
/// Syntax
/// sword OCILobFileClose ( OCISvcCtx            *svchp,
/// OCIError             *errhp,
/// OCILobLocator        *filep );
///
/// Comments
/// Closes a previously opened FILE. It is an error if this function is called for
/// an internal LOB. No error is returned if the FILE exists but is not opened.
/// Parameters
/// svchp (IN) - the service context handle.
/// errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
/// diagnostic information in the event of an error.
/// filep (IN/OUT) - a pointer to a FILE locator to be closed.
///
/// See Also
/// OCIErrorGet(), OCILobFileOpen(), OCILobFileCloseAll(), OCILobFileIsOpen(),
/// OCILobFileExists(), CREATE DIRECTORY DDL
///
///
///
///
/// OCILobFileCloseAll()
///
/// Name
/// OCI LOB FILE Close All
///
/// Purpose
/// Closes all open FILEs on a given service context.
///
/// Syntax
/// sword OCILobFileCLoseAll ( OCISvcCtx *svchp,
/// OCIError  *errhp );
///
/// Comments
/// Closes all open FILEs on a given service context.
///
/// Parameters
/// svchp (IN) - the service context handle.
/// errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
/// diagnostic information in the event of an error.
///
/// See also
/// OCILobFileClose(),
/// OCIErrorGet(), OCILobFileOpen(), OCILobFileIsOpen(),
/// OCILobFileExists(), CREATE DIRECTORY DDL
///
///
///
///
/// OCILobFileExists()
///
/// Name
/// OCI LOB FILE exists
///
/// Purpose
/// Tests to see if the FILE exists on the server
///
/// Syntax
/// sword OCILobFileExists ( OCISvcCtx     *svchp,
/// OCIError      *errhp,
/// OCILobLocator *filep,
/// boolean       *flag );
///
/// Comments
/// Checks to see if a FILE exists for on the server.
///
/// Parameters
/// svchp (IN) - the OCI service context handle.
/// errhp (IN/OUT) - error handle. The OCI error handle. If there is an error,
/// it is recorded in err and this function returns OCI_ERROR. Diagnostic
/// information can be obtained by calling OCIErrorGet().
/// filep (IN) - pointer to the FILE locator that refers to the file.
/// flag (OUT) - returns TRUE if the FILE exists; FALSE if it does not.
///
/// See also
/// OCIErrorGet, CREATE DIRECTORY (DDL)
///
///
///
///
/// OCILobFileGetName()
///
/// Name
/// OCI LOB FILE Get file Name
///
/// Purpose
/// Gets the FILE locator's directory alias and file name.
///
/// Syntax
/// sword OCILobFileGetName ( OCIEnv                   *envhp,
/// OCIError                 *errhp,
/// const OCILobLocator      *filep,
/// OraText                     *dir_alias,
/// ub2                      *d_length,
/// OraText                     *filename,
/// ub2                      *f_length );
///
/// Comments
/// Returns the directory alias and file name associated with this file locator.
///
/// Parameters
/// envhp (IN/OUT) - OCI environment handle initialized in object mode.
/// errhp (IN/OUT) -The OCI error handle. If there is an error, it is recorded in
/// errhp and this function returns OCI_ERROR. Diagnostic information can be
/// obtained by calling OCIErrorGet().
/// filep (IN) - FILE locator for which to get the directory alias and file name.
/// dir_alias (OUT) - buffer into which the directory alias name is placed. The
/// caller must allocate enough space for the directory alias name and must not
/// write into the space.
/// d_length (IN/OUT)
/// - IN: length of the input dir_alias string;
/// - OUT: length of the returned dir_alias string.
/// filename (OUT) - buffer into which the file name is placed. The caller must
/// allocate enough space for the file name and must not write into the space.
/// f_length (IN/OUT)
/// - IN: length of the input filename string;
/// - OUT: lenght of the returned filename string.
///
/// See also
/// OCILobFileSetName(), OCIErrorGet()
///
///
///
///
/// OCILobFileIsOpen()
///
/// Name
/// OCI LOB FILE Is Open?
///
/// Purpose
/// Tests to see if the FILE is open
///
/// Syntax
/// sword OCILobFileIsOpen ( OCISvcCtx *svchp,
/// OCIError  *errhp,
/// OCILobLocator *filep,
/// boolean       *flag );
///
/// Comments
/// Checks to see if the FILE on the server is open for a given LobLocator.
///
/// Parameters
/// svchp (IN) - the OCI service context handle.
/// errhp (IN/OUT) - error handle. The OCI error handle. If there is an error, it
/// is recorded in err and this function returns OCI_ERROR. Diagnostic
/// information can be obtained by calling OCIErrorGet().
/// filep (IN) - pointer to the FILE locator being examined. If the input file
/// locator was never passed to OCILobFileOpen(), the file is considered not to
/// be opened by this locator. However, a different locator may have opened the
/// file. More than one file opens can be performed on the same file using
/// different locators.
/// flag (OUT) - returns TRUE if the FILE is opened using this locator; FALSE if
/// it is not.
///
/// See also
/// OCIErrorGet, OCILobFileOpen, OCILobFileClose, OCILobFileCloseAll, CREATE
/// DIRECTORY SQL command
///
///
/// OCILobFileOpen()
///
/// Name
/// OCI LOB FILE open
///
/// Purpose
/// Opens a FILE for read-only access
///
/// Syntax
/// sword OCILobFileOpen ( OCISvcCtx            *svchp,
/// OCIError             *errhp,
/// OCILobLocator        *filep,
/// ub1                  mode );
///
/// Comments
/// Opens a FILE. The FILE can be opened for read-only access only. FILEs may not
/// be written to throough ORACLE.
///
/// Parameters
/// svchp (IN) - the service context handle.
/// errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
/// diagnostic information in the event of an error.
/// filep (IN/OUT) - the FILE to open. Error if the locator does not refer to a
/// FILE.
/// mode (IN) - mode in which to open the file. The only valid mode is
/// read-only - OCI_FILE_READONLY.
///
/// See Also
/// OCILobFileClose, OCIErrorGet, OCILobFileCloseAll, OCILobFileIsOpen,
/// OCILobFileSetName, CREATE DIRECTORY
///
///
///
///
/// OCILobFileSetName()
///
/// Name
/// OCI Lob File Set NaMe
///
/// Purpose
/// Sets directory alias and file name in the FILE locator.
///
/// Syntax
/// sword OCILobFileSetName ( OCIEnv             *envhp,
/// OCIError           *errhp,
/// OCILobLocator      **filepp,
/// OraText               *dir_alias,
/// ub2                d_length,
/// OraText               *filename,
/// ub2                f_length );
/// Comments
/// Sets the directory alias and file name in the LOB file locator.
/// Parameters
/// envhp (IN/OUT) - OCI environment handle initialized in object mode.
/// errhp (IN/OUT) - The OCI error handle. If there is an error, it is recorded
/// in errhp and this function returns OCI_ERROR. Diagnostic information can be
/// obtained by calling OCIErrorGet().
/// filepp (IN/OUT) - FILE locator for which to set the directory alias name.
/// The caller must have already allocated space for the locator by calling
/// OCIDescriptorAlloc().
/// dir_alias (IN) - buffer that contains the directory alias name to set in the
/// locator.
/// d_length (IN) - length of the input dir_alias parameter.
/// filename (IN) - buffer that contains the file name is placed.
/// f_length (IN) - length of the input filename parameter.
/// See also
/// OCILobFileGetName, OCIErrorGet, CREATE DIRECTORY
///
///
///
///
/// OCILobFlushBuffer()
///
/// Name
/// OCI Lob Flush all Buffers for this lob.
///
/// Purpose
/// Flush/write all buffers for this lob to the server.
///
///
/// Syntax
/// sword OCILobFlushBuffer ( OCISvcCtx       *svchp,
/// OCIError        *errhp,
/// OCILobLocator   *locp,
/// ub4              flag);
///
/// Comments
///
/// Flushes to the server, changes made to the buffering subsystem that
/// are associated with the lob referenced by the input locator.  This
/// routine will actually write the data in the buffer to the lob in
/// the database.  Lob buffering must have already been enabled for the
/// input lob locator.
///
/// This routine, by default, does not free the buffer resources for
/// reallocation to another buffered LOB operation. However, if you
/// want to free the buffer explicitly, you can set the flag parameter
/// to OCI_LOB_BUFFER_FREE.
///
/// Parameters
/// svchp (IN/OUT) - the service context handle.
/// errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
/// diagnostic information in the event of an error.
/// locp (IN/OUT) - a locator uniquely referencing the LOB.
/// flag    (IN)     - to indicate if the buffer resources need to be freed
/// after a flush. Default value is OCI_LOB_BUFFER_NOFREE.
/// Set it to OCI_LOB_BUFFER_FREE if you want the buffer
/// resources to be freed.
/// Related Functions
/// OCILobEnableBuffering()
/// OCILobDisableBuffering()
/// OCIErrorGet()
/// OCILobWrite()
/// OCILobRead()
///
///
/// OCILobFreeTemporary()
///
/// Name
/// OCI Lob Free Temporary
///
/// Purpose
/// Free a temporary LOB
///
/// Syntax
/// sword OCILobFreeTemporary(OCISvcCtx          *svchp,
/// OCIError           *errhp,
/// OCILobLocator      *locp);
///
/// Comments
/// Frees the contents of the temporary Lob this locator is pointing to. Note
/// that the locator itself is not freed until a OCIDescriptorFree is done.
///
/// Parameters
/// svchp (IN/OUT) - the service context handle.
/// errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
/// diagnostic information in the event of an error.
/// locp (IN/OUT) - a locator uniquely referencing the LOB
///
/// Related functions
/// OCILobCreateTemporary()
/// OCILobIsTemporary()
///
///
/// Name
/// OCI Lob/File Get Chunk Size
///
/// Purpose
/// When creating the table, the user can specify the chunking factor, which can
/// be a multiple of Oracle blocks. This corresponds to the chunk size used by the
/// LOB data layer when accessing/modifying the LOB value. Part of the chunk is
/// used to store system-related information and the rest stores the LOB value.
/// This function returns the amount of space used in the LOB chunk to store
/// the LOB value.
///
/// Syntax
/// sword OCILobGetChunkSize ( OCISvcCtx      *svchp,
/// OCIError       *errhp,
/// OCILobLocator  *locp,
/// ub4            *chunksizep );
///
/// Comments
/// Performance will be improved if the user issues read/write
/// requests using a multiple of this chunk size. For writes, there is an added
/// benefit since LOB chunks are versioned and, if all writes are done on chunk
/// basis, no extra/excess versioning is done nor duplicated. Users could batch
/// up the write until they have enough for a chunk instead of issuing several
/// write calls for the same chunk.
///
/// Parameters
/// svchp (IN) - the service context handle.
/// errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
/// diagnostic information in the event of an error.
/// locp (IN/OUT) - a LOB locator that uniquely references the LOB. For internal
/// LOBs, this locator must be a locator that was obtained from the server
/// specified by svchp. For FILEs, this locator can be initialized by a Select or
/// OCILobFileSetName.
/// chunksizep (OUT) - On output, it is the length of the LOB if not NULL - for
/// character LOBs it is the number of characters, for binary LOBs it is the
/// number of bytes in the LOB.
///
/// Related Functions
///
/// OCILobGetLength()
///
/// Name
/// OCI Lob/File Length
///
/// Purpose
/// Gets the length of a LOB/FILE.
///
/// Syntax
/// sword OCILobGetLength ( OCISvcCtx      *svchp,
/// OCIError       *errhp,
/// OCILobLocator  *locp,
/// ub4            *lenp );
///
/// Comments
/// Gets the length of a LOB/FILE. If the LOB/FILE is NULL, the length is
/// undefined.
///
/// Parameters
/// svchp (IN) - the service context handle.
/// errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
/// diagnostic information in the event of an error.
/// locp (IN/OUT) - a LOB locator that uniquely references the LOB. For internal
/// LOBs, this locator must be a locator that was obtained from the server
/// specified by svchp. For FILEs, this locator can be initialized by a Select or
/// OCILobFileSetName.
/// lenp (OUT) - On output, it is the length of the LOB if not NULL - for
/// character LOBs it is the number of characters, for binary LOBs it is the
/// number of bytes in the LOB.
///
/// Related Functions
/// OCIErrorGet, OCIFileSetName
///
///
///
/// OCILobIsEqual()
///
/// Name
///
/// OCI Lob Is Equal
///
/// Purpose
/// Compares two LOB locators for equality.
///
/// Syntax
/// sword OCILobIsEqual ( OCIEnv                  *envhp,
/// const OCILobLocator     *x,
/// const OCILobLocator     *y,
/// boolean                 *is_equal );
///
/// Comments
/// Compares the given LOB locators for equality.  Two LOB locators are equal if
/// and only if they both refer to the same LOB data.
/// Two NULL locators are considered not equal by this function.
/// Parameters
/// envhp (IN) - the OCI environment handle.
/// x (IN) - LOB locator to compare.
/// y (IN) - LOB locator to compare.
/// is_equal (OUT) - TRUE, if the LOB locators are equal; FALSE if they are not.
///
/// See also
/// OCILobAssign, OCILobLocatorIsInit
/// OCILobLocatorAssign,
/// OCILobIsOpen()
///
/// Name
///
/// OCI Lob Is Open
/// sword OCILobIsOpen(svchp, errhp, locp, flag)
/// OCISvcCtx     *svchp;
/// OCIError      *errhp;
/// OCILobLocator *locp;
/// boolean       *flag;
///
/// Comments
/// Checks if the LOB locator was opened before. flag is set to TRUE
/// if opened; FALSE otherwise
///
///
/// Parameters
/// svchp (IN) - the service context handle.
/// errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
/// diagnostic information in the event of an error.
/// locp (IN) - the locator to test for temporary LOB
/// flag(OUT) - TRUE, if the LOB locator points to is open
/// FALSE, if not.
///
/// OCILobIsTemporary()
///
/// Name
///
/// OCI Lob Is Temporary
///
/// Purpose
/// Tests if this locator points to a temporary LOB
///
/// Syntax
/// sword OCILobIsTemporary(OCIEnv            *envhp,
/// OCIError          *errhp,
/// OCILobLocator     *locp,
/// boolean           *is_temporary);
///
/// Comments
/// Tests the locator to determine if it points to a temporary LOB.
/// If so, is_temporary is set to TRUE. If not, is_temporary is set
/// to FALSE.
///
/// Parameters
/// envhp (IN) - the environment handle.
/// errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
/// diagnostic information in the event of an error.
/// locp (IN) - the locator to test for temporary LOB
/// is_temporary(OUT) - TRUE, if the LOB locator points to a temporary LOB;
/// FALSE, if not.
///
/// See Also
/// OCILobCreateTemporary, OCILobFreeTemporary
///
///
/// OCILobLoadFromFile()
///
/// Name
/// OCI Lob Load From File
///
/// Purpose
/// Load/copy all or a portion of the file into an internal LOB.
///
/// Syntax
/// sword OCILobLoadFromFile ( OCISvcCtx        *svchp,
/// OCIError         *errhp,
/// OCILobLocator    *dst_locp,
/// OCILobLocator    *src_filep,
/// ub4              amount,
/// ub4              dst_offset,
/// ub4              src_offset );
///
/// Comments
/// Loads/copies a portion or all of a file value into an internal LOB as
/// specified.  The data is copied from the source file to the destination
/// internal LOB (BLOB/CLOB).  No character set conversions are performed
/// when copying the bfile data to a clob/nclob.  The bfile data must already
/// be in the same character set as the clob/nclob in the database.  No
/// error checking is performed to verify this.
/// The source (src_filep) and the destination (dst_locp) LOBs must already exist.
/// If the data already exists at the destination's start position, it is
/// overwritten with the source data. If the destination's start position is
/// beyond the end of the current data, a hole is created from the end of the data
/// to the beginning of the newly written data from the source. The destination
/// LOB is extended to accommodate the newly written data if it extends
/// beyond the current length of the destination LOB.
/// It is an error to extend the destination LOB beyond the maximum length
/// allowed or to try to copy from a NULL LOB.
/// Parameters
/// svchp (IN) - the service context handle.
/// errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
/// diagnostic information in the event of an error.
/// dst_locp (IN/OUT) - a locator uniquely referencing the destination internal
/// LOB which may be of type blob, clob, or nclob.
/// src_filep (IN/OUT) - a locator uniquely referencing the source BFILE.
/// amount (IN) - the number of bytes to be copied.
/// dst_offset (IN) - this is the absolute offset for the destination LOB.
/// For character LOBs it is the number of characters from the beginning of the
/// LOB at which to begin writing. For binary LOBs it is the number of bytes from
/// the beginning of the lob from which to begin reading. The offset starts at 1.
/// src_offset (IN) - this is the absolute offset for the source BFILE.  It is
/// the number of bytes from the beginning of the LOB.  The offset starts at 1.
///
/// See Also
/// OCIErrorGet(), OCILobAppend(), OCILobWrite(), OCILobTrim(), OCILobCopy()
///
/// OCILobLocatorAssign()
///
/// Name
/// OCI Lob LOCATOR ASsiGn
///
/// Purpose
/// Assigns one LOB/FILE locator to another.
///
/// Syntax
/// sword OCILobLocatorAssign ( OCISvcCtx             *svchp,
/// OCIError              *errhp,
/// const OCILobLocator   *src_locp,
/// OCILobLocator         **dst_locpp );
///
/// Comments
/// Assign source locator to destination locator.  After the assignment, both
/// locators refer to the same LOB data.  For internal LOBs, the source locator's
/// LOB data gets copied to the destination locator's LOB data only when the
/// destination locator gets stored in the table.  Therefore, issuing a flush of
/// the object containing the destination locator will copy the LOB data. For
/// FILEs only the locator that refers to the OS file is copied to the table. The
/// OS file is not copied.
/// Note : the only difference between this and OCILobAssign is that this takes
/// a OCI service handle pointer instead of a OCI environment handle pointer
///
/// Parameters
/// svchp (IN/OUT) - OCI service handle initialized in object mode.
/// errhp (IN/OUT) - The OCI error handle. If there is an error, it is recorded
/// in errhp and this function returns OCI_ERROR. Diagnostic information can be
/// obtained by calling OCIErrorGet().
/// src_locp (IN) - LOB locator to copy from.
/// dst_locpp (IN/OUT) - LOB locator to copy to.  The caller must allocate space
/// for the OCILobLocator by calling OCIDescriptorAlloc().
///
/// See also
/// OCIErrorGet()
/// OCILobIsEqual()
/// OCILobLocatorIsInit()
/// OCILobAssign()
///
///
///
///
/// OCILobLocatorIsInit()
///
/// Name
/// OCI LOB locator is initialized?
///
/// Purpose
/// Tests to see if a given LOB locator is initialized.
///
/// Syntax
/// sword OCILobLocatorIsInit ( OCIEnv   *envhp,
/// OCIError *errhp,
/// const OCILobLocator *locp,
/// boolean *is_initialized );
///
/// Comments
/// Tests to see if a given LOB locator is initialized.
///
/// Parameters
/// envhp (IN/OUT) - OCI environment handle initialized in object mode.
/// errhp (IN/OUT) - error handle. The OCI error handle. If there is an error, it
/// is recorded in err and this function returns OCI_ERROR. Diagnostic
/// information can be obtained by calling OCIErrorGet().
/// locp (IN) - the LOB locator being tested
/// is_initialized (OUT) - returns TRUE if the given LOB locator is initialized;
/// FALSE if it is not.
///
/// See also
/// OCIErrorGet, OCILobIsEqual
///
///
///
///
/// OCILobRead()
///
/// Name
/// OCI Lob/File ReaD
///
/// Purpose
/// Reads a portion of a LOB/FILE as specified by the call into a buffer.
///
/// Syntax
/// sword OCILobRead ( OCISvcCtx       *svchp,
/// OCIError        *errhp,
/// OCILobLocator   *locp,
/// ub4             offset,
/// ub4             *amtp,
/// void           *bufp,
/// ub4             bufl,
/// void           *ctxp,
/// OCICallbackLobRead cbfp,
/// ub2             csid,
/// ub1             csfrm );
///
/// Comments
/// Reads a portion of a LOB/FILE as specified by the call into a buffer. Data
/// read from a hole is returned as 0s. It is an error to try to read from a NULL
/// LOB/FILE. The OS FILE must already exist on the server and must have been
/// opened using the input locator. Oracle must hav epermission to read the OS
/// file and user must have read permission on the directory object.
///
/// Parameters
/// svchp (IN/OUT) - the service context handle.
/// errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
/// diagnostic information in the event of an error.
/// locp (IN/OUT) - a LOB locator that uniquely references a LOB.
/// offset (IN) - On input, it is the absolute offset, for character LOBs in the
/// number of characters from the beginning of the LOB, for binary LOBs it is the
/// number of bytes. Starts from 1.
/// amtp (IN/OUT) - On input, the number of character or bytes to be read. On
/// output, the actual number of bytes or characters read.
/// If the amount of bytes to be read is larger than the buffer length it is
/// assumed that the LOB is being read in a streamed mode. On input if this value
/// is 0, then the data shall be read in streamed mode from the LOB until the end
/// of LOB. If the data is read in pieces, *amtp always contains the length of
/// the last piece read.  If a callback function is defined, then this callback
/// function will be invoked each time bufl bytes are read off the pipe. Each
/// piece will be written into bufp.
/// If the callback function is not defined, then OCI_NEED_DATA error code will
/// be returned. The application must invoke the LOB read over and over again to
/// read more pieces of the LOB until the OCI_NEED_DATA error code is not
/// returned. The buffer pointer and the length can be different in each call
/// if the pieces are being read into different sizes and location.
/// bufp (IN) - the pointer to a buffer into which the piece will be read. The
/// length of the allocated memory is assumed to be bufl.
/// bufl (IN) - the length of the buffer in octets.
/// ctxp (IN) - the context for the call back function. Can be NULL.
/// cbfp (IN) - a callback that may be registered to be called for each piece. If
/// this is NULL, then OCI_NEED_DATA will be returned for each piece.
/// The callback function must return OCI_CONTINUE for the read to continue.
/// If any other error code is returned, the LOB read is aborted.
/// ctxp (IN) - the context for the call back function. Can be NULL.
/// bufp (IN) - a buffer pointer for the piece.
/// len (IN) - the length of length of current piece in bufp.
/// piece (IN) - which piece - OCI_FIRST_PIECE, OCI_NEXT_PIECE or
/// OCI_LAST_PIECE.
/// csid - the character set ID of the buffer data
/// csfrm - the character set form of the buffer data
///
/// Related Functions
/// OCIErrorGet, OCILobWrite, OCILobFileOpen, OCILobFileSetName, CREATE DIRECTORY
///
///
///
///
/// OCILobTrim()
///
/// Name
///
/// OCI Lob  Trim
///
/// Purpose
/// Trims the lob value to a shorter length
///
/// Syntax
/// sword OCILobTrim ( OCISvcCtx       *svchp,
/// OCIError        *errhp,
/// OCILobLocator   *locp,
/// ub4             newlen );
///
/// Comments
/// Truncates LOB data to a specified shorter length.
///
/// Parameters
/// svchp (IN) - the service context handle.
/// errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
/// diagnostic information in the event of an error.
/// locp (IN/OUT) - a LOB locator that uniquely references the LOB. This locator
/// must be a locator that was obtained from the server specified by svchp.
/// newlen (IN) - the new length of the LOB data, which must be less than or equal
/// to the current length.
///
/// Related Functions
/// OCIErrorGet, OCILobWrite, OCiLobErase, OCILobAppend, OCILobCopy
///
///
///
///
///
/// OCILobWrite()
///
/// Name
/// OCI Lob Write
///
/// Purpose
/// Writes a buffer into a LOB
///
/// Syntax
/// sword OCILobWrite ( OCISvcCtx       *svchp,
/// OCIError        *errhp,
/// OCILobLocator   *locp,
/// ub4             offset,
/// ub4             *amtp,
/// void           *bufp,
/// ub4             buflen,
/// ub1             piece,
/// void           *ctxp,
/// OCICallbackLobWrite   (cbfp)
/// (
/// void    *ctxp,
/// void    *bufp,
/// ub4      *lenp,
/// ub1      *piecep )
/// ub2             csid
/// ub1             csfrm );
///
///
/// Comments
/// Writes a buffer into a LOB as specified. If LOB data already exists
/// it is overwritten with the data stored in the buffer.
/// The buffer can be written to the LOB in a single piece with this call, or
/// it can be provided piecewise using callbacks or a standard polling method.
/// If this value of the piece parameter is OCI_FIRST_PIECE, data must be
/// provided through callbacks or polling.
/// If a callback function is defined in the cbfp parameter, then this callback
/// function will be invoked to get the next piece after a piece is written to
/// the pipe. Each piece will be written from bufp.
/// If no callback function is defined, then OCILobWrite() returns the
/// OCI_NEED_DATA error code. The application must all OCILobWrite() again
/// to write more pieces of the LOB. In this mode, the buffer pointer and the
/// length can be different in each call if the pieces are of different sizes and
/// from different locations. A piece value of OCI_LAST_PIECE terminates the
/// piecewise write.
///
/// Parameters
/// svchp (IN/OUT) - the service context handle.
/// errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
/// diagnostic information in the event of an error.
/// locp (IN/OUT) - a LOB locator that uniquely references a LOB.
/// offset (IN) - On input, it is the absolute offset, for character LOBs in
/// the number of characters from the beginning of the LOB, for binary LOBs it
/// is the number of bytes. Starts at 1.
/// bufp (IN) - the pointer to a buffer from which the piece will be written. The
/// length of the allocated memory is assumed to be the value passed in bufl.
/// Even if the data is being written in pieces, bufp must contain the first
/// piece of the LOB when this call is invoked.
/// bufl (IN) - the length of the buffer in bytes.
/// Note: This parameter assumes an 8-bit byte. If your platform uses a
/// longer byte, the value of bufl must be adjusted accordingly.
/// piece (IN) - which piece of the buffer is being written. The default value for
/// this parameter is OCI_ONE_PIECE, indicating the buffer will be written in a
/// single piece.
/// The following other values are also possible for piecewise or callback mode:
/// OCI_FIRST_PIECE, OCI_NEXT_PIECE and OCI_LAST_PIECE.
/// amtp (IN/OUT) - On input, takes the number of character or bytes to be
/// written. On output, returns the actual number of bytes or characters written.
/// If the data is written in pieces, *amtp will contain the total length of the
/// pieces written at the end of the call (last piece written) and is undefined in
/// between.
/// (Note it is different from the piecewise read case)
/// ctxp (IN) - the context for the call back function. Can be NULL.
/// cbfp (IN) - a callback that may be registered to be called for each piece in
/// a piecewise write. If this is NULL, the standard polling method will be used.
/// The callback function must return OCI_CONTINUE for the write to continue.
/// If any other error code is returned, the LOB write is aborted. The
/// callback takes the following parameters:
/// ctxp (IN) - the context for the call back function. Can be NULL.
/// bufp (IN/OUT) - a buffer pointer for the piece.
/// lenp (IN/OUT) - the length of the buffer (in octets) and the length of
/// current piece in bufp (out octets).
/// piecep (OUT) - which piece - OCI_NEXT_PIECE or OCI_LAST_PIECE.
/// csid - the character set ID of the buffer data
/// csfrm - the character set form of the buffer data
/// Related Functions
///
/// OCILobWriteAppend()
///
/// Name
/// OCI Lob Write Append
///
/// Purpose
/// Writes data to the end of a LOB value. This call provides the ability
/// to get the length of the data and append it to the end of the LOB in
/// a single round trip to the server.
///
/// Syntax
/// sword OCILobWriteAppend ( OCISvcCtx       *svchp,
/// OCIError        *errhp,
/// OCILobLocator   *locp,
/// ub4             *amtp,
/// void           *bufp,
/// ub4             buflen,
/// ub1             piece,
/// void           *ctxp,
/// OCICallbackLobWrite   (cbfp)
/// (
/// void    *ctxp,
/// void    *bufp,
/// ub4      *lenp,
/// ub1      *piecep )
/// ub2             csid
/// ub1             csfrm );
///
///
/// Comments
/// Writes a buffer to the end of a LOB as specified. If LOB data already exists
/// it is overwritten with the data stored in the buffer.
/// The buffer can be written to the LOB in a single piece with this call, or
/// it can be provided piecewise using callbacks or a standard polling method.
/// If this value of the piece parameter is OCI_FIRST_PIECE, data must be
/// provided through callbacks or polling.
/// If a callback function is defined in the cbfp parameter, then this callback
/// function will be invoked to get the next piece after a piece is written to the
/// pipe. Each piece will be written from bufp.
/// If no callback function is defined, then OCILobWriteAppend() returns the
/// OCI_NEED_DATA error code. The application must all OCILobWriteAppend() again
/// to write more pieces of the LOB. In this mode, the buffer pointer and the
/// length can be different in each call if the pieces are of different sizes and
/// from different locations. A piece value of OCI_LAST_PIECE terminates the
/// piecewise write.
///
/// Parameters
/// svchp (IN/OUT) - the service context handle.
/// errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
/// diagnostic information in the event of an error.
/// locp (IN/OUT) - a LOB locator that uniquely references a LOB.
/// bufp (IN) - the pointer to a buffer from which the piece will be written. The
/// length of the allocated memory is assumed to be the value passed in bufl. Even
/// if the data is being written in pieces, bufp must contain the first piece of
/// the LOB when this call is invoked.
/// bufl (IN) - the length of the buffer in bytes.
/// Note: This parameter assumes an 8-bit byte. If your platform uses a
/// longer byte, the value of bufl must be adjusted accordingly.
/// piece (IN) - which piece of the buffer is being written. The default value for
/// this parameter is OCI_ONE_PIECE, indicating the buffer will be written in a
/// single piece.
/// The following other values are also possible for piecewise or callback mode:
/// OCI_FIRST_PIECE, OCI_NEXT_PIECE and OCI_LAST_PIECE.
/// amtp (IN/OUT) - On input, takes the number of character or bytes to be
/// written. On output, returns the actual number of bytes or characters written.
/// If the data is written in pieces, *amtp will contain the total length of the
/// pieces written at the end of the call (last piece written) and is undefined in
/// between.
/// (Note it is different from the piecewise read case)
/// ctxp (IN) - the context for the call back function. Can be NULL.
/// cbfp (IN) - a callback that may be registered to be called for each piece in a
/// piecewise write. If this is NULL, the standard polling method will be used.
/// The callback function must return OCI_CONTINUE for the write to continue.
/// If any other error code is returned, the LOB write is aborted. The
/// callback takes the following parameters:
/// ctxp (IN) - the context for the call back function. Can be NULL.
/// bufp (IN/OUT) - a buffer pointer for the piece.
/// lenp (IN/OUT) - the length of the buffer (in octets) and the length of
/// current piece in bufp (out octets).
/// piecep (OUT) - which piece - OCI_NEXT_PIECE or OCI_LAST_PIECE.
/// csid - the character set ID of the buffer data
/// csfrm - the character set form of the buffer data
/// Related Functions
///
///
///
///
/// OCILobGetStorageLimit()
///
/// Name
/// OCI Lob Get Storage Limit
///
/// Purpose
/// To get the maximum Length of a LOB in bytes that can be stored in the database.
///
/// Syntax
/// sword OCILobGetStorageLimit ( OCISvcCtx       *svchp,
/// OCIError        *errhp,
/// OCILobLocator   *locp,
/// oraub8          *limitp);
///
///
/// Comments
/// With unlimited size LOB support the limit for a LOB is no longer restricted
/// to 4GB.
/// This interface should be used to get the actual limit for storing data for
/// a specific
/// LOB locator. Note that if the compatibality is set to 9.2 or older the limit
/// would still be 4GB.
///
/// Parameters
/// svchp (IN/OUT) - the service context handle.
/// errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
/// diagnostic information in the event of an error.
/// locp (IN/OUT) - a LOB locator that uniquely references a LOB.
/// limitp (OUT)  - The storage limit for a LOB in bytes.
/// Related Functions
///
///
///
///
/// OCILobGetOptions()
///
/// Name
/// OCI Lob Get Options
///
/// Purpose
/// To get the current options set for the given SecureFile.
///
/// Syntax
/// sword OCILobGetOptions ( OCISvcCtx       *svchp,
/// OCIError        *errhp,
/// OCILobLocator   *locp,
/// ub4              optypes,
/// void            *optionsp,
/// ub4             *optionslenp,
/// ub4              mode);
///
///
/// Comments
/// This function only works on SecureFiles.  All others will get an error.
///
/// Parameters
/// svchp   (IN/OUT) - the service context handle.
/// errhp   (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
/// diagnostic information in the event of an error.
/// locp    (IN/OUT) - a LOB locator that uniquely references a LOB.
/// optypes (IN)     - the types of options flags to be retrieved.
/// optionsp (OUT)   - the options flags or value for the given types.
/// optionslenp (IN/OUT) - the length of option_value buffer
/// mode    (IN)     - for future use (pass 0 for now).
/// Related Functions
/// OCISetOptions()
///
/// OCILobSetOptions()
///
/// Name
/// OCI Lob Set Options
///
/// Purpose
/// To set the options for the given SecureFile Lob.
///
/// Syntax
/// sword OCILobSetOptions ( OCISvcCtx       *svchp,
/// OCIError        *errhp,
/// OCILobLocator   *locp,
/// ub4              optypes,
/// void            *optionsp,
/// ub4              optionslen,
/// ub4              mode);
///
///
/// Comments
/// This function only works on SecureFile Lobs.  All others will get an error.
///
/// Parameters
/// svchp     (IN/OUT) - the service context handle.
/// errhp     (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
/// diagnostic information in the event of an error.
/// locp      (IN/OUT) - a LOB locator that uniquely references a LOB.
/// optypes   (IN)     - the types of options flags to be set.
/// optionsp  (IN)     - the options flags or value to be set for the given types.
/// optionslen (IN)    - then length of option_value buffer
/// mode      (IN)     - for future use (pass 0 for now).
/// Related Functions
/// OCILobGetOptions()
///
/// OCILobGetContentType()
///
/// Name
/// OCI Lob Get Content Type
///
/// Purpose
/// To get the current contenttype set for the given SecureFile.
///
/// Syntax
/// sword OCILobGetContentType (OCISvcCtx       *svchp,
/// OCIError        *errhp,
/// OCILobLocator   *locp,
/// oratext         *contenttypep,
/// ub4             *contenttypelenp,
/// ub4              mode);
///
///
/// Comments
/// This function only works on SecureFiles.  All others will get an error.
/// If the securefile does not have a contenttype associated with it,
/// the contenttype length (= *contenttypelenp) is returned as 0 without
/// modifying the buffer contenttypep.
/// Parameters
/// svchp      (IN/OUT) - the service context handle.
/// errhp      (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
/// diagnostic information in the event of an error.
/// locp       (IN/OUT) - a LOB locator that uniquely references a LOB.
/// contenttypep(IN/OUT)- pointer to the buffer where the contenttype is stored
/// after successful execution.
/// The caller needs to allocate the buffer before calling
/// this function. The size of the allocated buffer should
/// be >= OCI_LOB_CONTENTTYPE_MAXSIZE bytes
/// contenttypelenp(IN/OUT)- The caller should set this field to the size
/// of contenttypep buffer.
/// After the call successfully executes, it will hold the
/// size of the contenttype returned.
/// mode           (IN) - for future use (pass 0 for now).
/// Related Functions
/// OCISetContentType()
///
/// OCILobSetContentType()
///
/// Name
/// OCI Lob Set Content Type
///
/// Purpose
/// To set the contenttype for the given SecureFile Lob.
///
/// Syntax
/// sword OCILobSetContentType (OCISvcCtx       *svchp,
/// OCIError        *errhp,
/// OCILobLocator   *locp,
/// const oratext   *contenttypep,
/// ub4              contenttypelen,
/// ub4              mode);
///
///
/// Comments
/// This function only works on SecureFiles.  All others will get an error.
/// To clear an existing contenttype set on a securefile, the user will
/// invoke OCILobSetContentType API with contenttypep  set to (oratext *)0,
/// and contenttypelen set to 0.
/// Parameters
/// svchp     (IN/OUT) - the service context handle.
/// errhp     (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
/// diagnostic information in the event of an error.
/// locp      (IN/OUT) - a LOB locator that uniquely references a LOB.
/// contenttypep  (IN) - the contenttype to be set for the given LOB.
/// contenttypelen(IN) - the size of contenttype in bytes. The size of the
/// contenttype should be <= OCI_LOB_CONTENTTYPE_MAXSIZE
/// bytes.
/// mode      (IN)     - for future use (pass 0 for now).
/// Related Functions
/// OCILobGetContentType()
///
///
/// OCILogoff()
/// Name
/// OCI simplified Logoff
/// Purpose
/// This function is used to terminate a session created with OCILogon() or
/// OCILogon2().
/// Syntax
/// sword OCILogoff ( OCISvcCtx      *svchp
/// OCIError       *errhp );
/// Comments
/// This call is used to terminate a session which was created with OCILogon() or
/// OCILogon2().
/// This call implicitly deallocates the server, authentication, and service
/// context handles.
/// Note: For more information on logging on and off in an application,
/// refer to the section "Application Initialization, Connection, and
/// Authorization" on page 2-16.
/// Parameters
/// svchp (IN) - the service context handle which was used in the call to
/// OCILogon() or OCILogon2().
/// errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
/// diagnostic information in the event of an error.
/// See Also
/// OCILogon(), OCILogon2().
///
///
///
///
///
///
/// OCILogon()
/// Name
/// OCI Service Context Logon
/// Purpose
/// This function is used to create a simple logon session.
/// Syntax
/// sword OCILogon ( OCIEnv          *envhp,
/// OCIError        *errhp,
/// OCISvcCtx       *svchp,
/// const OraText      *username,
/// ub4             uname_len,
/// const OraText      *password,
/// ub4             passwd_len,
/// const OraText      *dbname,
/// ub4             dbname_len );
/// Comments
/// This function is used to create a simple logon session for an application.
/// Note: Users requiring more complex session (e.g., TP monitor
/// applications) should refer to the section "Application Initialization,
/// Connection, and Authorization" on page 2-16.
/// This call allocates the error and service context handles which are passed to
/// it. This call also implicitly allocates server and authentication handles
/// associated with the session.  These handles can be retrieved by calling
/// OCIAttrGet() on the service context handle.
/// Parameters
/// envhp (IN) - the OCI environment handle.
/// errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
/// diagnostic information in the event of an error.
/// svchp (OUT) - the service context pointer.
/// username (IN) - the username.
/// uname_len (IN) - the length of username.
/// password (IN) - the user's password.
/// passwd_len (IN) - the length of password.
/// dbname (IN) - the name of the database to connect to.
/// dbname_len (IN) - the length of dbname.
/// See Also
/// OCILogoff()
///
///
///
///
///
/// OCILogon2()
/// Name
/// OCI Service Context Logon
/// Purpose
/// This function is used to create a logon session in connection pooling mode.
/// Syntax
/// sword OCILogon2 ( OCIEnv          *envhp,
/// OCIError        *errhp,
/// OCISvcCtx       **svchp,
/// const OraText      *username,
/// ub4             uname_len,
/// const OraText      *password,
/// ub4             passwd_len,
/// const OraText      *dbname,
/// ub4             dbname_len,
/// ub4             mode);
/// Comments
/// This function is used to create a simple logon session for an application in
/// Connection Pooling mode. The valid values for mode are currently OCI_POOL and
/// OCI_DEFAULT. Call to this function with OCI_DEFAULT mode is equivalent to
/// OCILogon() call.
/// This call allocates the error and service context handles which are passed to
/// it. This call also implicitly allocates server and authentication handles
/// associated with the session.  These handles can be retrieved by calling
/// OCIAttrGet() on the service context handle. This call assumes that
/// OCIConnectionPoolCreate() has already been called for the same dbname.
/// Parameters
/// envhp (IN) - the OCI environment handle.
/// errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
/// diagnostic information in the event of an error.
/// svchp (OUT) - the service context pointer.
/// username (IN) - the username.
/// uname_len (IN) - the length of username.
/// password (IN) - the user's password. If this is null, it is assumed that a
/// proxy session has to be created and the required grants on
/// the database are already done.
/// passwd_len (IN) - the length of password.
/// dbname (IN) - the name of the database to connect to.
/// dbname_len (IN) - the length of dbname.
/// mode (IN) - the mode for doing the server attach. Should be OCI_POOL for
/// using Connection Pooling.
///
///
/// See Also
/// OCILogoff()
///
///
///
///
///
/// OCIMemoryFree()
/// Name
/// OCI FREE Memory
/// Purpose
/// Frees up storage associated with the pointer.
/// Syntax
/// void OCIMemoryFree ( const OCIStmt   *stmhp,
/// void           *memptr);
/// Comments
/// Frees up dynamically allocated data pointers associated with the pointer using
/// either the default memory free function or the registered memory free
/// function, as the case may be.
/// A user-defined memory free function can be registered during the initial call
/// to OCIInitialize().
/// This call is always successful.
/// Parameters
/// stmhp (IN) - statement handle which returned this data buffer.
/// memptr (IN) - pointer to data allocated by the client library.
/// Related Functions
/// OCIInitialize()
///
///
///
///
///
/// OCIParamGet()
/// Name
/// OCI Get PARaMeter
/// Purpose
/// Returns a descriptor of a parameter specified by position in the describe
/// handle or statement handle.
/// Syntax
/// sword OCIParamGet ( const void       *hndlp,
/// ub4         htype,
/// OCIError    *errhp,
/// void    **parmdpp,
/// ub4         pos );
/// Comments
/// This call returns a descriptor of a parameter specified by position in the
/// describe handle or statement handle. Parameter descriptors are always
/// allocated internally by the OCI library. They are read-only.
/// OCI_NO_DATA may be returned if there are no parameter descriptors for this
/// position.
/// See Appendix B for more detailed information about parameter descriptor
/// attributes.
/// Parameters
/// hndlp (IN) - a statement handle or describe handle. The OCIParamGet()
/// function will return a parameter descriptor for this handle.
/// htype (IN) - the type of the handle passed in the handle parameter. Valid
/// types are OCI_HTYPE_DESCRIBE, for a describe handle OCI_HTYPE_STMT, for a
/// statement handle
/// errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
/// diagnostic information in the event of an error.
/// parmdpp (OUT) - a descriptor of the parameter at the position given in the pos
/// parameter.
/// pos (IN) - position number in the statement handle or describe handle. A
/// parameter descriptor will be returned for this position.
/// Note: OCI_NO_DATA may be returned if there are no parameter
/// descriptors for this position.
/// Related Functions
/// OCIAttrGet(), OCIAttrSet()
///
///
///
///
///
/// OCIParamSet()
/// Name
/// OCI Parameter Set in handle
/// Purpose
/// Used to set a complex object retrieval descriptor into a complex object
/// retrieval handle.
/// Syntax
/// sword   OCIParamGet ( void *hndlp,
/// ub4 htyp,
/// OCIError *errhp,
/// const void *dscp,
/// ub4 dtyp,
/// ub4 pos );
/// Comments
/// This call sets a given complex object retrieval descriptor into a complex
/// object retrieval handle.
/// The handle must have been previously allocated using OCIHandleAlloc(), and
/// the descriptor must have been previously allocated using OCIDescAlloc().
/// Attributes of the descriptor are set using OCIAttrSet().
/// Parameters
/// hndlp (IN/OUT) - handle pointer.
/// htype (IN) - handle type.
/// errhp (IN/OUT) - error handle.
/// dscp (IN) - complex object retrieval descriptor pointer.
/// dtyp (IN) -
/// pos (IN) - position number.
/// See Also
///
///
///
///
///
/// OCIPasswordChange()
/// Name
/// OCI Change PassWord
/// Purpose
/// This call allows the password of an account to be changed.
/// Syntax
/// sword OCIPasswordChange ( OCISvcCtx     *svchp,
/// OCIError      *errhp,
/// const OraText    *user_name,
/// ub4           usernm_len,
/// const OraText    *opasswd,
/// ub4           opasswd_len,
/// const OraText    *npasswd,
/// sb4           npasswd_len,
/// ub4           mode);
/// Comments
/// This call allows the password of an account to be changed. This call is
/// similar to OCISessionBegin() with the following differences:
/// If the user authentication is already established, it authenticates
/// the account using the old password and then changes the
/// password to the new password
/// If the user authentication is not established, it establishes a user
/// authentication and authenticates the account using the old
/// password, then changes the password to the new password.
/// This call is useful when the password of an account is expired and
/// OCISessionBegin() returns an error or warning which indicates that the
/// password has expired.
/// Parameters
/// svchp (IN/OUT) - a handle to a service context. The service context handle
/// must be initialized and have a server context handle associated with it.
/// errhp (IN) - an error handle which can be passed to OCIErrorGet() for
/// diagnostic information in the event of an error.
/// user_name (IN) - specifies the user name. It points to a character string,
/// whose length is specified in usernm_len. This parameter must be NULL if the
/// service context has been initialized with an authentication handle.
/// usernm_len (IN) - the length of the user name string specified in user_name.
/// For a valid user name string, usernm_len must be non-zero.
/// opasswd (IN) - specifies the user's old password. It points to a character
/// string, whose length is specified in opasswd_len .
/// opasswd_len (IN) - the length of the old password string specified in opasswd.
/// For a valid password string, opasswd_len must be non-zero.
/// npasswd (IN) - specifies the user's new password. It points to a character
/// string, whose length is specified in npasswd_len which must be non-zero for a
/// valid password string. If the password complexity verification routine is
/// specified in the user's profile to verify the new password's complexity, the
/// new password must meet the complexity requirements of the verification
/// function.
/// npasswd_len (IN)  - then length of the new password string specified in
/// npasswd. For a valid password string, npasswd_len must be non-zero.
/// mode - pass as OCI_DEFAULT.
/// Related Functions
/// OCISessionBegin()
///
///
/// ----------------------------------OCIReset------------------------------------
///
///
/// OCIReset()
/// Name
/// OCI Reset
/// Purpose
/// Resets the interrupted asynchronous operation and protocol. Must be called
/// if a OCIBreak call had been issued while a non-blocking operation was in
/// progress.
/// Syntax
/// sword OCIReset ( void      *hndlp,
/// OCIError   *errhp);
/// Comments
/// This call is called in non-blocking mode ONLY. Resets the interrupted
/// asynchronous operation and protocol. Must be called if a OCIBreak call
/// had been issued while a non-blocking operation was in progress.
/// Parameters
/// hndlp (IN) - the service context handle or the server context handle.
/// errhp (IN) - an error handle which can be passed to OCIErrorGet() for
/// diagnostic information in the event of an error.
/// Related Functions
///
///
/// OCIResultSetToStmt()
/// Name
/// OCI convert Result Set to Statement Handle
/// Purpose
/// Converts a descriptor to statement handle for fetching rows.
/// Syntax
/// sword OCIResultSetToStmt ( OCIResult     *rsetdp,
/// OCIError      *errhp );
/// Comments
/// Converts a descriptor to statement handle for fetching rows.
/// A result set descriptor can be allocated with a call to OCIDescAlloc().
/// Parameters
/// rsetdp (IN/OUT) - a result set descriptor pointer.
/// errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
/// diagnostic information in the event of an error.
/// Related Functions
/// OCIDescAlloc()
///
///
///
///
/// OCIServerAttach()
/// Name
/// OCI ATtaCH to server
/// Purpose
/// Creates an access path to a data source for OCI operations.
/// Syntax
/// sword OCIServerAttach ( OCIServer    *srvhp,
/// OCIError     *errhp,
/// const OraText   *dblink,
/// sb4          dblink_len,
/// ub4          mode);
/// Comments
/// This call is used to create an association between an OCI application and a
/// particular server.
/// This call initializes a server context handle, which must have been previously
/// allocated with a call to OCIHandleAlloc().
/// The server context handle initialized by this call can be associated with a
/// service context through a call to OCIAttrSet(). Once that association has been
/// made, OCI operations can be performed against the server.
/// If an application is operating against multiple servers, multiple server
/// context handles can be maintained. OCI operations are performed against
/// whichever server context is currently associated with the service context.
/// Parameters
/// srvhp (IN/OUT) - an uninitialized server context handle, which gets
/// initialized by this call. Passing in an initialized server handle causes an
/// error.
/// errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
/// diagnostic information in the event of an error.
/// dblink (IN) - specifies the database (server) to use. This parameter points to
/// a character string which specifies a connect string or a service point. If the
/// connect string is NULL, then this call attaches to the default host. The length
/// of connstr is specified in connstr_len. The connstr pointer may be freed by the
/// caller on return.
/// dblink_len (IN) - the length of the string pointed to by connstr. For a valid
/// connect string name or alias, connstr_len must be non-zero.
/// mode (IN) - specifies the various modes of operation.  For release 8.0, pass as
/// OCI_DEFAULT - in this mode, calls made to the server on this server context
/// are made in blocking mode.
/// Example
/// See the description of OCIStmtPrepare() on page 13-96 for an example showing
/// the use of OCIServerAttach().
/// Related Functions
/// OCIServerDetach()
///
///
///
/// OCIServerDetach()
/// Name
/// OCI DeTaCH server
/// Purpose
/// Deletes an access to a data source for OCI operations.
/// Syntax
/// sword OCIServerDetach ( OCIServer   *svrhp,
/// OCIError    *errhp,
/// ub4         mode);
/// Comments
/// This call deletes an access to data source for OCI operations, which was
/// established by a call to OCIServerAttach().
/// Parameters
/// srvhp (IN) - a handle to an initialized server context, which gets reset to
/// uninitialized state. The handle is not de-allocated.
/// errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
/// diagnostic information in the event of an error.
/// mode (IN) - specifies the various modes of operation. The only valid mode is
/// OCI_DEFAULT for the default mode.
/// Related Functions
/// OCIServerAttach()
///
///
///
/// OCIServerVersion()
/// Name
/// OCI VERSion
/// Purpose
/// Returns the version string of the Oracle server.
/// Syntax
/// sword OCIServerVersion ( void        *hndlp,
/// OCIError     *errhp,
/// OraText         *bufp,
/// ub4          bufsz
/// ub1          hndltype );
/// Comments
/// This call returns the version string of the Oracle server.
/// For example, the following might be returned as the version string if your
/// application is running against a 7.3.2 server:
/// Oracle7 Server Release 7.3.2.0.0 - Production Release
/// PL/SQL Release 2.3.2.0.0 - Production
/// CORE Version 3.5.2.0.0 - Production
/// TNS for SEQUENT DYNIX/ptx: Version 2.3.2.0.0 - Production
/// NLSRTL Version 3.2.2.0.0 - Production
///
/// Parameters
/// hndlp (IN) - the service context handle or the server context handle.
/// errhp (IN) - an error handle which can be passed to OCIErrorGet() for
/// diagnostic information in the event of an error.
/// bufp (IN) - the buffer in which the version information is returned.
/// bufsz (IN) - the length of the buffer.
/// hndltype (IN) - the type of handle passed to the function.
/// Related Functions
///
///
///
///
///
/// OCISessionBegin()
/// Name
/// OCI Session Begin and authenticate user
/// Purpose
/// Creates a user authentication and begins a user session for a given server.
/// Syntax
/// sword OCISessionBegin ( OCISvcCtx     *svchp,
/// OCIError      *errhp,
/// OCISession    *usrhp,
/// ub4           credt,
/// ub4           mode);
///
/// Comments
/// For Oracle8, OCISessionBegin() must be called for any given server handle
/// before requests can be made against it. Also, OCISessionBegin() only supports
/// authenticating the user for access to the Oracle server specified by the
/// server handle in the service context. In other words, after OCIServerAttach()
/// is called to initialize a server handle, OCISessionBegin() must be called to
/// authenticate the user for that given server.
/// When OCISessionBegin() is called for the first time for the given server
/// handle, the initialized authentication handle is called a primary
/// authentication context. A primary authentication context may not be created
/// with the OCI_MIGRATE mode. Also, only one primary authentication context can
/// be created for a given server handle and the primary authentication context c
/// an only ever be used with that server handle. If the primary authentication
/// context is set in a service handle with a different server handle, then an
/// error will result.
/// After OCISessionBegin() has been called for the server handle, and the primary
/// authentication context is set in the service handle, OCISessionBegin() may be
/// called again to initialize another authentication handle with different (or
/// the same) credentials. When OCISessionBegin() is called with a service handle
/// set with a primary authentication context, the returned authentication context
/// in authp is called a user authentication context. As many user authentication
/// contexts may be initialized as desired.
/// User authentication contexts may be created with the OCI_MIGRATE mode.
/// If the OCI_MIGRATE mode is not specified, then the user authentication
/// context can only ever be used with the same server handle set in svchp. If
/// OCI_MIGRATE mode is specified, then the user authentication may be set
/// with different server handles. However, the user authentication context is
/// restricted to use with only server handles which resolve to the same database
/// instance and that have equivalent primary authentication contexts. Equivalent
/// authentication contexts are those which were authenticated as the same
/// database user.
/// OCI_SYSDBA, OCI_SYSOPER, OCI_SYSASM, and OCI_PRELIM_AUTH may only be used
/// with a primary authentication context.
/// To provide credentials for a call to OCISessionBegin(), one of two methods are
/// supported. The first is to provide a valid username and password pair for
/// database authentication in the user authentication handle passed to
/// OCISessionBegin(). This involves using OCIAttrSet() to set the
/// OCI_ATTR_USERNAME and OCI_ATTR_PASSWORD attributes on the
/// authentication handle. Then OCISessionBegin() is called with
/// OCI_CRED_RDBMS.
/// Note: When the authentication handle is terminated using
/// OCISessionEnd(), the username and password attributes remain
/// unchanged and thus can be re-used in a future call to OCISessionBegin().
/// Otherwise, they must be reset to new values before the next
/// OCISessionBegin() call.
/// The second type of credentials supported are external credentials. No
/// attributes need to be set on the authentication handle before calling
/// OCISessionBegin(). The credential type is OCI_CRED_EXT. This is equivalent
/// to the Oracle7 `connect /' syntax. If values have been set for
/// OCI_ATTR_USERNAME and OCI_ATTR_PASSWORD, then these are
/// ignored if OCI_CRED_EXT is used.
/// Parameters
/// svchp (IN) - a handle to a service context. There must be a valid server
/// handle set in svchp.
/// errhp (IN) - an error handle to the retrieve diagnostic information.
/// usrhp (IN/OUT) - a handle to an authentication context, which is initialized
/// by this call.
/// credt (IN) - specifies the type of credentials to use for authentication.
/// Valid values for credt are:
/// OCI_CRED_RDBMS - authenticate using a database username and
/// password pair as credentials. The attributes OCI_ATTR_USERNAME
/// and OCI_ATTR_PASSWORD should be set on the authentication
/// context before this call.
/// OCI_CRED_EXT - authenticate using external credentials. No username
/// or password is provided.
/// mode (IN) - specifies the various modes of operation. Valid modes are:
/// OCI_DEFAULT - in this mode, the authentication context returned may
/// only ever be set with the same server context specified in svchp. This
/// establishes the primary authentication context.
/// OCI_MIGRATE - in this mode, the new authentication context may be
/// set in a service handle with a different server handle. This mode
/// establishes the user authentication context.
/// OCI_SYSDBA - in this mode, the user is authenticated for SYSDBA
/// access.
/// OCI_SYSOPER - in this mode, the user is authenticated for SYSOPER
/// access.
/// OCI_SYSASM - in this mode, the user is authenticated for SYSASM
/// access.  Note that only an ASM instance can grant SYSASM access.
/// OCI_PRELIM_AUTH - this mode may only be used with OCI_SYSDBA, OCI_SYSASM,
/// or OCI_SYSOPER to authenticate for certain administration tasks.
/// Related Functions
/// OCISessionEnd()
///
///
///
///
///
///
/// OCISessionEnd()
/// Name
/// OCI Terminate user Authentication Context
/// Purpose
/// Terminates a user authentication context created by OCISessionBegin()
/// Syntax
/// sword OCISessionEnd ( OCISvcCtx       *svchp,
/// OCIError        *errhp,
/// OCISession      *usrhp,
/// ub4             mode);
///
/// Comments
/// The user security context associated with the service context is invalidated
/// by this call. Storage for the authentication context is not freed. The
/// transaction specified by the service context is implicitly committed. The
/// transaction handle, if explicitly allocated, may be freed if not being used.
/// Resources allocated on the server for this user are freed.
/// The authentication handle may be reused in a new call to OCISessionBegin().
/// Parameters
/// svchp (IN/OUT) - the service context handle. There must be a valid server
/// handle and user authentication handle associated with svchp.
/// errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
/// diagnostic information in the event of an error.
/// usrhp (IN) - de-authenticate this user. If this parameter is passed as NULL,
/// the user in the service context handle is de-authenticated.
/// mode (IN) - the only valid mode is OCI_DEFAULT.
/// Example
/// In this example, an authentication context is destroyed.
/// Related Functions
/// OCISessionBegin()
///
///
///
///
/// OCIStmtExecute()
/// Name
/// OCI EXECute
/// Purpose
/// This call associates an application request with a server.
/// Syntax
/// sword OCIStmtExecute ( OCISvcCtx           *svchp,
/// OCIStmt             *stmtp,
/// OCIError            *errhp,
/// ub4                 iters,
/// ub4                 rowoff,
/// const OCISnapshot   *snap_in,
/// OCISnapshot         *snap_out,
/// ub4                 mode );
/// Comments
/// This function  is used to execute a prepared SQL statement.
/// Using an execute call, the application associates a request with a server. On
/// success, OCI_SUCCESS is returned.
/// If a SELECT statement is executed, the description of the select list follows
/// implicitly as a response. This description is buffered on the client side for
/// describes, fetches and define type conversions. Hence it is optimal to
/// describe a select list only after an execute.
/// Also for SELECT statements, some results are available implicitly. Rows will
/// be received and buffered at the end of the execute. For queries with small row
/// count, a prefetch causes memory to be released in the server if the end of
/// fetch is reached, an optimization that may result in memory usage reduction.
/// Set attribute call has been defined to set the number of rows to be prefetched
/// per result set.
/// For SELECT statements, at the end of the execute, the statement handle
/// implicitly maintains a reference to the service context on which it is
/// executed. It is the user's responsibility to maintain the integrity of the
/// service context. If the attributes of a service context is changed for
/// executing some operations on this service context, the service context must
/// be restored to have the same attributes, that a statement was executed with,
/// prior to a fetch on the statement handle. The implicit reference is maintained
/// until the statement handle is freed or the fetch is cancelled or an end of
/// fetch condition is reached.
/// Note: If output variables are defined for a SELECT statement before a
/// call to OCIStmtExecute(), the number of rows specified by iters will be
/// fetched directly into the defined output buffers and additional rows
/// equivalent to the prefetch count will be prefetched. If there are no
/// additional rows, then the fetch is complete without calling
/// OCIStmtFetch().
/// The execute call will return errors if the statement has bind data types that
/// are not supported in an Oracle7 server.
/// Parameters
/// svchp (IN/OUT) - service context handle.
/// stmtp (IN/OUT) - an statement handle - defines the statement and the
/// associated data to be executed at the server. It is invalid to pass in a
/// statement handle that has bind of data types only supported in release 8.0
/// when srvchp points to an Oracle7 server.
/// errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
/// diagnostic information in the event of an error. If the statement is being
/// batched and it is successful, then this handle will contain this particular
/// statement execution specific errors returned from the server when the batch is
/// flushed.
/// iters (IN) - the number of times this statement is executed for non-Select
/// statements. For Select statements, if iters is non-zero, then defines must
/// have been done for the statement handle. The execution fetches iters rows into
/// these predefined buffers and prefetches more rows depending upon the prefetch
/// row count. This function returns an error if iters=0 for non-SELECT
/// statements.
/// rowoff (IN) - the index from which the data in an array bind is relevant for
/// this multiple row execution.
/// snap_in (IN) - this parameter is optional. if supplied, must point to a
/// snapshot descriptor of type OCI_DTYPE_SNAP.  The contents of this descriptor
/// must be obtained from the snap_out parameter of a previous call.  The
/// descriptor is ignored if the SQL is not a SELECT.  This facility allows
/// multiple service contexts to ORACLE to see the same consistent snapshot of the
/// database's committed data.  However, uncommitted data in one context is not
/// visible to another context even using the same snapshot.
/// snap_out (OUT) - this parameter optional. if supplied, must point to a
/// descriptor of type OCI_DTYPE_SNAP. This descriptor is filled in with an
/// opaque representation which is the current ORACLE "system change
/// number" suitable as a snap_in input to a subsequent call to OCIStmtExecute().
/// This descriptor should not be used any longer than necessary in order to avoid
/// "snapshot too old" errors.
/// mode (IN) - The modes are:
/// If OCI_DEFAULT_MODE, the default mode, is selected, the request is
/// immediately executed. Error handle contains diagnostics on error if any.
/// OCI_EXACT_FETCH - if the statement is a SQL SELECT, this mode is
/// only valid if the application has set the prefetch row count prior to this
/// call. In this mode, the OCI library will get up to the number of rows
/// specified (i.e., prefetch row count plus iters). If the number of rows
/// returned by the query is greater than this value, OCI_ERROR will be
/// returned with ORA-01422 as the implementation specific error in a
/// diagnostic record. If the number of rows returned by the query is
/// smaller than the prefetch row count, OCI_SUCCESS_WITH_INFO will
/// be returned with ORA-01403 as the implementation specific error. The
/// prefetch buffer size is ignored and the OCI library tries to allocate all the
/// space required to contain the prefetched rows. The exact fetch semantics
/// apply to only the top level rows. No more rows can be fetched for this
/// query at the end of the call.
/// OCI_KEEP_FETCH_STATE - the result set rows (not yet fetched) of this
/// statement executed in this transaction will be maintained when the
/// transaction is detached for migration. By default, a query is cancelled
/// when a transaction is detached for migration. This mode is the default
/// mode when connected to a V7 server.
/// Related Functions
/// OCIStmtPrepare()
///
/// sword OCIStmtGetNextResult (OCIStmt *stmthp,
/// OCIError *errhp,
/// void **result,
/// ub4  *rtype,
/// ub4 mode)
/// PARAMETERS
/// stmthp   - (IN) executed statement handle
/// errhp    - (IN) error handle
/// result   - (OUT) the next implicit
/// Result from the executed PL/SQL statement
/// rtype       - (OUT) the type of the implicit result
/// mode     - (IN) OCI_DEFAULT for now
///
/// DESCRIPTION
/// Returns the implicit results from a executed PL/SQL statement
/// handle. Each call to OCIStmtGetNextResult () retrieves a single
/// implicit Result in the order in which they were returned from
/// the PL/SQL procedure/block. If no more Results are available,
/// then OCI_NO_DATA is returned. If rtype is OCI_RESULT_TYPE_SELECT, then
/// the returned result can be cast as an OCI statement handle.
/// The OCI statement handles for implicit result-sets
/// are allocated by OCI. Applications can do normal OCI define
/// and fetch calls to fetch rows from the implicit result-sets. The
/// returned OCI statement handle cannot be freed explicitly. All implicit
/// result-sets are automatically closed and freed when the top-level
/// statement handle is freed or released.
/// RETURN
/// OCI_ERROR
/// OCI_SUCCESS
/// OCI_NO_DATA  when all implicit ResultSets have been retrieved from
/// the top-level Statement handle
///
///
///
///
///
///
/// OCIStmtFetch()
/// Name
/// OCI FetCH
/// Purpose
/// Fetches rows from a query.
/// Syntax
/// sword OCIStmtFetch ( OCIStmt     *stmtp,
/// OCIError    *errhp,
/// ub4         nrows,
/// ub2         orientation,
/// ub4         mode);
/// Comments
/// The fetch call is a local call, if prefetched rows suffice. However, this is
/// transparent to the application. If LOB columns are being read, LOB locators
/// are fetched for subsequent LOB operations to be performed on these locators.
/// Prefetching is turned off if LONG columns are involved.
/// A fetch with nrows set to 0 rows effectively cancels the fetch for this
/// statement.
/// Parameters
/// stmtp (IN) - a statement (application request) handle.
/// errhp (IN) - an error handle which can be passed to OCIErrorGet() for
/// diagnostic information in the event of an error.
/// nrows (IN) - number of rows to be fetched from the current position.
/// orientation (IN) - for release 8.0, the only acceptable value is
/// OCI_FETCH_NEXT, which is also the default value.
/// mode (IN) - for release 8.0, beta-1, the following mode is defined.
/// OCI_DEFAULT - default mode
/// OCI_EOF_FETCH - indicates that it is the last fetch from the result set.
/// If nrows is non-zero, setting this mode effectively cancels fetching after
/// retrieving nrows, otherwise it cancels fetching immediately.
/// Related Functions
/// OCIAttrGet()
///
/// OCIStmtFetch2()
/// Name
/// OCI FetCH2
/// Purpose
/// Fetches rows from a query.
/// Syntax
/// sword OCIStmtFetch2 ( OCIStmt     *stmtp,
/// OCIError    *errhp,
/// ub4         nrows,
/// ub2         orientation,
/// ub4         scrollOffset,
/// ub4         mode);
/// Comments
/// The fetch call works similar to the OCIStmtFetch call with the
/// addition of the fetchOffset parameter. It can be used on any
/// statement handle, whether it is scrollable or not. For a
/// non-scrollable statement handle, the only acceptable value
/// will be OCI_FETCH_NEXT, and the fetchOffset parameter will be
/// ignored. Applications are encouraged to use this new call.
///
/// A fetchOffset with OCI_FETCH_RELATIVE is equivalent to
/// OCI_FETCH_CURRENT with a value of 0, is equivalent to
/// OCI_FETCH_NEXT with a value of 1, and equivalent to
/// OCI_FETCH_PRIOR with a value of -1. Note that the range of
/// accessible rows is [1,OCI_ATTR_ROW_COUNT] beyond which an
/// error could be raised if sufficient rows do not exist in
///
/// The fetch call is a local call, if prefetched rows suffice. However, this is
/// transparent to the application. If LOB columns are being read, LOB locators
/// are fetched for subsequent LOB operations to be performed on these locators.
/// Prefetching is turned off if LONG columns are involved.
/// A fetch with nrows set to 0 rows effectively cancels the fetch for this
/// statement.
/// Parameters
/// stmtp (IN) - a statement (application request) handle.
/// errhp (IN) - an error handle which can be passed to OCIErrorGet() for
/// diagnostic information in the event of an error.
/// nrows (IN) - number of rows to be fetched from the current position.
/// It defaults to 1 for orientation OCI_FETCH_LAST.
/// orientation (IN) -  The acceptable values are as follows, with
/// OCI_FETCH_NEXT being the default value.
/// OCI_FETCH_CURRENT gets the current row,
/// OCI_FETCH_NEXT gets the next row from the current position,
/// OCI_FETCH_FIRST gets the first row in the result set,
/// OCI_FETCH_LAST gets the last row in the result set,
/// OCI_FETCH_PRIOR gets the previous row from the current row in the result set,
/// OCI_FETCH_ABSOLUTE will fetch the row number (specified by fetchOffset
/// parameter) in the result set using absolute positioning,
/// OCI_FETCH_RELATIVE will fetch the row number (specified by fetchOffset
/// parameter) in the result set using relative positioning.
/// scrollOffset(IN) - offset used with the OCI_FETCH_ABSOLUTE and
/// OCI_FETCH_RELATIVE orientation parameters only. It specify
/// the new current position for scrollable result set. It is
/// ignored for non-scrollable result sets.
/// mode (IN) - for release 8.0, beta-1, the following mode is defined.
/// OCI_DEFAULT - default mode
/// OCI_EOF_FETCH - indicates that it is the last fetch from the result set.
/// If nrows is non-zero, setting this mode effectively cancels fetching after
/// retrieving nrows, otherwise it cancels fetching immediately.
/// Related Functions
/// OCIAttrGet()
///
///
///
/// OCIStmtGetPieceInfo()
/// Name
/// OCI Get Piece Information
/// Purpose
/// Returns piece information for a piecewise operation.
/// Syntax
/// sword OCIStmtGetPieceInfo( const OCIStmt  *stmtp,
/// OCIError       *errhp,
/// void          **hndlpp,
/// ub4            *typep,
/// ub1            *in_outp,
/// ub4            *iterp,
/// ub4            *idxp,
/// ub1            *piecep );
///
/// Comments
/// When an execute/fetch call returns OCI_NEED_DATA to get/return a
/// dynamic bind/define value or piece, OCIStmtGetPieceInfo() returns the
/// relevant information: bind/define handle, iteration or index number and
/// which piece.
/// See the section "Runtime Data Allocation and Piecewise Operations" on page
/// 5-16 for more information about using OCIStmtGetPieceInfo().
/// Parameters
/// stmtp (IN) - the statement when executed returned OCI_NEED_DATA.
/// errhp (OUT) - an error handle which can be passed to OCIErrorGet() for
/// diagnostic information in the event of an error.
/// hndlpp (OUT) - returns a pointer to the bind or define handle of the bind or
/// define whose runtime data is required or is being provided.
/// typep (OUT) - the type of the handle pointed to by hndlpp: OCI_HTYPE_BIND
/// (for a bind handle) or OCI_HTYPE_DEFINE (for a define handle).
/// in_outp (OUT) - returns OCI_PARAM_IN if the data is required for an IN bind
/// value. Returns OCI_PARAM_OUT if the data is available as an OUT bind
/// variable or a define position value.
/// iterp (OUT) - returns the row number of a multiple row operation.
/// idxp (OUT) - the index of an array element of a PL/SQL array bind operation.
/// piecep (OUT) - returns one of the following defined values -
/// OCI_ONE_PIECE, OCI_FIRST_PIECE, OCI_NEXT_PIECE and
/// OCI_LAST_PIECE. The default value is always OCI_ONE_PIECE.
/// Related Functions
/// OCIAttrGet(), OCIAttrGet(), OCIStmtExecute(), OCIStmtFetch(),
/// OCIStmtSetPieceInfo()
///
///
///
///
/// OCIStmtPrepare()
/// Name
/// OCI Statement REQuest
/// Purpose
/// This call defines the SQL/PLSQL statement to be executed.
/// Syntax
/// sword OCIStmtPrepare ( OCIStmt      *stmtp,
/// OCIError     *errhp,
/// const OraText   *stmt,
/// ub4          stmt_len,
/// ub4          language,
/// ub4          mode);
/// Comments
/// This call is used to prepare a SQL or PL/SQL statement for execution. The
/// OCIStmtPrepare() call defines an application request.
/// This is a purely local call. Data values for this statement initialized in
/// subsequent bind calls will be stored in a bind handle which will hang off this
/// statement handle.
/// This call does not create an association between this statement handle and any
/// particular server.
/// See the section "Preparing Statements" on page 2-21 for more information
/// about using this call.
/// Parameters
/// stmtp (IN) - a statement handle.
/// errhp (IN) - an error handle to retrieve diagnostic information.
/// stmt (IN) - SQL or PL/SQL statement to be executed. Must be a null-terminated
/// string. The pointer to the OraText of the statement must be available as long
/// as the statement is executed.
/// stmt_len (IN) - length of the statement. Must not be zero.
/// language (IN) - V7, V8, or native syntax. Possible values are:
/// OCI_V7_SYNTAX - V7 ORACLE parsing syntax
/// OCI_V8_SYNTAX - V8 ORACLE parsing syntax
/// OCI_NTV_SYNTAX - syntax depending upon the version of the server.
/// mode (IN) - the only defined mode is OCI_DEFAULT for default mode.
/// Example
/// This example demonstrates the use of OCIStmtPrepare(), as well as the OCI
/// application initialization calls.
/// Related Functions
/// OCIAttrGet(), OCIStmtExecute()
///
///
/// OCIStmtPrepare2()
/// Name
/// OCI Statement REQuest with (a) early binding to svchp and/or
/// (b) stmt caching
/// Purpose
/// This call defines the SQL/PLSQL statement to be executed.
/// Syntax
/// sword OCIStmtPrepare2 ( OCISvcCtx *svchp,
/// OCIStmt      **stmtp,
/// OCIError     *errhp,
/// const OraText   *stmt,
/// ub4          stmt_len,
/// const OraText *key,
/// ub4          key_len,
/// ub4          language,
/// ub4          mode);
/// Comments
/// This call is used to prepare a SQL or PL/SQL statement for execution. The
/// OCIStmtPrepare() call defines an application request.
/// This is a purely local call. Data values for this statement initialized in
/// subsequent bind calls will be stored in a bind handle which will hang off this
/// statement handle.
/// This call creates an association between the statement handle and a service
/// context. It differs from OCIStmtPrepare in that respect.It also supports
/// stmt caching. The stmt will automatically be cached if the authp of the stmt
/// has enabled stmt caching.
/// Parameters
/// svchp (IN) - the service context handle that contains the session that
/// this stmt handle belongs to.
/// stmtp (OUT) - an unallocated stmt handle must be pased in. An allocated
/// and prepared  statement handle will be returned.
/// errhp (IN) - an error handle to retrieve diagnostic information.
/// stmt (IN) - SQL or PL/SQL statement to be executed. Must be a null-
/// terminated string. The pointer to the OraText of the statement
/// must be available as long as the statement is executed.
/// stmt_len (IN) - length of the statement. Must not be zero.
/// key (IN) - This is only Valid for OCI Stmt Caching. It indicates the
/// key to search with. It thus optimizes the search in the cache.
/// key_len (IN) - the length of the key. This, too, is onlly valid for stmt
/// caching.
/// language (IN) - V7, V8, or native syntax. Possible values are:
/// OCI_V7_SYNTAX - V7 ORACLE parsing syntax
/// OCI_V8_SYNTAX - V8 ORACLE parsing syntax
/// OCI_NTV_SYNTAX - syntax depending upon the version of the server.
/// mode (IN) - the defined modes are OCI_DEFAULT and OCI_PREP2_CACHE_SEARCHONLY.
/// Example
/// Related Functions
/// OCIStmtExecute(), OCIStmtRelease()
///
///
/// OCIStmtRelease()
/// Name
/// OCI Statement Release. This call is used to relesae the stmt that
/// was retreived using OCIStmtPrepare2(). If the stmt is release
/// using this call, OCIHandleFree() must not be called on the stmt
/// handle.
/// Purpose
/// This call releases the statement obtained by OCIStmtPrepare2
/// Syntax
/// sword OCIStmtRelease ( OCIStmt      *stmtp,
/// OCIError     *errhp,
/// cONST OraText *key,
/// ub4          key_len,
/// ub4          mode);
/// Comments
/// This call is used to release a handle obtained via OCIStmtPrepare2().
/// It also frees the memory associated with the handle.
/// This is a purely local call.
/// Parameters
/// stmtp (IN/OUT) - The statement handle to be released/freed.
/// errhp (IN) - an error handle to retrieve diagnostic information.
/// key (IN) - This is only Valid for OCI Stmt Caching. It indicates the
/// key to tag the stmt with.
/// key_len (IN) - the length of the key. This, too, is only valid for stmt
/// caching.
/// mode (IN) - the defined modes are OCI_DEFAULT for default mode and
/// OCI_STRLS_CACHE_DELETE (only used for Stmt Caching).
/// Example
/// Related Functions
/// OCIStmtExecute(), OCIStmtPrepare2()
///
///
/// OCIStmtSetPieceInfo()
/// Name
/// OCI Set Piece Information
/// Purpose
/// Sets piece information for a piecewise operation.
/// Syntax
/// sword OCIStmtSetPieceInfo ( void             *hndlp,
/// ub4               type,
/// OCIError          *errhp,
/// const void       *bufp,
/// ub4               *alenp,
/// ub1               piece,
/// const void       *indp,
/// ub2               *rcodep );
/// Comments
/// When an execute call returns OCI_NEED_DATA to get a dynamic IN/OUT
/// bind value or piece, OCIStmtSetPieceInfo() sets the piece information: the
/// buffer, the length, the indicator and which piece is currently being processed.
/// For more information about using OCIStmtSetPieceInfo() see the section
/// "Runtime Data Allocation and Piecewise Operations" on page 5-16.
/// Parameters
/// hndlp (IN/OUT) - the bind/define handle.
/// type (IN) - type of the handle.
/// errhp (OUT) - an error handle which can be passed to OCIErrorGet() for
/// diagnostic information in the event of an error.
/// bufp (IN/OUT) - bufp is a pointer to a storage containing the data value or
/// the piece when it is an IN bind variable, otherwise bufp is a pointer to
/// storage for getting a piece or a value for OUT binds and define variables. For
/// named data types or REFs, a pointer to the object or REF is returned.
/// alenp (IN/OUT) - the length of the piece or the value.
/// piece (IN) - the piece parameter. The following are valid values:
/// OCI_ONE_PIECE, OCI_FIRST_PIECE, OCI_NEXT_PIECE, or
/// OCI_LAST_PIECE.
/// The default value is OCI_ONE_PIECE. This parameter is used for IN bind
/// variables only.
/// indp (IN/OUT) - indicator. A pointer to a sb2 value or pointer to an indicator
/// structure for named data types (SQLT_NTY) and REFs (SQLT_REF), i.e., *indp
/// is either an sb2 or a void * depending upon the data type.
/// rcodep (IN/OUT) - return code.
/// Related Functions
/// OCIAttrGet(), OCIAttrGet(), OCIStmtExecute(), OCIStmtFetch(),
/// OCIStmtGetPieceInfo()
///
///
/// OCIFormatInit
/// Name
/// OCIFormat Package Initialize
/// Purpose
/// Initializes the OCIFormat package.
/// Syntax
/// sword OCIFormatInit(void *hndl, OCIError *err);
/// Comments
/// This routine must be called before calling any other OCIFormat routine.
/// Returns OCI_SUCCESS, OCI_INVALID_HANDLE, or OCI_ERROR
/// Parameters
/// hndl (IN/OUT) - OCI environment or session handle
/// err (IN/OUT) - OCI error handle
/// Related Functions
/// OCIFormatTerm()
///
///
/// OCIFormatString
/// Name
/// OCIFormat Package Format String
/// Purpose
/// Writes a text string into the supplied text buffer using the argument
/// list submitted to it and in accordance with the format string given.
/// Syntax
/// sword OCIFormatString(void *hndl, OCIError *err, OraText *buffer,
/// sbig_ora bufferLength, sbig_ora *returnLength,
/// const OraText *formatString, ...);
/// Comments
/// The first call to this routine must be preceded by a call to the
/// OCIFormatInit routine that initializes the OCIFormat package
/// for use.  When this routine is no longer needed then terminate
/// the OCIFormat package by a call to the OCIFormatTerm routine.
/// Returns OCI_SUCCESS, OCI_INVALID_HANDLE, or OCI_ERROR
/// Parameters
/// hndl         (IN/OUT) - OCI environment or session handle
/// err          (IN/OUT) - OCI error handle
/// buffer       (OUT)    - text buffer for the string
/// bufferLength (IN)     - length of the text buffer
/// returnLength (OUT)    - length of the formatted string
/// formatString (IN)     - format specification string
/// ...          (IN)     - variable argument list
/// Related Functions
///
///
/// OCIFormatTerm
/// Name
/// OCIFormat Package Terminate
/// Purpose
/// Terminates the OCIFormat package.
/// Syntax
/// sword OCIFormatTerm(void *hndl, OCIError *err);
/// Comments
/// It must be called after the OCIFormat package is no longer being used.
/// Returns OCI_SUCCESS, OCI_INVALID_HANDLE, or OCI_ERROR
/// Parameters
/// hndl (IN/OUT) - OCI environment or session handle
/// err (IN/OUT) - OCI error handle
/// Related Functions
/// OCIFormatInit()
///
///
/// OCIFormatTUb1
/// Name
/// OCIFormat Package ub1 Type
/// Purpose
/// Return the type value for the ub1 type.
/// Syntax
/// sword OCIFormatTUb1(void);
/// Comments
/// None
/// Parameters
/// None
/// Related Functions
/// None
///
///
/// OCIFormatTUb2
/// Name
/// OCIFormat Package ub2 Type
/// Purpose
/// Return the type value for the ub2 type.
/// Syntax
/// sword OCIFormatTUb2(void);
/// Comments
/// None
/// Parameters
/// None
/// Related Functions
/// None
///
///
/// OCIFormatTUb4
/// Name
/// OCIFormat Package ub4 Type
/// Purpose
/// Return the type value for the ub4 type.
/// Syntax
/// sword OCIFormatTUb4(void);
/// Comments
/// None
/// Parameters
/// None
/// Related Functions
/// None
///
///
/// OCIFormatTUword
/// Name
/// OCIFormat Package uword Type
/// Purpose
/// Return the type value for the uword type.
/// Syntax
/// sword OCIFormatTUword(void);
/// Comments
/// None
/// Parameters
/// None
/// Related Functions
/// None
///
///
/// OCIFormatTUbig_ora
/// Name
/// OCIFormat Package ubig_ora Type
/// Purpose
/// Return the type value for the ubig_ora type.
/// Syntax
/// sword OCIFormatTUbig_ora(void);
/// Comments
/// None
/// Parameters
/// None
/// Related Functions
/// None
///
///
/// OCIFormatTSb1
/// Name
/// OCIFormat Package sb1 Type
/// Purpose
/// Return the type value for the sb1 type.
/// Syntax
/// sword OCIFormatTSb1(void);
/// Comments
/// None
/// Parameters
/// None
/// Related Functions
/// None
///
///
/// OCIFormatTSb2
/// Name
/// OCIFormat Package sb2 Type
/// Purpose
/// Return the type value for the sb2 type.
/// Syntax
/// sword OCIFormatTSb2(void);
/// Comments
/// None
/// Parameters
/// None
/// Related Functions
/// None
///
///
/// OCIFormatTSb4
/// Name
/// OCIFormat Package sb4 Type
/// Purpose
/// Return the type value for the sb4 type.
/// Syntax
/// sword OCIFormatTSb4(void);
/// Comments
/// None
/// Parameters
/// None
/// Related Functions
/// None
///
///
/// OCIFormatTSword
/// Name
/// OCIFormat Package sword Type
/// Purpose
/// Return the type value for the sword type.
/// Syntax
/// sword OCIFormatTSword(void);
/// Comments
/// None
/// Parameters
/// None
/// Related Functions
/// None
///
///
/// OCIFormatTSbig_ora
/// Name
/// OCIFormat Package sbig_ora Type
/// Purpose
/// Return the type value for the sbig_ora type.
/// Syntax
/// sword OCIFormatTSbig_ora(void);
/// Comments
/// None
/// Parameters
/// None
/// Related Functions
/// None
///
///
/// OCIFormatTEb1
/// Name
/// OCIFormat Package eb1 Type
/// Purpose
/// Return the type value for the eb1 type.
/// Syntax
/// sword OCIFormatTEb1(void);
/// Comments
/// None
/// Parameters
/// None
/// Related Functions
/// None
///
///
/// OCIFormatTEb2
/// Name
/// OCIFormat Package eb2 Type
/// Purpose
/// Return the type value for the eb2 type.
/// Syntax
/// sword OCIFormatTEb2(void);
/// Comments
/// None
/// Parameters
/// None
/// Related Functions
/// None
///
///
/// OCIFormatTEb4
/// Name
/// OCIFormat Package eb4 Type
/// Purpose
/// Return the type value for the eb4 type.
/// Syntax
/// sword OCIFormatTEb4(void);
/// Comments
/// None
/// Parameters
/// None
/// Related Functions
/// None
///
///
/// OCIFormatTEword
/// Name
/// OCIFormat Package eword Type
/// Purpose
/// Return the type value for the eword type.
/// Syntax
/// sword OCIFormatTEword(void);
/// Comments
/// None
/// Parameters
/// None
/// Related Functions
/// None
///
///
/// OCIFormatTChar
/// Name
/// OCIFormat Package text Type
/// Purpose
/// Return the type value for the text type.
/// Syntax
/// sword OCIFormatTChar(void);
/// Comments
/// None
/// Parameters
/// None
/// Related Functions
/// None
///
///
/// OCIFormatTText
/// Name
/// OCIFormat Package *text Type
/// Purpose
/// Return the type value for the *text type.
/// Syntax
/// sword OCIFormatTText(void);
/// Comments
/// None
/// Parameters
/// None
/// Related Functions
/// None
///
///
/// OCIFormatTDouble
/// Name
/// OCIFormat Package double Type
/// Purpose
/// Return the type value for the double type.
/// Syntax
/// sword OCIFormatTDouble(void);
/// Comments
/// None
/// Parameters
/// None
/// Related Functions
/// None
///
///
/// OCIFormatDvoid
/// Name
/// OCIFormat Package void Type
/// Purpose
/// Return the type value for the void type.
/// Syntax
/// sword OCIFormatTDvoid(void);
/// Comments
/// None
/// Parameters
/// None
/// Related Functions
/// None
///
///
/// OCIFormatTEnd
/// Name
/// OCIFormat Package end Type
/// Purpose
/// Return the list terminator's "type".
/// Syntax
/// sword OCIFormatTEnd(void);
/// Comments
/// None
/// Parameters
/// None
/// Related Functions
/// None
///
///
/// OCISvcCtxToLda()
/// Name
/// OCI toggle SerVice context handle to Version 7 Lda_Def
/// Purpose
/// Toggles between a V8 service context handle and a V7 Lda_Def.
/// Syntax
/// sword OCISvcCtxToLda ( OCISvcCtx    *srvhp,
/// OCIError     *errhp,
/// Lda_Def      *ldap );
/// Comments
/// Toggles between an Oracle8 service context handle and an Oracle7 Lda_Def.
/// This function can only be called after a service context has been properly
/// initialized.
/// Once the service context has been translated to an Lda_Def, it can be used in
/// release 7.x OCI calls (e.g., obindps(), ofen()).
/// Note: If there are multiple service contexts which share the same server
/// handle, only one can be in V7 mode at any time.
/// The action of this call can be reversed by passing the resulting Lda_Def to
/// the OCILdaToSvcCtx() function.
/// Parameters
/// svchp (IN/OUT) - the service context handle.
/// errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
/// diagnostic information in the event of an error.
/// ldap (IN/OUT) - a Logon Data Area for V7-style OCI calls which is initialized
/// by this call.
/// Related Functions
/// OCILdaToSvcCtx()
///
///
///
///
/// OCITransCommit()
/// Name
/// OCI TX (transaction) CoMmit
/// Purpose
/// Commits the transaction associated with a specified service context.
/// Syntax
/// sword OCITransCommit ( OCISvcCtx    *srvcp,
/// OCIError     *errhp,
/// ub4          flags );
/// Comments
/// The transaction currently associated with the service context is committed. If
/// it is a distributed transaction that the server cannot commit, this call
/// additionally retrieves the state of the transaction from the database to be
/// returned to the user in the error handle.
/// If the application has defined multiple transactions, this function operates
/// on the transaction currently associated with the service context. If the
/// application is working with only the implicit local transaction created when
/// database changes are made, that implicit transaction is committed.
/// If the application is running in the object mode, then the modified or updated
/// objects in the object cache for this transaction are also committed.
/// The flags parameter is used for one-phase commit optimization in distributed
/// transactions. If the transaction is non-distributed, the flags parameter is
/// ignored, and OCI_DEFAULT can be passed as its value. OCI applications
/// managing global transactions should pass a value of
/// OCI_TRANS_TWOPHASE to the flags parameter for a two-phase commit. The
/// default is one-phase commit.
/// Under normal circumstances, OCITransCommit() returns with a status
/// indicating that the transaction has either been committed or rolled back. With
/// distributed transactions, it is possible that the transaction is now in-doubt
/// (i.e., neither committed nor aborted). In this case, OCITransCommit()
/// attempts to retrieve the status of the transaction from the server.
/// The status is returned.
/// Parameters
/// srvcp (IN) - the service context handle.
/// errhp (IN) - an error handle which can be passed to OCIErrorGet() for
/// diagnostic information in the event of an error.
/// flags -see the "Comments" section above.
/// Related Functions
/// OCITransRollback()
///
///
///
///
/// OCITransDetach()
/// Name
/// OCI TX (transaction) DeTach
/// Purpose
/// Detaches a transaction.
/// Syntax
/// sword OCITransDetach ( OCISvcCtx    *srvcp,
/// OCIError     *errhp,
/// ub4          flags);
/// Comments
/// Detaches a global transaction from the service context handle. The transaction
/// currently attached to the service context handle becomes inactive at the end
/// of this call. The transaction may be resumed later by calling OCITransStart(),
/// specifying  a flags value of OCI_TRANS_RESUME.
/// When a transaction is detached, the value which was specified in the timeout
/// parameter of OCITransStart() when the transaction was started is used to
/// determine the amount of time the branch can remain inactive before being
/// deleted by the server's PMON process.
/// Note: The transaction can be resumed by a different process than the one
/// that detached it, provided that the transaction has the same
/// authorization.
/// Parameters
/// srvcp (IN) - the service context handle.
/// errhp (IN) - an error handle which can be passed to OCIErrorGet() for
/// diagnostic information in the event of an error.
/// flags (IN) - you must pass a value of OCI_DEFAULT for this parameter.
/// Related Functions
/// OCITransStart()
///
///
///
/// OCITransForget()
/// Name
/// OCI TX (transaction) ForGeT
/// Purpose
/// Causes the server to forget a heuristically completed global transaction.
/// Syntax
/// sword OCITransForget ( OCISvcCtx     *svchp,
/// OCIError      *errhp,
/// ub4           flags);
///
/// Comments
///
/// Forgets a heuristically completed global transaction. The server deletes the
/// status of the transaction from the system's pending transaction table.
/// The XID of the transaction to be forgotten is set as an attribute of the
/// transaction handle (OCI_ATTR_XID).
/// Parameters
/// srvcp (IN) - the service context handle - the transaction is rolled back.
/// errhp (IN) - an error handle which can be passed to OCIErrorGet() for
/// diagnostic information in the event of an error.
/// flags (IN) - you must pass OCI_DEFAULT for this parameter.
/// Related Functions
/// OCITransCommit(), OCITransRollback()
///
///
/// OCITransMultiPrepare()
/// Name
/// OCI Trans(action) Multi-Branch Prepare
/// Purpose
/// Prepares a transaction with multiple branches in a single call.
/// Syntax
/// sword OCITransMultiPrepare ( OCISvcCtx    *svchp,
/// ub4           numBranches,
/// OCITrans     **txns,
/// OCIError     **errhp);
///
/// Comments
///
/// Prepares the specified global transaction for commit.
/// This call is valid only for distributed transactions.
/// This call is an advanced performance feature intended for use only in
/// situations where the caller is responsible for preparing all the branches
/// in a transaction.
/// Parameters
/// srvcp (IN) - the service context handle.
/// numBranches (IN) - This is the number of branches expected. It is also the
/// array size for the next two parameters.
/// txns (IN) - This is the array of transaction handles for the branches to
/// prepare. They should all have the OCI_ATTR_XID set. The global transaction
/// ID should be the same.
/// errhp (IN) - This is the array of error handles. If OCI_SUCCESS is not
/// returned, then these will indicate which branches received which errors.
/// Related Functions
/// OCITransPrepare()
///
///
/// OCITransPrepare()
/// Name
/// OCI TX (transaction) PREpare
/// Purpose
/// Prepares a transaction for commit.
/// Syntax
/// sword OCITransPrepare ( OCISvcCtx    *svchp,
/// OCIError     *errhp,
/// ub4          flags);
///
/// Comments
///
/// Prepares the specified global transaction for commit.
/// This call is valid only for distributed transactions.
/// The call returns OCI_SUCCESS_WITH_INFO if the transaction has not made
/// any changes. The error handle will indicate that the transaction is read-only.
/// The flag parameter is not currently used.
/// Parameters
/// srvcp (IN) - the service context handle.
/// errhp (IN) - an error handle which can be passed to OCIErrorGet() for
/// diagnostic information in the event of an error.
/// flags (IN) - you must pass OCI_DEFAULT for this parameter.
/// Related Functions
/// OCITransCommit(), OCITransForget()
///
///
///
///
/// OCITransRollback()
/// Name
/// OCI TX (transaction) RoLlback
/// Purpose
/// Rolls back the current transaction.
/// Syntax
/// sword OCITransRollback ( void        *svchp,
/// OCIError     *errhp,
/// ub4          flags );
/// Comments
/// The current transaction- defined as the set of statements executed since the
/// last OCITransCommit() or since OCISessionBegin()-is rolled back.
/// If the application is running under object mode then the modified or updated
/// objects in the object cache for this transaction are also rolled back.
/// An error is returned if an attempt is made to roll back a global transaction
/// that is not currently active.
/// Parameters
/// svchp (IN) - a service context handle. The transaction currently set in the
/// service context handle is rolled back.
/// errhp -(IN) - an error handle which can be passed to OCIErrorGet() for
/// diagnostic information in the event of an error.
/// flags - you must pass a value of OCI_DEFAULT for this parameter.
/// Related Functions
/// OCITransCommit()
///
///
///
///
/// OCITransStart()
/// Name
/// OCI TX (transaction) STart
/// Purpose
/// Sets the beginning of a transaction.
/// Syntax
/// sword OCITransStart ( OCISvcCtx    *svchp,
/// OCIError     *errhp,
/// uword        timeout,
/// ub4          flags);
///
/// Comments
/// This function sets the beginning of a global or serializable transaction. The
/// transaction context currently associated with the service context handle is
/// initialized at the end of the call if the flags parameter specifies that a new
/// transaction should be started.
/// The XID of the transaction is set as an attribute of the transaction handle
/// (OCI_ATTR_XID)
/// Parameters
/// svchp (IN/OUT) - the service context handle. The transaction context in the
/// service context handle is initialized at the end of the call if the flag
/// specified a new transaction to be started.
/// errhp (IN/OUT) - The OCI error handle. If there is an error, it is recorded in
/// err and this function returns OCI_ERROR. Diagnostic information can be
/// obtained by calling OCIErrorGet().
/// timeout (IN) - the time, in seconds, to wait for a transaction to become
/// available for resumption when OCI_TRANS_RESUME is specified. When
/// OCI_TRANS_NEW is specified, this value is stored and may be used later by
/// OCITransDetach().
/// flags (IN) - specifies whether a new transaction is being started or an
/// existing transaction is being resumed. Also specifies serializiability or
/// read-only status. More than a single value can be specified. By default,
/// a read/write transaction is started. The flag values are:
/// OCI_TRANS_NEW - starts a new transaction branch. By default starts a
/// tightly coupled and migratable branch.
/// OCI_TRANS_TIGHT - explicitly specifies a tightly coupled branch
/// OCI_TRANS_LOOSE - specifies a loosely coupled branch
/// OCI_TRANS_RESUME - resumes an existing transaction branch.
/// OCI_TRANS_READONLY - start a readonly transaction
/// OCI_TRANS_SERIALIZABLE - start a serializable transaction
/// Related Functions
/// OCITransDetach()
pub type OCICallbackInBind =
    ::std::option::Option<unsafe extern "C" fn(ictxp: *mut ::std::os::raw::c_void,
                                               bindp: *mut OCIBind,
                                               iter: ub4,
                                               index: ub4,
                                               bufpp: *mut *mut ::std::os::raw::c_void,
                                               alenp: *mut ub4,
                                               piecep: *mut ub1,
                                               indp: *mut *mut ::std::os::raw::c_void)
                                               -> sb4>;
pub type OCICallbackOutBind =
    ::std::option::Option<unsafe extern "C" fn(octxp: *mut ::std::os::raw::c_void,
                                               bindp: *mut OCIBind,
                                               iter: ub4,
                                               index: ub4,
                                               bufpp: *mut *mut ::std::os::raw::c_void,
                                               alenp: *mut *mut ub4,
                                               piecep: *mut ub1,
                                               indp: *mut *mut ::std::os::raw::c_void,
                                               rcodep: *mut *mut ub2)
                                               -> sb4>;
pub type OCICallbackDefine =
    ::std::option::Option<unsafe extern "C" fn(octxp: *mut ::std::os::raw::c_void,
                                               defnp: *mut OCIDefine,
                                               iter: ub4,
                                               bufpp: *mut *mut ::std::os::raw::c_void,
                                               alenp: *mut *mut ub4,
                                               piecep: *mut ub1,
                                               indp: *mut *mut ::std::os::raw::c_void,
                                               rcodep: *mut *mut ub2)
                                               -> sb4>;
pub type OCIUserCallback =
    ::std::option::Option<unsafe extern "C" fn(ctxp: *mut ::std::os::raw::c_void,
                                               hndlp: *mut ::std::os::raw::c_void,
                                               type_: ub4,
                                               fcode: ub4,
                                               when: ub4,
                                               returnCode: sword,
                                               errnop: *mut sb4,
                                               arglist: *mut __va_list_tag)
                                               -> sword>;
pub type OCIEnvCallbackType =
    ::std::option::Option<unsafe extern "C" fn(env: *mut OCIEnv,
                                               mode: ub4,
                                               xtramem_sz: usize,
                                               usrmemp: *mut ::std::os::raw::c_void,
                                               ucbDesc: *mut OCIUcb)
                                               -> sword>;
pub type OCICallbackLobRead =
    ::std::option::Option<unsafe extern "C" fn(ctxp: *mut ::std::os::raw::c_void,
                                               bufp: *const ::std::os::raw::c_void,
                                               len: ub4,
                                               piece: ub1)
                                               -> sb4>;
pub type OCICallbackLobWrite =
    ::std::option::Option<unsafe extern "C" fn(ctxp: *mut ::std::os::raw::c_void,
                                               bufp: *mut ::std::os::raw::c_void,
                                               lenp: *mut ub4,
                                               piece: *mut ub1)
                                               -> sb4>;
pub type OCICallbackLobRead2 =
    ::std::option::Option<unsafe extern "C" fn(ctxp: *mut ::std::os::raw::c_void,
                                               bufp: *const ::std::os::raw::c_void,
                                               len: oraub8,
                                               piece: ub1,
                                               changed_bufpp: *mut *mut ::std::os::raw::c_void,
                                               changed_lenp: *mut oraub8)
                                               -> sb4>;
pub type OCICallbackLobWrite2 =
    ::std::option::Option<unsafe extern "C" fn(ctxp: *mut ::std::os::raw::c_void,
                                               bufp: *mut ::std::os::raw::c_void,
                                               lenp: *mut oraub8,
                                               piece: *mut ub1,
                                               changed_bufpp: *mut *mut ::std::os::raw::c_void,
                                               changed_lenp: *mut oraub8)
                                               -> sb4>;
pub type OCICallbackLobArrayRead =
    ::std::option::Option<unsafe extern "C" fn(ctxp: *mut ::std::os::raw::c_void,
                                               array_iter: ub4,
                                               bufp: *const ::std::os::raw::c_void,
                                               len: oraub8,
                                               piece: ub1,
                                               changed_bufpp: *mut *mut ::std::os::raw::c_void,
                                               changed_lenp: *mut oraub8)
                                               -> sb4>;
pub type OCICallbackLobArrayWrite =
    ::std::option::Option<unsafe extern "C" fn(ctxp: *mut ::std::os::raw::c_void,
                                               array_iter: ub4,
                                               bufp: *mut ::std::os::raw::c_void,
                                               lenp: *mut oraub8,
                                               piece: *mut ub1,
                                               changed_bufpp: *mut *mut ::std::os::raw::c_void,
                                               changed_lenp: *mut oraub8)
                                               -> sb4>;
pub type OCICallbackLobGetDeduplicateRegions =
    ::std::option::Option<unsafe extern "C" fn(ctxp: *mut ::std::os::raw::c_void,
                                               regions: *mut OCILobRegion,
                                               count: ub4,
                                               piece: ub1,
                                               changed_reg: *mut *mut OCILobRegion,
                                               changed_count: *mut ub4)
                                               -> sb4>;
pub type OCICallbackAQEnq =
    ::std::option::Option<unsafe extern "C" fn(ctxp: *mut ::std::os::raw::c_void,
                                               payload: *mut *mut ::std::os::raw::c_void,
                                               payload_ind: *mut *mut ::std::os::raw::c_void)
                                               -> sb4>;
pub type OCICallbackAQEnqStreaming =
    ::std::option::Option<unsafe extern "C" fn(ctxp: *mut ::std::os::raw::c_void,
                                               payload: *mut *mut ::std::os::raw::c_void,
                                               payload_ind: *mut *mut ::std::os::raw::c_void,
                                               msgprop: *mut *mut OCIAQMsgProperties,
                                               tdo: *mut *mut OCIType)
                                               -> sb4>;
pub type OCICallbackAQDeq =
    ::std::option::Option<unsafe extern "C" fn(ctxp: *mut ::std::os::raw::c_void,
                                               payload: *mut *mut ::std::os::raw::c_void,
                                               payload_ind: *mut *mut ::std::os::raw::c_void)
                                               -> sb4>;
pub type OCICallbackFailover =
    ::std::option::Option<unsafe extern "C" fn(svcctx: *mut ::std::os::raw::c_void,
                                               envctx: *mut ::std::os::raw::c_void,
                                               fo_ctx: *mut ::std::os::raw::c_void,
                                               fo_type: ub4,
                                               fo_event: ub4)
                                               -> sb4>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct OCIFocbkStruct {
    pub callback_function: OCICallbackFailover,
    pub fo_ctx: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_OCIFocbkStruct() {
    assert_eq!(::std::mem::size_of::<OCIFocbkStruct>(),
               16usize,
               concat!("Size of: ", stringify!(OCIFocbkStruct)));
    assert_eq!(::std::mem::align_of::<OCIFocbkStruct>(),
               8usize,
               concat!("Alignment of ", stringify!(OCIFocbkStruct)));
    assert_eq!(unsafe { &(*(0 as *const OCIFocbkStruct)).callback_function as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(OCIFocbkStruct),
                       "::",
                       stringify!(callback_function)));
    assert_eq!(unsafe { &(*(0 as *const OCIFocbkStruct)).fo_ctx as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(OCIFocbkStruct),
                       "::",
                       stringify!(fo_ctx)));
}
impl Clone for OCIFocbkStruct {
    fn clone(&self) -> Self {
        *self
    }
}
pub type OCICallbackStmtCache =
    ::std::option::Option<unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void,
                                               stmt: *mut OCIStmt,
                                               mode: ub4)
                                               -> sword>;
pub type OCIEventCallback =
    ::std::option::Option<unsafe extern "C" fn(evtctx: *mut ::std::os::raw::c_void,
                                               eventhp: *mut OCIEvent)>;
pub type OCIRoundTripCallback =
    ::std::option::Option<unsafe extern "C" fn(rtctx: *mut ::std::os::raw::c_void,
                                               svch: *mut OCISvcCtx,
                                               userh: *mut OCISession)
                                               -> sword>;
extern "C" {
    /// ACTUAL PROTOTYPE DECLARATIONS
    pub fn OCIInitialize(mode: ub4, ctxp: *mut ::std::os::raw::c_void,
                         malocfp:
                             ::std::option::Option<unsafe extern "C" fn(ctxp:
                                                                            *mut ::std::os::raw::c_void,
                                                                        size:
                                                                            usize)
                                                       ->
                                                           *mut ::std::os::raw::c_void>,
                         ralocfp:
                             ::std::option::Option<unsafe extern "C" fn(ctxp:
                                                                            *mut ::std::os::raw::c_void,
                                                                        memptr:
                                                                            *mut ::std::os::raw::c_void,
                                                                        newsize:
                                                                            usize)
                                                       ->
                                                           *mut ::std::os::raw::c_void>,
                         mfreefp:
                             ::std::option::Option<unsafe extern "C" fn(ctxp:
                                                                            *mut ::std::os::raw::c_void,
                                                                        memptr:
                                                                            *mut ::std::os::raw::c_void)>)
-> sword;
}
extern "C" {
    pub fn OCITerminate(mode: ub4) -> sword;
}
extern "C" {
    pub fn OCIEnvCreate(envp: *mut *mut OCIEnv, mode: ub4,
                        ctxp: *mut ::std::os::raw::c_void,
                        malocfp:
                            ::std::option::Option<unsafe extern "C" fn(ctxp:
                                                                           *mut ::std::os::raw::c_void,
                                                                       size:
                                                                           usize)
                                                      ->
                                                          *mut ::std::os::raw::c_void>,
                        ralocfp:
                            ::std::option::Option<unsafe extern "C" fn(ctxp:
                                                                           *mut ::std::os::raw::c_void,
                                                                       memptr:
                                                                           *mut ::std::os::raw::c_void,
                                                                       newsize:
                                                                           usize)
                                                      ->
                                                          *mut ::std::os::raw::c_void>,
                        mfreefp:
                            ::std::option::Option<unsafe extern "C" fn(ctxp:
                                                                           *mut ::std::os::raw::c_void,
                                                                       memptr:
                                                                           *mut ::std::os::raw::c_void)>,
                        xtramem_sz: usize,
usrmempp: *mut *mut ::std::os::raw::c_void) -> sword;
}
extern "C" {
    pub fn OCIEnvNlsCreate(envp: *mut *mut OCIEnv, mode: ub4,
                           ctxp: *mut ::std::os::raw::c_void,
                           malocfp:
                               ::std::option::Option<unsafe extern "C" fn(ctxp:
                                                                              *mut ::std::os::raw::c_void,
                                                                          size:
                                                                              usize)
                                                         ->
                                                             *mut ::std::os::raw::c_void>,
                           ralocfp:
                               ::std::option::Option<unsafe extern "C" fn(ctxp:
                                                                              *mut ::std::os::raw::c_void,
                                                                          memptr:
                                                                              *mut ::std::os::raw::c_void,
                                                                          newsize:
                                                                              usize)
                                                         ->
                                                             *mut ::std::os::raw::c_void>,
                           mfreefp:
                               ::std::option::Option<unsafe extern "C" fn(ctxp:
                                                                              *mut ::std::os::raw::c_void,
                                                                          memptr:
                                                                              *mut ::std::os::raw::c_void)>,
                           xtramem_sz: usize,
                           usrmempp: *mut *mut ::std::os::raw::c_void,
charset: ub2, ncharset: ub2) -> sword;
}
extern "C" {
    pub fn OCIFEnvCreate(envp: *mut *mut OCIEnv, mode: ub4,
                         ctxp: *mut ::std::os::raw::c_void,
                         malocfp:
                             ::std::option::Option<unsafe extern "C" fn(ctxp:
                                                                            *mut ::std::os::raw::c_void,
                                                                        size:
                                                                            usize)
                                                       ->
                                                           *mut ::std::os::raw::c_void>,
                         ralocfp:
                             ::std::option::Option<unsafe extern "C" fn(ctxp:
                                                                            *mut ::std::os::raw::c_void,
                                                                        memptr:
                                                                            *mut ::std::os::raw::c_void,
                                                                        newsize:
                                                                            usize)
                                                       ->
                                                           *mut ::std::os::raw::c_void>,
                         mfreefp:
                             ::std::option::Option<unsafe extern "C" fn(ctxp:
                                                                            *mut ::std::os::raw::c_void,
                                                                        memptr:
                                                                            *mut ::std::os::raw::c_void)>,
                         xtramem_sz: usize,
                         usrmempp: *mut *mut ::std::os::raw::c_void,
fupg: *mut ::std::os::raw::c_void) -> sword;
}
extern "C" {
    pub fn OCIHandleAlloc(parenth: *const ::std::os::raw::c_void,
                          hndlpp: *mut *mut ::std::os::raw::c_void,
                          type_: ub4,
                          xtramem_sz: usize,
                          usrmempp: *mut *mut ::std::os::raw::c_void)
                          -> sword;
}
extern "C" {
    pub fn OCIHandleFree(hndlp: *mut ::std::os::raw::c_void, type_: ub4) -> sword;
}
extern "C" {
    pub fn OCIDescriptorAlloc(parenth: *const ::std::os::raw::c_void,
                              descpp: *mut *mut ::std::os::raw::c_void,
                              type_: ub4,
                              xtramem_sz: usize,
                              usrmempp: *mut *mut ::std::os::raw::c_void)
                              -> sword;
}
extern "C" {
    pub fn OCIArrayDescriptorAlloc(parenth: *const ::std::os::raw::c_void,
                                   descpp: *mut *mut ::std::os::raw::c_void,
                                   type_: ub4,
                                   array_size: ub4,
                                   xtramem_sz: usize,
                                   usrmempp: *mut *mut ::std::os::raw::c_void)
                                   -> sword;
}
extern "C" {
    pub fn OCIDescriptorFree(descp: *mut ::std::os::raw::c_void, type_: ub4) -> sword;
}
extern "C" {
    pub fn OCIArrayDescriptorFree(descp: *mut *mut ::std::os::raw::c_void, type_: ub4) -> sword;
}
extern "C" {
    pub fn OCIEnvInit(envp: *mut *mut OCIEnv,
                      mode: ub4,
                      xtramem_sz: usize,
                      usrmempp: *mut *mut ::std::os::raw::c_void)
                      -> sword;
}
extern "C" {
    pub fn OCIServerAttach(srvhp: *mut OCIServer,
                           errhp: *mut OCIError,
                           dblink: *const OraText,
                           dblink_len: sb4,
                           mode: ub4)
                           -> sword;
}
extern "C" {
    pub fn OCIServerDetach(srvhp: *mut OCIServer, errhp: *mut OCIError, mode: ub4) -> sword;
}
extern "C" {
    pub fn OCISessionBegin(svchp: *mut OCISvcCtx,
                           errhp: *mut OCIError,
                           usrhp: *mut OCISession,
                           credt: ub4,
                           mode: ub4)
                           -> sword;
}
extern "C" {
    pub fn OCISessionEnd(svchp: *mut OCISvcCtx,
                         errhp: *mut OCIError,
                         usrhp: *mut OCISession,
                         mode: ub4)
                         -> sword;
}
extern "C" {
    pub fn OCILogon(envhp: *mut OCIEnv,
                    errhp: *mut OCIError,
                    svchp: *mut *mut OCISvcCtx,
                    username: *const OraText,
                    uname_len: ub4,
                    password: *const OraText,
                    passwd_len: ub4,
                    dbname: *const OraText,
                    dbname_len: ub4)
                    -> sword;
}
extern "C" {
    pub fn OCILogon2(envhp: *mut OCIEnv,
                     errhp: *mut OCIError,
                     svchp: *mut *mut OCISvcCtx,
                     username: *const OraText,
                     uname_len: ub4,
                     password: *const OraText,
                     passwd_len: ub4,
                     dbname: *const OraText,
                     dbname_len: ub4,
                     mode: ub4)
                     -> sword;
}
extern "C" {
    pub fn OCILogoff(svchp: *mut OCISvcCtx, errhp: *mut OCIError) -> sword;
}
extern "C" {
    pub fn OCIPasswordChange(svchp: *mut OCISvcCtx,
                             errhp: *mut OCIError,
                             user_name: *const OraText,
                             usernm_len: ub4,
                             opasswd: *const OraText,
                             opasswd_len: ub4,
                             npasswd: *const OraText,
                             npasswd_len: ub4,
                             mode: ub4)
                             -> sword;
}
extern "C" {
    pub fn OCIStmtPrepare(stmtp: *mut OCIStmt,
                          errhp: *mut OCIError,
                          stmt: *const OraText,
                          stmt_len: ub4,
                          language: ub4,
                          mode: ub4)
                          -> sword;
}
extern "C" {
    pub fn OCIStmtPrepare2(svchp: *mut OCISvcCtx,
                           stmtp: *mut *mut OCIStmt,
                           errhp: *mut OCIError,
                           stmt: *const OraText,
                           stmt_len: ub4,
                           key: *const OraText,
                           key_len: ub4,
                           language: ub4,
                           mode: ub4)
                           -> sword;
}
extern "C" {
    pub fn OCIStmtRelease(stmtp: *mut OCIStmt,
                          errhp: *mut OCIError,
                          key: *const OraText,
                          key_len: ub4,
                          mode: ub4)
                          -> sword;
}
extern "C" {
    pub fn OCIBindByPos(stmtp: *mut OCIStmt,
                        bindp: *mut *mut OCIBind,
                        errhp: *mut OCIError,
                        position: ub4,
                        valuep: *mut ::std::os::raw::c_void,
                        value_sz: sb4,
                        dty: ub2,
                        indp: *mut ::std::os::raw::c_void,
                        alenp: *mut ub2,
                        rcodep: *mut ub2,
                        maxarr_len: ub4,
                        curelep: *mut ub4,
                        mode: ub4)
                        -> sword;
}
extern "C" {
    pub fn OCIBindByPos2(stmtp: *mut OCIStmt,
                         bindp: *mut *mut OCIBind,
                         errhp: *mut OCIError,
                         position: ub4,
                         valuep: *mut ::std::os::raw::c_void,
                         value_sz: sb8,
                         dty: ub2,
                         indp: *mut ::std::os::raw::c_void,
                         alenp: *mut ub4,
                         rcodep: *mut ub2,
                         maxarr_len: ub4,
                         curelep: *mut ub4,
                         mode: ub4)
                         -> sword;
}
extern "C" {
    pub fn OCIBindByName(stmtp: *mut OCIStmt,
                         bindp: *mut *mut OCIBind,
                         errhp: *mut OCIError,
                         placeholder: *const OraText,
                         placeh_len: sb4,
                         valuep: *mut ::std::os::raw::c_void,
                         value_sz: sb4,
                         dty: ub2,
                         indp: *mut ::std::os::raw::c_void,
                         alenp: *mut ub2,
                         rcodep: *mut ub2,
                         maxarr_len: ub4,
                         curelep: *mut ub4,
                         mode: ub4)
                         -> sword;
}
extern "C" {
    pub fn OCIBindByName2(stmtp: *mut OCIStmt,
                          bindp: *mut *mut OCIBind,
                          errhp: *mut OCIError,
                          placeholder: *const OraText,
                          placeh_len: sb4,
                          valuep: *mut ::std::os::raw::c_void,
                          value_sz: sb8,
                          dty: ub2,
                          indp: *mut ::std::os::raw::c_void,
                          alenp: *mut ub4,
                          rcodep: *mut ub2,
                          maxarr_len: ub4,
                          curelep: *mut ub4,
                          mode: ub4)
                          -> sword;
}
extern "C" {
    pub fn OCIBindObject(bindp: *mut OCIBind,
                         errhp: *mut OCIError,
                         type_: *const OCIType,
                         pgvpp: *mut *mut ::std::os::raw::c_void,
                         pvszsp: *mut ub4,
                         indpp: *mut *mut ::std::os::raw::c_void,
                         indszp: *mut ub4)
                         -> sword;
}
extern "C" {
    pub fn OCIBindDynamic(bindp: *mut OCIBind,
                          errhp: *mut OCIError,
                          ictxp: *mut ::std::os::raw::c_void,
                          icbfp: OCICallbackInBind,
                          octxp: *mut ::std::os::raw::c_void,
                          ocbfp: OCICallbackOutBind)
                          -> sword;
}
extern "C" {
    pub fn OCIBindArrayOfStruct(bindp: *mut OCIBind,
                                errhp: *mut OCIError,
                                pvskip: ub4,
                                indskip: ub4,
                                alskip: ub4,
                                rcskip: ub4)
                                -> sword;
}
extern "C" {
    pub fn OCIStmtGetPieceInfo(stmtp: *mut OCIStmt,
                               errhp: *mut OCIError,
                               hndlpp: *mut *mut ::std::os::raw::c_void,
                               typep: *mut ub4,
                               in_outp: *mut ub1,
                               iterp: *mut ub4,
                               idxp: *mut ub4,
                               piecep: *mut ub1)
                               -> sword;
}
extern "C" {
    pub fn OCIStmtSetPieceInfo(hndlp: *mut ::std::os::raw::c_void,
                               type_: ub4,
                               errhp: *mut OCIError,
                               bufp: *const ::std::os::raw::c_void,
                               alenp: *mut ub4,
                               piece: ub1,
                               indp: *const ::std::os::raw::c_void,
                               rcodep: *mut ub2)
                               -> sword;
}
extern "C" {
    pub fn OCIStmtExecute(svchp: *mut OCISvcCtx,
                          stmtp: *mut OCIStmt,
                          errhp: *mut OCIError,
                          iters: ub4,
                          rowoff: ub4,
                          snap_in: *const OCISnapshot,
                          snap_out: *mut OCISnapshot,
                          mode: ub4)
                          -> sword;
}
extern "C" {
    pub fn OCIStmtGetNextResult(stmthp: *mut OCIStmt,
                                errhp: *mut OCIError,
                                result: *mut *mut ::std::os::raw::c_void,
                                rtype: *mut ub4,
                                mode: ub4)
                                -> sword;
}
extern "C" {
    pub fn OCIDefineByPos(stmtp: *mut OCIStmt,
                          defnp: *mut *mut OCIDefine,
                          errhp: *mut OCIError,
                          position: ub4,
                          valuep: *mut ::std::os::raw::c_void,
                          value_sz: sb4,
                          dty: ub2,
                          indp: *mut ::std::os::raw::c_void,
                          rlenp: *mut ub2,
                          rcodep: *mut ub2,
                          mode: ub4)
                          -> sword;
}
extern "C" {
    pub fn OCIDefineByPos2(stmtp: *mut OCIStmt,
                           defnp: *mut *mut OCIDefine,
                           errhp: *mut OCIError,
                           position: ub4,
                           valuep: *mut ::std::os::raw::c_void,
                           value_sz: sb8,
                           dty: ub2,
                           indp: *mut ::std::os::raw::c_void,
                           rlenp: *mut ub4,
                           rcodep: *mut ub2,
                           mode: ub4)
                           -> sword;
}
extern "C" {
    pub fn OCIDefineObject(defnp: *mut OCIDefine,
                           errhp: *mut OCIError,
                           type_: *const OCIType,
                           pgvpp: *mut *mut ::std::os::raw::c_void,
                           pvszsp: *mut ub4,
                           indpp: *mut *mut ::std::os::raw::c_void,
                           indszp: *mut ub4)
                           -> sword;
}
extern "C" {
    pub fn OCIDefineDynamic(defnp: *mut OCIDefine,
                            errhp: *mut OCIError,
                            octxp: *mut ::std::os::raw::c_void,
                            ocbfp: OCICallbackDefine)
                            -> sword;
}
extern "C" {
    pub fn OCIRowidToChar(rowidDesc: *mut OCIRowid,
                          outbfp: *mut OraText,
                          outbflp: *mut ub2,
                          errhp: *mut OCIError)
                          -> sword;
}
extern "C" {
    pub fn OCIDefineArrayOfStruct(defnp: *mut OCIDefine,
                                  errhp: *mut OCIError,
                                  pvskip: ub4,
                                  indskip: ub4,
                                  rlskip: ub4,
                                  rcskip: ub4)
                                  -> sword;
}
extern "C" {
    pub fn OCIStmtFetch(stmtp: *mut OCIStmt,
                        errhp: *mut OCIError,
                        nrows: ub4,
                        orientation: ub2,
                        mode: ub4)
                        -> sword;
}
extern "C" {
    pub fn OCIStmtFetch2(stmtp: *mut OCIStmt,
                         errhp: *mut OCIError,
                         nrows: ub4,
                         orientation: ub2,
                         scrollOffset: sb4,
                         mode: ub4)
                         -> sword;
}
extern "C" {
    pub fn OCIStmtGetBindInfo(stmtp: *mut OCIStmt,
                              errhp: *mut OCIError,
                              size: ub4,
                              startloc: ub4,
                              found: *mut sb4,
                              bvnp: *mut *mut OraText,
                              bvnl: *mut ub1,
                              invp: *mut *mut OraText,
                              inpl: *mut ub1,
                              dupl: *mut ub1,
                              hndl: *mut *mut OCIBind)
                              -> sword;
}
extern "C" {
    pub fn OCIDescribeAny(svchp: *mut OCISvcCtx,
                          errhp: *mut OCIError,
                          objptr: *mut ::std::os::raw::c_void,
                          objnm_len: ub4,
                          objptr_typ: ub1,
                          info_level: ub1,
                          objtyp: ub1,
                          dschp: *mut OCIDescribe)
                          -> sword;
}
extern "C" {
    pub fn OCIParamGet(hndlp: *const ::std::os::raw::c_void,
                       htype: ub4,
                       errhp: *mut OCIError,
                       parmdpp: *mut *mut ::std::os::raw::c_void,
                       pos: ub4)
                       -> sword;
}
extern "C" {
    pub fn OCIParamSet(hdlp: *mut ::std::os::raw::c_void,
                       htyp: ub4,
                       errhp: *mut OCIError,
                       dscp: *const ::std::os::raw::c_void,
                       dtyp: ub4,
                       pos: ub4)
                       -> sword;
}
extern "C" {
    pub fn OCITransStart(svchp: *mut OCISvcCtx,
                         errhp: *mut OCIError,
                         timeout: uword,
                         flags: ub4)
                         -> sword;
}
extern "C" {
    pub fn OCITransDetach(svchp: *mut OCISvcCtx, errhp: *mut OCIError, flags: ub4) -> sword;
}
extern "C" {
    pub fn OCITransCommit(svchp: *mut OCISvcCtx, errhp: *mut OCIError, flags: ub4) -> sword;
}
extern "C" {
    pub fn OCITransRollback(svchp: *mut OCISvcCtx, errhp: *mut OCIError, flags: ub4) -> sword;
}
extern "C" {
    pub fn OCITransPrepare(svchp: *mut OCISvcCtx, errhp: *mut OCIError, flags: ub4) -> sword;
}
extern "C" {
    pub fn OCITransMultiPrepare(svchp: *mut OCISvcCtx,
                                numBranches: ub4,
                                txns: *mut *mut OCITrans,
                                errhp: *mut *mut OCIError)
                                -> sword;
}
extern "C" {
    pub fn OCITransForget(svchp: *mut OCISvcCtx, errhp: *mut OCIError, flags: ub4) -> sword;
}
extern "C" {
    pub fn OCIErrorGet(hndlp: *mut ::std::os::raw::c_void,
                       recordno: ub4,
                       sqlstate: *mut OraText,
                       errcodep: *mut sb4,
                       bufp: *mut OraText,
                       bufsiz: ub4,
                       type_: ub4)
                       -> sword;
}
extern "C" {
    pub fn OCILobAppend(svchp: *mut OCISvcCtx,
                        errhp: *mut OCIError,
                        dst_locp: *mut OCILobLocator,
                        src_locp: *mut OCILobLocator)
                        -> sword;
}
extern "C" {
    pub fn OCILobAssign(envhp: *mut OCIEnv,
                        errhp: *mut OCIError,
                        src_locp: *const OCILobLocator,
                        dst_locpp: *mut *mut OCILobLocator)
                        -> sword;
}
extern "C" {
    pub fn OCILobCharSetForm(envhp: *mut OCIEnv,
                             errhp: *mut OCIError,
                             locp: *const OCILobLocator,
                             csfrm: *mut ub1)
                             -> sword;
}
extern "C" {
    pub fn OCILobCharSetId(envhp: *mut OCIEnv,
                           errhp: *mut OCIError,
                           locp: *const OCILobLocator,
                           csid: *mut ub2)
                           -> sword;
}
extern "C" {
    pub fn OCILobCopy(svchp: *mut OCISvcCtx,
                      errhp: *mut OCIError,
                      dst_locp: *mut OCILobLocator,
                      src_locp: *mut OCILobLocator,
                      amount: ub4,
                      dst_offset: ub4,
                      src_offset: ub4)
                      -> sword;
}
extern "C" {
    pub fn OCILobCreateTemporary(svchp: *mut OCISvcCtx,
                                 errhp: *mut OCIError,
                                 locp: *mut OCILobLocator,
                                 csid: ub2,
                                 csfrm: ub1,
                                 lobtype: ub1,
                                 cache: boolean,
                                 duration: OCIDuration)
                                 -> sword;
}
extern "C" {
    pub fn OCILobClose(svchp: *mut OCISvcCtx,
                       errhp: *mut OCIError,
                       locp: *mut OCILobLocator)
                       -> sword;
}
extern "C" {
    pub fn OCILobDisableBuffering(svchp: *mut OCISvcCtx,
                                  errhp: *mut OCIError,
                                  locp: *mut OCILobLocator)
                                  -> sword;
}
extern "C" {
    pub fn OCILobEnableBuffering(svchp: *mut OCISvcCtx,
                                 errhp: *mut OCIError,
                                 locp: *mut OCILobLocator)
                                 -> sword;
}
extern "C" {
    pub fn OCILobErase(svchp: *mut OCISvcCtx,
                       errhp: *mut OCIError,
                       locp: *mut OCILobLocator,
                       amount: *mut ub4,
                       offset: ub4)
                       -> sword;
}
extern "C" {
    pub fn OCILobFileClose(svchp: *mut OCISvcCtx,
                           errhp: *mut OCIError,
                           filep: *mut OCILobLocator)
                           -> sword;
}
extern "C" {
    pub fn OCILobFileCloseAll(svchp: *mut OCISvcCtx, errhp: *mut OCIError) -> sword;
}
extern "C" {
    pub fn OCILobFileExists(svchp: *mut OCISvcCtx,
                            errhp: *mut OCIError,
                            filep: *mut OCILobLocator,
                            flag: *mut boolean)
                            -> sword;
}
extern "C" {
    pub fn OCILobFileGetName(envhp: *mut OCIEnv,
                             errhp: *mut OCIError,
                             filep: *const OCILobLocator,
                             dir_alias: *mut OraText,
                             d_length: *mut ub2,
                             filename: *mut OraText,
                             f_length: *mut ub2)
                             -> sword;
}
extern "C" {
    pub fn OCILobFileIsOpen(svchp: *mut OCISvcCtx,
                            errhp: *mut OCIError,
                            filep: *mut OCILobLocator,
                            flag: *mut boolean)
                            -> sword;
}
extern "C" {
    pub fn OCILobFileOpen(svchp: *mut OCISvcCtx,
                          errhp: *mut OCIError,
                          filep: *mut OCILobLocator,
                          mode: ub1)
                          -> sword;
}
extern "C" {
    pub fn OCILobFileSetName(envhp: *mut OCIEnv,
                             errhp: *mut OCIError,
                             filepp: *mut *mut OCILobLocator,
                             dir_alias: *const OraText,
                             d_length: ub2,
                             filename: *const OraText,
                             f_length: ub2)
                             -> sword;
}
extern "C" {
    pub fn OCILobFlushBuffer(svchp: *mut OCISvcCtx,
                             errhp: *mut OCIError,
                             locp: *mut OCILobLocator,
                             flag: ub4)
                             -> sword;
}
extern "C" {
    pub fn OCILobFreeTemporary(svchp: *mut OCISvcCtx,
                               errhp: *mut OCIError,
                               locp: *mut OCILobLocator)
                               -> sword;
}
extern "C" {
    pub fn OCILobGetChunkSize(svchp: *mut OCISvcCtx,
                              errhp: *mut OCIError,
                              locp: *mut OCILobLocator,
                              chunksizep: *mut ub4)
                              -> sword;
}
extern "C" {
    pub fn OCILobGetLength(svchp: *mut OCISvcCtx,
                           errhp: *mut OCIError,
                           locp: *mut OCILobLocator,
                           lenp: *mut ub4)
                           -> sword;
}
extern "C" {
    pub fn OCILobIsEqual(envhp: *mut OCIEnv,
                         x: *const OCILobLocator,
                         y: *const OCILobLocator,
                         is_equal: *mut boolean)
                         -> sword;
}
extern "C" {
    pub fn OCILobIsOpen(svchp: *mut OCISvcCtx,
                        errhp: *mut OCIError,
                        locp: *mut OCILobLocator,
                        flag: *mut boolean)
                        -> sword;
}
extern "C" {
    pub fn OCILobIsTemporary(envp: *mut OCIEnv,
                             errhp: *mut OCIError,
                             locp: *mut OCILobLocator,
                             is_temporary: *mut boolean)
                             -> sword;
}
extern "C" {
    pub fn OCILobLoadFromFile(svchp: *mut OCISvcCtx,
                              errhp: *mut OCIError,
                              dst_locp: *mut OCILobLocator,
                              src_filep: *mut OCILobLocator,
                              amount: ub4,
                              dst_offset: ub4,
                              src_offset: ub4)
                              -> sword;
}
extern "C" {
    pub fn OCILobLocatorAssign(svchp: *mut OCISvcCtx,
                               errhp: *mut OCIError,
                               src_locp: *const OCILobLocator,
                               dst_locpp: *mut *mut OCILobLocator)
                               -> sword;
}
extern "C" {
    pub fn OCILobLocatorIsInit(envhp: *mut OCIEnv,
                               errhp: *mut OCIError,
                               locp: *const OCILobLocator,
                               is_initialized: *mut boolean)
                               -> sword;
}
extern "C" {
    pub fn OCILobOpen(svchp: *mut OCISvcCtx,
                      errhp: *mut OCIError,
                      locp: *mut OCILobLocator,
                      mode: ub1)
                      -> sword;
}
extern "C" {
    pub fn OCILobRead(svchp: *mut OCISvcCtx,
                      errhp: *mut OCIError,
                      locp: *mut OCILobLocator,
                      amtp: *mut ub4,
                      offset: ub4,
                      bufp: *mut ::std::os::raw::c_void,
                      bufl: ub4,
                      ctxp: *mut ::std::os::raw::c_void,
                      cbfp: OCICallbackLobRead,
                      csid: ub2,
                      csfrm: ub1)
                      -> sword;
}
extern "C" {
    pub fn OCILobTrim(svchp: *mut OCISvcCtx,
                      errhp: *mut OCIError,
                      locp: *mut OCILobLocator,
                      newlen: ub4)
                      -> sword;
}
extern "C" {
    pub fn OCILobWrite(svchp: *mut OCISvcCtx,
                       errhp: *mut OCIError,
                       locp: *mut OCILobLocator,
                       amtp: *mut ub4,
                       offset: ub4,
                       bufp: *mut ::std::os::raw::c_void,
                       buflen: ub4,
                       piece: ub1,
                       ctxp: *mut ::std::os::raw::c_void,
                       cbfp: OCICallbackLobWrite,
                       csid: ub2,
                       csfrm: ub1)
                       -> sword;
}
extern "C" {
    pub fn OCILobGetDeduplicateRegions(svchp: *mut OCISvcCtx,
                                       errhp: *mut OCIError,
                                       locp: *mut OCILobLocator,
                                       regp: *mut OCILobRegion,
                                       count: *mut ub4,
                                       piece: ub1,
                                       ctxp: *mut ::std::os::raw::c_void,
                                       cbfp: OCICallbackLobGetDeduplicateRegions)
                                       -> sword;
}
extern "C" {
    pub fn OCILobWriteAppend(svchp: *mut OCISvcCtx,
                             errhp: *mut OCIError,
                             lobp: *mut OCILobLocator,
                             amtp: *mut ub4,
                             bufp: *mut ::std::os::raw::c_void,
                             bufl: ub4,
                             piece: ub1,
                             ctxp: *mut ::std::os::raw::c_void,
                             cbfp: OCICallbackLobWrite,
                             csid: ub2,
                             csfrm: ub1)
                             -> sword;
}
extern "C" {
    pub fn OCIBreak(hndlp: *mut ::std::os::raw::c_void, errhp: *mut OCIError) -> sword;
}
extern "C" {
    pub fn OCIReset(hndlp: *mut ::std::os::raw::c_void, errhp: *mut OCIError) -> sword;
}
extern "C" {
    pub fn OCIServerVersion(hndlp: *mut ::std::os::raw::c_void,
                            errhp: *mut OCIError,
                            bufp: *mut OraText,
                            bufsz: ub4,
                            hndltype: ub1)
                            -> sword;
}
extern "C" {
    pub fn OCIServerRelease(hndlp: *mut ::std::os::raw::c_void,
                            errhp: *mut OCIError,
                            bufp: *mut OraText,
                            bufsz: ub4,
                            hndltype: ub1,
                            version: *mut ub4)
                            -> sword;
}
extern "C" {
    pub fn OCIAttrGet(trgthndlp: *const ::std::os::raw::c_void,
                      trghndltyp: ub4,
                      attributep: *mut ::std::os::raw::c_void,
                      sizep: *mut ub4,
                      attrtype: ub4,
                      errhp: *mut OCIError)
                      -> sword;
}
extern "C" {
    pub fn OCIAttrSet(trgthndlp: *mut ::std::os::raw::c_void,
                      trghndltyp: ub4,
                      attributep: *mut ::std::os::raw::c_void,
                      size: ub4,
                      attrtype: ub4,
                      errhp: *mut OCIError)
                      -> sword;
}
extern "C" {
    pub fn OCISvcCtxToLda(svchp: *mut OCISvcCtx,
                          errhp: *mut OCIError,
                          ldap: *mut Lda_Def)
                          -> sword;
}
extern "C" {
    pub fn OCILdaToSvcCtx(svchpp: *mut *mut OCISvcCtx,
                          errhp: *mut OCIError,
                          ldap: *mut Lda_Def)
                          -> sword;
}
extern "C" {
    pub fn OCIResultSetToStmt(rsetdp: *mut OCIResult, errhp: *mut OCIError) -> sword;
}
extern "C" {
    pub fn OCIFileClose(hndl: *mut ::std::os::raw::c_void,
                        err: *mut OCIError,
                        filep: *mut OCIFileObject)
                        -> sword;
}
extern "C" {
    pub fn OCIUserCallbackRegister(hndlp: *mut ::std::os::raw::c_void,
                                   type_: ub4,
                                   ehndlp: *mut ::std::os::raw::c_void,
                                   callback: OCIUserCallback,
                                   ctxp: *mut ::std::os::raw::c_void,
                                   fcode: ub4,
                                   when: ub4,
                                   ucbDesc: *mut OCIUcb)
                                   -> sword;
}
extern "C" {
    pub fn OCIUserCallbackGet(hndlp: *mut ::std::os::raw::c_void,
                              type_: ub4,
                              ehndlp: *mut ::std::os::raw::c_void,
                              fcode: ub4,
                              when: ub4,
                              callbackp: *mut OCIUserCallback,
                              ctxpp: *mut *mut ::std::os::raw::c_void,
                              ucbDesc: *mut OCIUcb)
                              -> sword;
}
extern "C" {
    pub fn OCISharedLibInit(metaCtx: *mut ::std::os::raw::c_void,
                            libCtx: *mut ::std::os::raw::c_void,
                            argfmt: ub4,
                            argc: sword,
                            argv: *mut *mut ::std::os::raw::c_void,
                            envCallback: OCIEnvCallbackType)
                            -> sword;
}
extern "C" {
    pub fn OCIFileExists(hndl: *mut ::std::os::raw::c_void,
                         err: *mut OCIError,
                         filename: *mut OraText,
                         path: *mut OraText,
                         flag: *mut ub1)
                         -> sword;
}
extern "C" {
    pub fn OCIFileFlush(hndl: *mut ::std::os::raw::c_void,
                        err: *mut OCIError,
                        filep: *mut OCIFileObject)
                        -> sword;
}
extern "C" {
    pub fn OCIFileGetLength(hndl: *mut ::std::os::raw::c_void,
                            err: *mut OCIError,
                            filename: *mut OraText,
                            path: *mut OraText,
                            lenp: *mut ubig_ora)
                            -> sword;
}
extern "C" {
    pub fn OCIFileInit(hndl: *mut ::std::os::raw::c_void, err: *mut OCIError) -> sword;
}
extern "C" {
    pub fn OCIFileOpen(hndl: *mut ::std::os::raw::c_void,
                       err: *mut OCIError,
                       filep: *mut *mut OCIFileObject,
                       filename: *mut OraText,
                       path: *mut OraText,
                       mode: ub4,
                       create: ub4,
                       type_: ub4)
                       -> sword;
}
extern "C" {
    pub fn OCIFileRead(hndl: *mut ::std::os::raw::c_void,
                       err: *mut OCIError,
                       filep: *mut OCIFileObject,
                       bufp: *mut ::std::os::raw::c_void,
                       bufl: ub4,
                       bytesread: *mut ub4)
                       -> sword;
}
extern "C" {
    pub fn OCIFileSeek(hndl: *mut ::std::os::raw::c_void,
                       err: *mut OCIError,
                       filep: *mut OCIFileObject,
                       origin: uword,
                       offset: ubig_ora,
                       dir: sb1)
                       -> sword;
}
extern "C" {
    pub fn OCIFileTerm(hndl: *mut ::std::os::raw::c_void, err: *mut OCIError) -> sword;
}
extern "C" {
    pub fn OCIFileWrite(hndl: *mut ::std::os::raw::c_void,
                        err: *mut OCIError,
                        filep: *mut OCIFileObject,
                        bufp: *mut ::std::os::raw::c_void,
                        buflen: ub4,
                        byteswritten: *mut ub4)
                        -> sword;
}
extern "C" {
    pub fn OCILobCopy2(svchp: *mut OCISvcCtx,
                       errhp: *mut OCIError,
                       dst_locp: *mut OCILobLocator,
                       src_locp: *mut OCILobLocator,
                       amount: oraub8,
                       dst_offset: oraub8,
                       src_offset: oraub8)
                       -> sword;
}
extern "C" {
    pub fn OCILobErase2(svchp: *mut OCISvcCtx,
                        errhp: *mut OCIError,
                        locp: *mut OCILobLocator,
                        amount: *mut oraub8,
                        offset: oraub8)
                        -> sword;
}
extern "C" {
    pub fn OCILobGetLength2(svchp: *mut OCISvcCtx,
                            errhp: *mut OCIError,
                            locp: *mut OCILobLocator,
                            lenp: *mut oraub8)
                            -> sword;
}
extern "C" {
    pub fn OCILobLoadFromFile2(svchp: *mut OCISvcCtx,
                               errhp: *mut OCIError,
                               dst_locp: *mut OCILobLocator,
                               src_filep: *mut OCILobLocator,
                               amount: oraub8,
                               dst_offset: oraub8,
                               src_offset: oraub8)
                               -> sword;
}
extern "C" {
    pub fn OCILobRead2(svchp: *mut OCISvcCtx,
                       errhp: *mut OCIError,
                       locp: *mut OCILobLocator,
                       byte_amtp: *mut oraub8,
                       char_amtp: *mut oraub8,
                       offset: oraub8,
                       bufp: *mut ::std::os::raw::c_void,
                       bufl: oraub8,
                       piece: ub1,
                       ctxp: *mut ::std::os::raw::c_void,
                       cbfp: OCICallbackLobRead2,
                       csid: ub2,
                       csfrm: ub1)
                       -> sword;
}
extern "C" {
    pub fn OCILobArrayRead(svchp: *mut OCISvcCtx,
                           errhp: *mut OCIError,
                           array_iter: *mut ub4,
                           lobp_arr: *mut *mut OCILobLocator,
                           byte_amt_arr: *mut oraub8,
                           char_amt_arr: *mut oraub8,
                           offset_arr: *mut oraub8,
                           bufp_arr: *mut *mut ::std::os::raw::c_void,
                           bufl_arr: *mut oraub8,
                           piece: ub1,
                           ctxp: *mut ::std::os::raw::c_void,
                           cbfp: OCICallbackLobArrayRead,
                           csid: ub2,
                           csfrm: ub1)
                           -> sword;
}
extern "C" {
    pub fn OCILobTrim2(svchp: *mut OCISvcCtx,
                       errhp: *mut OCIError,
                       locp: *mut OCILobLocator,
                       newlen: oraub8)
                       -> sword;
}
extern "C" {
    pub fn OCILobWrite2(svchp: *mut OCISvcCtx,
                        errhp: *mut OCIError,
                        locp: *mut OCILobLocator,
                        byte_amtp: *mut oraub8,
                        char_amtp: *mut oraub8,
                        offset: oraub8,
                        bufp: *mut ::std::os::raw::c_void,
                        buflen: oraub8,
                        piece: ub1,
                        ctxp: *mut ::std::os::raw::c_void,
                        cbfp: OCICallbackLobWrite2,
                        csid: ub2,
                        csfrm: ub1)
                        -> sword;
}
extern "C" {
    pub fn OCILobArrayWrite(svchp: *mut OCISvcCtx,
                            errhp: *mut OCIError,
                            array_iter: *mut ub4,
                            lobp_arr: *mut *mut OCILobLocator,
                            byte_amt_arr: *mut oraub8,
                            char_amt_arr: *mut oraub8,
                            offset_arr: *mut oraub8,
                            bufp_arr: *mut *mut ::std::os::raw::c_void,
                            bufl_arr: *mut oraub8,
                            piece: ub1,
                            ctxp: *mut ::std::os::raw::c_void,
                            cbfp: OCICallbackLobArrayWrite,
                            csid: ub2,
                            csfrm: ub1)
                            -> sword;
}
extern "C" {
    pub fn OCILobWriteAppend2(svchp: *mut OCISvcCtx,
                              errhp: *mut OCIError,
                              lobp: *mut OCILobLocator,
                              byte_amtp: *mut oraub8,
                              char_amtp: *mut oraub8,
                              bufp: *mut ::std::os::raw::c_void,
                              bufl: oraub8,
                              piece: ub1,
                              ctxp: *mut ::std::os::raw::c_void,
                              cbfp: OCICallbackLobWrite2,
                              csid: ub2,
                              csfrm: ub1)
                              -> sword;
}
extern "C" {
    pub fn OCILobGetStorageLimit(svchp: *mut OCISvcCtx,
                                 errhp: *mut OCIError,
                                 lobp: *mut OCILobLocator,
                                 limitp: *mut oraub8)
                                 -> sword;
}
extern "C" {
    pub fn OCILobGetOptions(svchp: *mut OCISvcCtx,
                            errhp: *mut OCIError,
                            lobp: *mut OCILobLocator,
                            optypes: ub4,
                            optionsp: *mut ::std::os::raw::c_void,
                            optionslenp: *mut ub4,
                            mode: ub4)
                            -> sword;
}
extern "C" {
    pub fn OCILobSetOptions(svchp: *mut OCISvcCtx,
                            errhp: *mut OCIError,
                            lobp: *mut OCILobLocator,
                            optypes: ub4,
                            optionsp: *mut ::std::os::raw::c_void,
                            optionslen: ub4,
                            mode: ub4)
                            -> sword;
}
extern "C" {
    pub fn OCILobGetContentType(svchp: *mut OCISvcCtx,
                                errhp: *mut OCIError,
                                lobp: *mut OCILobLocator,
                                contenttypep: *mut oratext,
                                contenttypelenp: *mut ub4,
                                mode: ub4)
                                -> sword;
}
extern "C" {
    pub fn OCILobSetContentType(svchp: *mut OCISvcCtx,
                                errhp: *mut OCIError,
                                lobp: *mut OCILobLocator,
                                contenttypep: *const oratext,
                                contenttypelen: ub4,
                                mode: ub4)
                                -> sword;
}
extern "C" {
    pub fn OCISecurityInitialize(sechandle: *mut OCISecurity,
                                 error_handle: *mut OCIError)
                                 -> sword;
}
extern "C" {
    pub fn OCISecurityTerminate(sechandle: *mut OCISecurity, error_handle: *mut OCIError) -> sword;
}
extern "C" {
    pub fn OCISecurityOpenWallet(osshandle: *mut OCISecurity,
                                 error_handle: *mut OCIError,
                                 wrllen: usize,
                                 wallet_resource_locator: *mut OraText,
                                 pwdlen: usize,
                                 password: *mut OraText,
                                 wallet: *mut nzttWallet)
                                 -> sword;
}
extern "C" {
    pub fn OCISecurityCloseWallet(osshandle: *mut OCISecurity,
                                  error_handle: *mut OCIError,
                                  wallet: *mut nzttWallet)
                                  -> sword;
}
extern "C" {
    pub fn OCISecurityCreateWallet(osshandle: *mut OCISecurity,
                                   error_handle: *mut OCIError,
                                   wrllen: usize,
                                   wallet_resource_locator: *mut OraText,
                                   pwdlen: usize,
                                   password: *mut OraText,
                                   wallet: *mut nzttWallet)
                                   -> sword;
}
extern "C" {
    pub fn OCISecurityDestroyWallet(osshandle: *mut OCISecurity,
                                    error_handle: *mut OCIError,
                                    wrllen: usize,
                                    wallet_resource_locator: *mut OraText,
                                    pwdlen: usize,
                                    password: *mut OraText)
                                    -> sword;
}
extern "C" {
    pub fn OCISecurityStorePersona(osshandle: *mut OCISecurity,
                                   error_handle: *mut OCIError,
                                   persona: *mut *mut nzttPersona,
                                   wallet: *mut nzttWallet)
                                   -> sword;
}
extern "C" {
    pub fn OCISecurityOpenPersona(osshandle: *mut OCISecurity,
                                  error_handle: *mut OCIError,
                                  persona: *mut nzttPersona)
                                  -> sword;
}
extern "C" {
    pub fn OCISecurityClosePersona(osshandle: *mut OCISecurity,
                                   error_handle: *mut OCIError,
                                   persona: *mut nzttPersona)
                                   -> sword;
}
extern "C" {
    pub fn OCISecurityRemovePersona(osshandle: *mut OCISecurity,
                                    error_handle: *mut OCIError,
                                    persona: *mut *mut nzttPersona)
                                    -> sword;
}
extern "C" {
    pub fn OCISecurityCreatePersona(osshandle: *mut OCISecurity,
                                    error_handle: *mut OCIError,
                                    identity_type: nzttIdentType,
                                    cipher_type: nzttCipherType,
                                    desc: *mut nzttPersonaDesc,
                                    persona: *mut *mut nzttPersona)
                                    -> sword;
}
extern "C" {
    pub fn OCISecuritySetProtection(osshandle: *mut OCISecurity,
                                    error_handle: *mut OCIError,
                                    persona: *mut nzttPersona,
                                    crypto_engine_function: nzttcef,
                                    data_unit_format: nztttdufmt,
                                    protection_info: *mut nzttProtInfo)
                                    -> sword;
}
extern "C" {
    pub fn OCISecurityGetProtection(osshandle: *mut OCISecurity,
                                    error_handle: *mut OCIError,
                                    persona: *mut nzttPersona,
                                    crypto_engine_function: nzttcef,
                                    data_unit_format_ptr: *mut nztttdufmt,
                                    protection_info: *mut nzttProtInfo)
                                    -> sword;
}
extern "C" {
    pub fn OCISecurityRemoveIdentity(osshandle: *mut OCISecurity,
                                     error_handle: *mut OCIError,
                                     identity_ptr: *mut *mut nzttIdentity)
                                     -> sword;
}
extern "C" {
    pub fn OCISecurityCreateIdentity(osshandle: *mut OCISecurity,
                                     error_handle: *mut OCIError,
                                     type_: nzttIdentType,
                                     desc: *mut nzttIdentityDesc,
                                     identity_ptr: *mut *mut nzttIdentity)
                                     -> sword;
}
extern "C" {
    pub fn OCISecurityAbortIdentity(osshandle: *mut OCISecurity,
                                    error_handle: *mut OCIError,
                                    identity_ptr: *mut *mut nzttIdentity)
                                    -> sword;
}
extern "C" {
    pub fn OCISecurityFreeIdentity(osshandle: *mut OCISecurity,
                                   error_handle: *mut OCIError,
                                   identity_ptr: *mut *mut nzttIdentity)
                                   -> sword;
}
extern "C" {
    pub fn OCISecurityStoreTrustedIdentity(osshandle: *mut OCISecurity,
                                           error_handle: *mut OCIError,
                                           identity_ptr: *mut *mut nzttIdentity,
                                           persona: *mut nzttPersona)
                                           -> sword;
}
extern "C" {
    pub fn OCISecuritySign(osshandle: *mut OCISecurity,
                           error_handle: *mut OCIError,
                           persona: *mut nzttPersona,
                           signature_state: nzttces,
                           input_length: usize,
                           input: *mut ub1,
                           buffer_block: *mut nzttBufferBlock)
                           -> sword;
}
extern "C" {
    pub fn OCISecuritySignExpansion(osshandle: *mut OCISecurity,
                                    error_handle: *mut OCIError,
                                    persona: *mut nzttPersona,
                                    inputlen: usize,
                                    signature_length: *mut usize)
                                    -> sword;
}
extern "C" {
    pub fn OCISecurityVerify(osshandle: *mut OCISecurity,
                             error_handle: *mut OCIError,
                             persona: *mut nzttPersona,
                             signature_state: nzttces,
                             siglen: usize,
                             signature: *mut ub1,
                             extracted_message: *mut nzttBufferBlock,
                             verified: *mut boolean,
                             validated: *mut boolean,
                             signing_party_identity: *mut *mut nzttIdentity)
                             -> sword;
}
extern "C" {
    pub fn OCISecurityValidate(osshandle: *mut OCISecurity,
                               error_handle: *mut OCIError,
                               persona: *mut nzttPersona,
                               identity: *mut nzttIdentity,
                               validated: *mut boolean)
                               -> sword;
}
extern "C" {
    pub fn OCISecuritySignDetached(osshandle: *mut OCISecurity,
                                   error_handle: *mut OCIError,
                                   persona: *mut nzttPersona,
                                   signature_state: nzttces,
                                   input_length: usize,
                                   input: *mut ub1,
                                   signature: *mut nzttBufferBlock)
                                   -> sword;
}
extern "C" {
    pub fn OCISecuritySignDetExpansion(osshandle: *mut OCISecurity,
                                       error_handle: *mut OCIError,
                                       persona: *mut nzttPersona,
                                       input_length: usize,
                                       required_buffer_length: *mut usize)
                                       -> sword;
}
extern "C" {
    pub fn OCISecurityVerifyDetached(osshandle: *mut OCISecurity,
                                     error_handle: *mut OCIError,
                                     persona: *mut nzttPersona,
                                     signature_state: nzttces,
                                     data_length: usize,
                                     data: *mut ub1,
                                     siglen: usize,
                                     signature: *mut ub1,
                                     verified: *mut boolean,
                                     validated: *mut boolean,
                                     signing_party_identity: *mut *mut nzttIdentity)
                                     -> sword;
}
extern "C" {
    pub fn OCISecurity_PKEncrypt(osshandle: *mut OCISecurity,
                                 error_handle: *mut OCIError,
                                 persona: *mut nzttPersona,
                                 number_of_recipients: usize,
                                 recipient_list: *mut nzttIdentity,
                                 encryption_state: nzttces,
                                 input_length: usize,
                                 input: *mut ub1,
                                 encrypted_data: *mut nzttBufferBlock)
                                 -> sword;
}
extern "C" {
    pub fn OCISecurityPKEncryptExpansion(osshandle: *mut OCISecurity,
                                         error_handle: *mut OCIError,
                                         persona: *mut nzttPersona,
                                         number_recipients: usize,
                                         input_length: usize,
                                         buffer_length_required: *mut usize)
                                         -> sword;
}
extern "C" {
    pub fn OCISecurityPKDecrypt(osshandle: *mut OCISecurity,
                                error_handle: *mut OCIError,
                                persona: *mut nzttPersona,
                                encryption_state: nzttces,
                                input_length: usize,
                                input: *mut ub1,
                                encrypted_data: *mut nzttBufferBlock)
                                -> sword;
}
extern "C" {
    pub fn OCISecurityEncrypt(osshandle: *mut OCISecurity,
                              error_handle: *mut OCIError,
                              persona: *mut nzttPersona,
                              encryption_state: nzttces,
                              input_length: usize,
                              input: *mut ub1,
                              encrypted_data: *mut nzttBufferBlock)
                              -> sword;
}
extern "C" {
    pub fn OCISecurityEncryptExpansion(osshandle: *mut OCISecurity,
                                       error_handle: *mut OCIError,
                                       persona: *mut nzttPersona,
                                       input_length: usize,
                                       encrypted_data_length: *mut usize)
                                       -> sword;
}
extern "C" {
    pub fn OCISecurityDecrypt(osshandle: *mut OCISecurity,
                              error_handle: *mut OCIError,
                              persona: *mut nzttPersona,
                              decryption_state: nzttces,
                              input_length: usize,
                              input: *mut ub1,
                              decrypted_data: *mut nzttBufferBlock)
                              -> sword;
}
extern "C" {
    pub fn OCISecurityEnvelope(osshandle: *mut OCISecurity,
                               error_handle: *mut OCIError,
                               persona: *mut nzttPersona,
                               number_of_recipients: usize,
                               identity: *mut nzttIdentity,
                               encryption_state: nzttces,
                               input_length: usize,
                               input: *mut ub1,
                               enveloped_data: *mut nzttBufferBlock)
                               -> sword;
}
extern "C" {
    pub fn OCISecurityDeEnvelope(osshandle: *mut OCISecurity,
                                 error_handle: *mut OCIError,
                                 persona: *mut nzttPersona,
                                 decryption_state: nzttces,
                                 input_length: usize,
                                 input: *mut ub1,
                                 output_message: *mut nzttBufferBlock,
                                 verified: *mut boolean,
                                 validated: *mut boolean,
                                 sender_identity: *mut *mut nzttIdentity)
                                 -> sword;
}
extern "C" {
    pub fn OCISecurityKeyedHash(osshandle: *mut OCISecurity,
                                error_handle: *mut OCIError,
                                persona: *mut nzttPersona,
                                hash_state: nzttces,
                                input_length: usize,
                                input: *mut ub1,
                                keyed_hash: *mut nzttBufferBlock)
                                -> sword;
}
extern "C" {
    pub fn OCISecurityKeyedHashExpansion(osshandle: *mut OCISecurity,
                                         error_handle: *mut OCIError,
                                         persona: *mut nzttPersona,
                                         input_length: usize,
                                         required_buffer_length: *mut usize)
                                         -> sword;
}
extern "C" {
    pub fn OCISecurityHash(osshandle: *mut OCISecurity,
                           error_handle: *mut OCIError,
                           persona: *mut nzttPersona,
                           hash_state: nzttces,
                           input: usize,
                           input_length: *mut ub1,
                           hash: *mut nzttBufferBlock)
                           -> sword;
}
extern "C" {
    pub fn OCISecurityHashExpansion(osshandle: *mut OCISecurity,
                                    error_handle: *mut OCIError,
                                    persona: *mut nzttPersona,
                                    input_length: usize,
                                    required_buffer_length: *mut usize)
                                    -> sword;
}
extern "C" {
    pub fn OCISecuritySeedRandom(osshandle: *mut OCISecurity,
                                 error_handle: *mut OCIError,
                                 persona: *mut nzttPersona,
                                 seed_length: usize,
                                 seed: *mut ub1)
                                 -> sword;
}
extern "C" {
    pub fn OCISecurityRandomBytes(osshandle: *mut OCISecurity,
                                  error_handle: *mut OCIError,
                                  persona: *mut nzttPersona,
                                  number_of_bytes_desired: usize,
                                  random_bytes: *mut nzttBufferBlock)
                                  -> sword;
}
extern "C" {
    pub fn OCISecurityRandomNumber(osshandle: *mut OCISecurity,
                                   error_handle: *mut OCIError,
                                   persona: *mut nzttPersona,
                                   random_number_ptr: *mut uword)
                                   -> sword;
}
extern "C" {
    pub fn OCISecurityInitBlock(osshandle: *mut OCISecurity,
                                error_handle: *mut OCIError,
                                buffer_block: *mut nzttBufferBlock)
                                -> sword;
}
extern "C" {
    pub fn OCISecurityReuseBlock(osshandle: *mut OCISecurity,
                                 error_handle: *mut OCIError,
                                 buffer_block: *mut nzttBufferBlock)
                                 -> sword;
}
extern "C" {
    pub fn OCISecurityPurgeBlock(osshandle: *mut OCISecurity,
                                 error_handle: *mut OCIError,
                                 buffer_block: *mut nzttBufferBlock)
                                 -> sword;
}
extern "C" {
    pub fn OCISecuritySetBlock(osshandle: *mut OCISecurity,
                               error_handle: *mut OCIError,
                               flags_to_set: uword,
                               buffer_length: usize,
                               used_buffer_length: usize,
                               buffer: *mut ub1,
                               buffer_block: *mut nzttBufferBlock)
                               -> sword;
}
extern "C" {
    pub fn OCISecurityGetIdentity(osshandle: *mut OCISecurity,
                                  error_handle: *mut OCIError,
                                  namelen: usize,
                                  distinguished_name: *mut OraText,
                                  identity: *mut *mut nzttIdentity)
                                  -> sword;
}
extern "C" {
    pub fn OCIAQEnq(svchp: *mut OCISvcCtx,
                    errhp: *mut OCIError,
                    queue_name: *mut OraText,
                    enqopt: *mut OCIAQEnqOptions,
                    msgprop: *mut OCIAQMsgProperties,
                    payload_tdo: *mut OCIType,
                    payload: *mut *mut ::std::os::raw::c_void,
                    payload_ind: *mut *mut ::std::os::raw::c_void,
                    msgid: *mut *mut OCIRaw,
                    flags: ub4)
                    -> sword;
}
extern "C" {
    pub fn OCIAQDeq(svchp: *mut OCISvcCtx,
                    errhp: *mut OCIError,
                    queue_name: *mut OraText,
                    deqopt: *mut OCIAQDeqOptions,
                    msgprop: *mut OCIAQMsgProperties,
                    payload_tdo: *mut OCIType,
                    payload: *mut *mut ::std::os::raw::c_void,
                    payload_ind: *mut *mut ::std::os::raw::c_void,
                    msgid: *mut *mut OCIRaw,
                    flags: ub4)
                    -> sword;
}
extern "C" {
    pub fn OCIAQEnqArray(svchp: *mut OCISvcCtx,
                         errhp: *mut OCIError,
                         queue_name: *mut OraText,
                         enqopt: *mut OCIAQEnqOptions,
                         iters: *mut ub4,
                         msgprop: *mut *mut OCIAQMsgProperties,
                         payload_tdo: *mut OCIType,
                         payload: *mut *mut ::std::os::raw::c_void,
                         payload_ind: *mut *mut ::std::os::raw::c_void,
                         msgid: *mut *mut OCIRaw,
                         ctxp: *mut ::std::os::raw::c_void,
                         enqcbfp: OCICallbackAQEnq,
                         flags: ub4)
                         -> sword;
}
extern "C" {
    pub fn OCIAQEnqStreaming(svchp: *mut OCISvcCtx,
                             errhp: *mut OCIError,
                             queue_name: *mut OraText,
                             enqopt: *mut OCIAQEnqOptions,
                             payload_tdo: *mut OCIType,
                             ctxp: *mut ::std::os::raw::c_void,
                             enqcbfp: OCICallbackAQEnqStreaming,
                             flags: ub4)
                             -> sword;
}
extern "C" {
    pub fn OCIAQDeqArray(svchp: *mut OCISvcCtx,
                         errhp: *mut OCIError,
                         queue_name: *mut OraText,
                         deqopt: *mut OCIAQDeqOptions,
                         iters: *mut ub4,
                         msgprop: *mut *mut OCIAQMsgProperties,
                         payload_tdo: *mut OCIType,
                         payload: *mut *mut ::std::os::raw::c_void,
                         payload_ind: *mut *mut ::std::os::raw::c_void,
                         msgid: *mut *mut OCIRaw,
                         ctxp: *mut ::std::os::raw::c_void,
                         deqcbfp: OCICallbackAQDeq,
                         flags: ub4)
                         -> sword;
}
extern "C" {
    pub fn OCIAQListen(svchp: *mut OCISvcCtx,
                       errhp: *mut OCIError,
                       agent_list: *mut *mut OCIAQAgent,
                       num_agents: ub4,
                       wait: sb4,
                       agent: *mut *mut OCIAQAgent,
                       flags: ub4)
                       -> sword;
}
extern "C" {
    pub fn OCIAQListen2(svchp: *mut OCISvcCtx,
                        errhp: *mut OCIError,
                        agent_list: *mut *mut OCIAQAgent,
                        num_agents: ub4,
                        lopts: *mut OCIAQListenOpts,
                        agent: *mut *mut OCIAQAgent,
                        lmops: *mut OCIAQLisMsgProps,
                        flags: ub4)
                        -> sword;
}
extern "C" {
    pub fn OCIAQGetReplayInfo(svchp: *mut OCISvcCtx,
                              errhp: *mut OCIError,
                              queue_name: *mut OraText,
                              sender: *mut OCIAQAgent,
                              replay_attribute: ub4,
                              correlation: *mut OraText,
                              corr_len: *mut ub2)
                              -> sword;
}
extern "C" {
    pub fn OCIAQResetReplayInfo(svchp: *mut OCISvcCtx,
                                errhp: *mut OCIError,
                                queue_name: *mut OraText,
                                sender: *mut OCIAQAgent,
                                replay_attribute: ub4)
                                -> sword;
}
extern "C" {
    pub fn OCIExtractInit(hndl: *mut ::std::os::raw::c_void, err: *mut OCIError) -> sword;
}
extern "C" {
    pub fn OCIExtractTerm(hndl: *mut ::std::os::raw::c_void, err: *mut OCIError) -> sword;
}
extern "C" {
    pub fn OCIExtractReset(hndl: *mut ::std::os::raw::c_void, err: *mut OCIError) -> sword;
}
extern "C" {
    pub fn OCIExtractSetNumKeys(hndl: *mut ::std::os::raw::c_void,
                                err: *mut OCIError,
                                numkeys: uword)
                                -> sword;
}
extern "C" {
    pub fn OCIExtractSetKey(hndl: *mut ::std::os::raw::c_void,
                            err: *mut OCIError,
                            name: *const OraText,
                            type_: ub1,
                            flag: ub4,
                            defval: *const ::std::os::raw::c_void,
                            intrange: *const sb4,
                            strlist: *const *const OraText)
                            -> sword;
}
extern "C" {
    pub fn OCIExtractFromFile(hndl: *mut ::std::os::raw::c_void,
                              err: *mut OCIError,
                              flag: ub4,
                              filename: *mut OraText)
                              -> sword;
}
extern "C" {
    pub fn OCIExtractFromStr(hndl: *mut ::std::os::raw::c_void,
                             err: *mut OCIError,
                             flag: ub4,
                             input: *mut OraText)
                             -> sword;
}
extern "C" {
    pub fn OCIExtractToInt(hndl: *mut ::std::os::raw::c_void,
                           err: *mut OCIError,
                           keyname: *mut OraText,
                           valno: uword,
                           retval: *mut sb4)
                           -> sword;
}
extern "C" {
    pub fn OCIExtractToBool(hndl: *mut ::std::os::raw::c_void,
                            err: *mut OCIError,
                            keyname: *mut OraText,
                            valno: uword,
                            retval: *mut ub1)
                            -> sword;
}
extern "C" {
    pub fn OCIExtractToStr(hndl: *mut ::std::os::raw::c_void,
                           err: *mut OCIError,
                           keyname: *mut OraText,
                           valno: uword,
                           retval: *mut OraText,
                           buflen: uword)
                           -> sword;
}
extern "C" {
    pub fn OCIExtractToOCINum(hndl: *mut ::std::os::raw::c_void,
                              err: *mut OCIError,
                              keyname: *mut OraText,
                              valno: uword,
                              retval: *mut OCINumber)
                              -> sword;
}
extern "C" {
    pub fn OCIExtractToList(hndl: *mut ::std::os::raw::c_void,
                            err: *mut OCIError,
                            numkeys: *mut uword)
                            -> sword;
}
extern "C" {
    pub fn OCIExtractFromList(hndl: *mut ::std::os::raw::c_void,
                              err: *mut OCIError,
                              index: uword,
                              name: *mut *mut OraText,
                              type_: *mut ub1,
                              numvals: *mut uword,
                              values: *mut *mut *mut ::std::os::raw::c_void)
                              -> sword;
}
extern "C" {
    pub fn OCIMemoryAlloc(hdl: *mut ::std::os::raw::c_void,
                          err: *mut OCIError,
                          mem: *mut *mut ::std::os::raw::c_void,
                          dur: OCIDuration,
                          size: ub4,
                          flags: ub4)
                          -> sword;
}
extern "C" {
    pub fn OCIMemoryResize(hdl: *mut ::std::os::raw::c_void,
                           err: *mut OCIError,
                           mem: *mut *mut ::std::os::raw::c_void,
                           newsize: ub4,
                           flags: ub4)
                           -> sword;
}
extern "C" {
    pub fn OCIMemoryFree(hdl: *mut ::std::os::raw::c_void,
                         err: *mut OCIError,
                         mem: *mut ::std::os::raw::c_void)
                         -> sword;
}
extern "C" {
    pub fn OCIContextSetValue(hdl: *mut ::std::os::raw::c_void,
                              err: *mut OCIError,
                              duration: OCIDuration,
                              key: *mut ub1,
                              keylen: ub1,
                              ctx_value: *mut ::std::os::raw::c_void)
                              -> sword;
}
extern "C" {
    pub fn OCIContextGetValue(hdl: *mut ::std::os::raw::c_void,
                              err: *mut OCIError,
                              key: *mut ub1,
                              keylen: ub1,
                              ctx_value: *mut *mut ::std::os::raw::c_void)
                              -> sword;
}
extern "C" {
    pub fn OCIContextClearValue(hdl: *mut ::std::os::raw::c_void,
                                err: *mut OCIError,
                                key: *mut ub1,
                                keylen: ub1)
                                -> sword;
}
extern "C" {
    pub fn OCIContextGenerateKey(hdl: *mut ::std::os::raw::c_void,
                                 err: *mut OCIError,
                                 key: *mut ub4)
                                 -> sword;
}
extern "C" {
    pub fn OCIMemorySetCurrentIDs(hdl: *mut ::std::os::raw::c_void,
                                  err: *mut OCIError,
                                  curr_session_id: ub4,
                                  curr_trans_id: ub4,
                                  curr_stmt_id: ub4)
                                  -> sword;
}
extern "C" {
    pub fn OCIPicklerTdsCtxInit(env: *mut OCIEnv,
                                err: *mut OCIError,
                                tdsc: *mut *mut OCIPicklerTdsCtx)
                                -> sword;
}
extern "C" {
    pub fn OCIPicklerTdsCtxFree(env: *mut OCIEnv,
                                err: *mut OCIError,
                                tdsc: *mut OCIPicklerTdsCtx)
                                -> sword;
}
extern "C" {
    pub fn OCIPicklerTdsInit(env: *mut OCIEnv,
                             err: *mut OCIError,
                             tdsc: *mut OCIPicklerTdsCtx,
                             tdsh: *mut *mut OCIPicklerTds)
                             -> sword;
}
extern "C" {
    pub fn OCIPicklerTdsFree(env: *mut OCIEnv,
                             err: *mut OCIError,
                             tdsh: *mut OCIPicklerTds)
                             -> sword;
}
extern "C" {
    pub fn OCIPicklerTdsCreateElementNumber(env: *mut OCIEnv,
                                            err: *mut OCIError,
                                            tdsh: *mut OCIPicklerTds,
                                            prec: ub1,
                                            scale: sb1,
                                            elt: *mut OCIPicklerTdsElement)
                                            -> sword;
}
extern "C" {
    pub fn OCIPicklerTdsCreateElementChar(env: *mut OCIEnv,
                                          err: *mut OCIError,
                                          tdsh: *mut OCIPicklerTds,
                                          len: ub2,
                                          elt: *mut OCIPicklerTdsElement)
                                          -> sword;
}
extern "C" {
    pub fn OCIPicklerTdsCreateElementVarchar(env: *mut OCIEnv,
                                             err: *mut OCIError,
                                             tdsh: *mut OCIPicklerTds,
                                             len: ub2,
                                             elt: *mut OCIPicklerTdsElement)
                                             -> sword;
}
extern "C" {
    pub fn OCIPicklerTdsCreateElementRaw(env: *mut OCIEnv,
                                         err: *mut OCIError,
                                         tdsh: *mut OCIPicklerTds,
                                         len: ub2,
                                         elt: *mut OCIPicklerTdsElement)
                                         -> sword;
}
extern "C" {
    pub fn OCIPicklerTdsCreateElement(env: *mut OCIEnv,
                                      err: *mut OCIError,
                                      tdsh: *mut OCIPicklerTds,
                                      dty: OCITypeCode,
                                      elt: *mut OCIPicklerTdsElement)
                                      -> sword;
}
extern "C" {
    pub fn OCIPicklerTdsAddAttr(env: *mut OCIEnv,
                                err: *mut OCIError,
                                tdsh: *mut OCIPicklerTds,
                                elt: OCIPicklerTdsElement)
                                -> sword;
}
extern "C" {
    pub fn OCIPicklerTdsGenerate(env: *mut OCIEnv,
                                 err: *mut OCIError,
                                 tdsh: *mut OCIPicklerTds)
                                 -> sword;
}
extern "C" {
    pub fn OCIPicklerTdsGetAttr(env: *mut OCIEnv,
                                err: *mut OCIError,
                                tdsh: *const OCIPicklerTds,
                                attrno: ub1,
                                typ: *mut OCITypeCode,
                                len: *mut ub2)
                                -> sword;
}
extern "C" {
    pub fn OCIPicklerFdoInit(env: *mut OCIEnv,
                             err: *mut OCIError,
                             fdoh: *mut *mut OCIPicklerFdo)
                             -> sword;
}
extern "C" {
    pub fn OCIPicklerFdoFree(env: *mut OCIEnv,
                             err: *mut OCIError,
                             fdoh: *mut OCIPicklerFdo)
                             -> sword;
}
extern "C" {
    pub fn OCIPicklerImageInit(env: *mut OCIEnv,
                               err: *mut OCIError,
                               fdoh: *mut OCIPicklerFdo,
                               tdsh: *mut OCIPicklerTds,
                               imgh: *mut *mut OCIPicklerImage)
                               -> sword;
}
extern "C" {
    pub fn OCIPicklerImageFree(env: *mut OCIEnv,
                               err: *mut OCIError,
                               imgh: *mut OCIPicklerImage)
                               -> sword;
}
extern "C" {
    pub fn OCIPicklerImageAddScalar(env: *mut OCIEnv,
                                    err: *mut OCIError,
                                    imgh: *mut OCIPicklerImage,
                                    scalar: *mut ::std::os::raw::c_void,
                                    len: ub4)
                                    -> sword;
}
extern "C" {
    pub fn OCIPicklerImageAddNullScalar(env: *mut OCIEnv,
                                        err: *mut OCIError,
                                        imgh: *mut OCIPicklerImage)
                                        -> sword;
}
extern "C" {
    pub fn OCIPicklerImageGenerate(env: *mut OCIEnv,
                                   err: *mut OCIError,
                                   imgh: *mut OCIPicklerImage)
                                   -> sword;
}
extern "C" {
    pub fn OCIPicklerImageGetScalarSize(env: *mut OCIEnv,
                                        err: *mut OCIError,
                                        imgh: *mut OCIPicklerImage,
                                        attrno: ub4,
                                        size: *mut ub4)
                                        -> sword;
}
extern "C" {
    pub fn OCIPicklerImageGetScalar(env: *mut OCIEnv,
                                    err: *mut OCIError,
                                    imgh: *mut OCIPicklerImage,
                                    attrno: ub4,
                                    buf: *mut ::std::os::raw::c_void,
                                    len: *mut ub4,
                                    ind: *mut OCIInd)
                                    -> sword;
}
extern "C" {
    pub fn OCIPicklerImageCollBegin(env: *mut OCIEnv,
                                    err: *mut OCIError,
                                    imgh: *mut OCIPicklerImage,
                                    colltdsh: *const OCIPicklerTds)
                                    -> sword;
}
extern "C" {
    pub fn OCIPicklerImageCollAddScalar(env: *mut OCIEnv,
                                        err: *mut OCIError,
                                        imgh: *mut OCIPicklerImage,
                                        scalar: *mut ::std::os::raw::c_void,
                                        buflen: ub4,
                                        ind: OCIInd)
                                        -> sword;
}
extern "C" {
    pub fn OCIPicklerImageCollEnd(env: *mut OCIEnv,
                                  err: *mut OCIError,
                                  imgh: *mut OCIPicklerImage)
                                  -> sword;
}
extern "C" {
    pub fn OCIPicklerImageCollBeginScan(env: *mut OCIEnv,
                                        err: *mut OCIError,
                                        imgh: *mut OCIPicklerImage,
                                        coll_tdsh: *const OCIPicklerTds,
                                        attrnum: ub4,
                                        startidx: ub4,
                                        ind: *mut OCIInd)
                                        -> sword;
}
extern "C" {
    pub fn OCIPicklerImageCollGetScalarSize(env: *mut OCIEnv,
                                            err: *mut OCIError,
                                            coll_tdsh: *const OCIPicklerTds,
                                            size: *mut ub4)
                                            -> sword;
}
extern "C" {
    pub fn OCIPicklerImageCollGetScalar(env: *mut OCIEnv,
                                        err: *mut OCIError,
                                        imgh: *mut OCIPicklerImage,
                                        buf: *mut ::std::os::raw::c_void,
                                        buflen: *mut ub4,
                                        ind: *mut OCIInd)
                                        -> sword;
}
extern "C" {
    pub fn OCIAnyDataGetType(svchp: *mut OCISvcCtx,
                             errhp: *mut OCIError,
                             sdata: *mut OCIAnyData,
                             tc: *mut OCITypeCode,
                             type_: *mut *mut OCIType)
                             -> sword;
}
extern "C" {
    pub fn OCIAnyDataIsNull(svchp: *mut OCISvcCtx,
                            errhp: *mut OCIError,
                            sdata: *mut OCIAnyData,
                            isnull: *mut boolean)
                            -> sword;
}
extern "C" {
    pub fn OCIAnyDataConvert(svchp: *mut OCISvcCtx,
                             errhp: *mut OCIError,
                             tc: OCITypeCode,
                             type_: *mut OCIType,
                             dur: OCIDuration,
                             ind: *mut ::std::os::raw::c_void,
                             data_val: *mut ::std::os::raw::c_void,
                             len: ub4,
                             sdata: *mut *mut OCIAnyData)
                             -> sword;
}
extern "C" {
    pub fn OCIAnyDataBeginCreate(svchp: *mut OCISvcCtx,
                                 errhp: *mut OCIError,
                                 tc: OCITypeCode,
                                 type_: *mut OCIType,
                                 dur: OCIDuration,
                                 sdata: *mut *mut OCIAnyData)
                                 -> sword;
}
extern "C" {
    pub fn OCIAnyDataDestroy(svchp: *mut OCISvcCtx,
                             errhp: *mut OCIError,
                             sdata: *mut OCIAnyData)
                             -> sword;
}
extern "C" {
    pub fn OCIAnyDataAttrSet(svchp: *mut OCISvcCtx,
                             errhp: *mut OCIError,
                             sdata: *mut OCIAnyData,
                             tc: OCITypeCode,
                             type_: *mut OCIType,
                             ind: *mut ::std::os::raw::c_void,
                             attr_val: *mut ::std::os::raw::c_void,
                             length: ub4,
                             is_any: boolean)
                             -> sword;
}
extern "C" {
    pub fn OCIAnyDataCollAddElem(svchp: *mut OCISvcCtx,
                                 errhp: *mut OCIError,
                                 sdata: *mut OCIAnyData,
                                 tc: OCITypeCode,
                                 type_: *mut OCIType,
                                 ind: *mut ::std::os::raw::c_void,
                                 attr_val: *mut ::std::os::raw::c_void,
                                 length: ub4,
                                 is_any: boolean,
                                 last_elem: boolean)
                                 -> sword;
}
extern "C" {
    pub fn OCIAnyDataEndCreate(svchp: *mut OCISvcCtx,
                               errhp: *mut OCIError,
                               sdata: *mut OCIAnyData)
                               -> sword;
}
extern "C" {
    pub fn OCIAnyDataAccess(svchp: *mut OCISvcCtx,
                            errhp: *mut OCIError,
                            sdata: *mut OCIAnyData,
                            tc: OCITypeCode,
                            type_: *mut OCIType,
                            ind: *mut ::std::os::raw::c_void,
                            attr_val: *mut ::std::os::raw::c_void,
                            length: *mut ub4)
                            -> sword;
}
extern "C" {
    pub fn OCIAnyDataGetCurrAttrNum(svchp: *mut OCISvcCtx,
                                    errhp: *mut OCIError,
                                    sdata: *mut OCIAnyData,
                                    attrnum: *mut ub4)
                                    -> sword;
}
extern "C" {
    pub fn OCIAnyDataAttrGet(svchp: *mut OCISvcCtx,
                             errhp: *mut OCIError,
                             sdata: *mut OCIAnyData,
                             tc: OCITypeCode,
                             type_: *mut OCIType,
                             ind: *mut ::std::os::raw::c_void,
                             attr_val: *mut ::std::os::raw::c_void,
                             length: *mut ub4,
                             is_any: boolean)
                             -> sword;
}
extern "C" {
    pub fn OCIAnyDataCollGetElem(svchp: *mut OCISvcCtx,
                                 errhp: *mut OCIError,
                                 sdata: *mut OCIAnyData,
                                 tc: OCITypeCode,
                                 type_: *mut OCIType,
                                 ind: *mut ::std::os::raw::c_void,
                                 celem_val: *mut ::std::os::raw::c_void,
                                 length: *mut ub4,
                                 is_any: boolean)
                                 -> sword;
}
extern "C" {
    pub fn OCIAnyDataSetBeginCreate(svchp: *mut OCISvcCtx,
                                    errhp: *mut OCIError,
                                    typecode: OCITypeCode,
                                    type_: *const OCIType,
                                    dur: OCIDuration,
                                    data_set: *mut *mut OCIAnyDataSet)
                                    -> sword;
}
extern "C" {
    pub fn OCIAnyDataSetDestroy(svchp: *mut OCISvcCtx,
                                errhp: *mut OCIError,
                                data_set: *mut OCIAnyDataSet)
                                -> sword;
}
extern "C" {
    pub fn OCIAnyDataSetAddInstance(svchp: *mut OCISvcCtx,
                                    errhp: *mut OCIError,
                                    data_set: *mut OCIAnyDataSet,
                                    data: *mut *mut OCIAnyData)
                                    -> sword;
}
extern "C" {
    pub fn OCIAnyDataSetEndCreate(svchp: *mut OCISvcCtx,
                                  errhp: *mut OCIError,
                                  data_set: *mut OCIAnyDataSet)
                                  -> sword;
}
extern "C" {
    pub fn OCIAnyDataSetGetType(svchp: *mut OCISvcCtx,
                                errhp: *mut OCIError,
                                data_set: *mut OCIAnyDataSet,
                                tc: *mut OCITypeCode,
                                type_: *mut *mut OCIType)
                                -> sword;
}
extern "C" {
    pub fn OCIAnyDataSetGetCount(svchp: *mut OCISvcCtx,
                                 errhp: *mut OCIError,
                                 data_set: *mut OCIAnyDataSet,
                                 count: *mut ub4)
                                 -> sword;
}
extern "C" {
    pub fn OCIAnyDataSetGetInstance(svchp: *mut OCISvcCtx,
                                    errhp: *mut OCIError,
                                    data_set: *mut OCIAnyDataSet,
                                    data: *mut *mut OCIAnyData)
                                    -> sword;
}
extern "C" {
    pub fn OCIFormatInit(hndl: *mut ::std::os::raw::c_void, err: *mut OCIError) -> sword;
}
extern "C" {
    pub fn OCIFormatString(hndl: *mut ::std::os::raw::c_void,
                           err: *mut OCIError,
                           buffer: *mut OraText,
                           bufferLength: sbig_ora,
                           returnLength: *mut sbig_ora,
                           formatString: *const OraText,
                           ...)
                           -> sword;
}
extern "C" {
    pub fn OCIFormatTerm(hndl: *mut ::std::os::raw::c_void, err: *mut OCIError) -> sword;
}
extern "C" {
    pub fn OCIFormatTUb1() -> sword;
}
extern "C" {
    pub fn OCIFormatTUb2() -> sword;
}
extern "C" {
    pub fn OCIFormatTUb4() -> sword;
}
extern "C" {
    pub fn OCIFormatTUword() -> sword;
}
extern "C" {
    pub fn OCIFormatTUbig_ora() -> sword;
}
extern "C" {
    pub fn OCIFormatTSb1() -> sword;
}
extern "C" {
    pub fn OCIFormatTSb2() -> sword;
}
extern "C" {
    pub fn OCIFormatTSb4() -> sword;
}
extern "C" {
    pub fn OCIFormatTSword() -> sword;
}
extern "C" {
    pub fn OCIFormatTSbig_ora() -> sword;
}
extern "C" {
    pub fn OCIFormatTEb1() -> sword;
}
extern "C" {
    pub fn OCIFormatTEb2() -> sword;
}
extern "C" {
    pub fn OCIFormatTEb4() -> sword;
}
extern "C" {
    pub fn OCIFormatTEword() -> sword;
}
extern "C" {
    pub fn OCIFormatTChar() -> sword;
}
extern "C" {
    pub fn OCIFormatTText() -> sword;
}
extern "C" {
    pub fn OCIFormatTDouble() -> sword;
}
extern "C" {
    pub fn OCIFormatTDvoid() -> sword;
}
extern "C" {
    pub fn OCIFormatTEnd() -> sword;
}
extern "C" {
    pub fn xaosvch(dbname: *mut OraText) -> *mut OCISvcCtx;
}
extern "C" {
    pub fn xaoSvcCtx(dbname: *mut OraText) -> *mut OCISvcCtx;
}
extern "C" {
    pub fn xaoEnv(dbname: *mut OraText) -> *mut OCIEnv;
}
extern "C" {
    pub fn xaosterr(svch: *mut OCISvcCtx, error: sb4) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OCINlsGetInfo(envhp: *mut ::std::os::raw::c_void,
                         errhp: *mut OCIError,
                         buf: *mut OraText,
                         buflen: usize,
                         item: ub2)
                         -> sword;
}
extern "C" {
    pub fn OCINlsNumericInfoGet(envhp: *mut ::std::os::raw::c_void,
                                errhp: *mut OCIError,
                                val: *mut sb4,
                                item: ub2)
                                -> sword;
}
extern "C" {
    pub fn OCINlsCharSetNameToId(envhp: *mut ::std::os::raw::c_void, name: *const oratext) -> ub2;
}
extern "C" {
    pub fn OCINlsCharSetIdToName(envhp: *mut ::std::os::raw::c_void,
                                 buf: *mut oratext,
                                 buflen: usize,
                                 id: ub2)
                                 -> sword;
}
extern "C" {
    pub fn OCINlsNameMap(envhp: *mut ::std::os::raw::c_void,
                         buf: *mut oratext,
                         buflen: usize,
                         srcbuf: *const oratext,
                         flag: ub4)
                         -> sword;
}
extern "C" {
    pub fn OCIMultiByteToWideChar(envhp: *mut ::std::os::raw::c_void,
                                  dst: *mut OCIWchar,
                                  src: *const OraText,
                                  rsize: *mut usize)
                                  -> sword;
}
extern "C" {
    pub fn OCIMultiByteInSizeToWideChar(envhp: *mut ::std::os::raw::c_void,
                                        dst: *mut OCIWchar,
                                        dstsz: usize,
                                        src: *const OraText,
                                        srcsz: usize,
                                        rsize: *mut usize)
                                        -> sword;
}
extern "C" {
    pub fn OCIWideCharToMultiByte(envhp: *mut ::std::os::raw::c_void,
                                  dst: *mut OraText,
                                  src: *const OCIWchar,
                                  rsize: *mut usize)
                                  -> sword;
}
extern "C" {
    pub fn OCIWideCharInSizeToMultiByte(envhp: *mut ::std::os::raw::c_void,
                                        dst: *mut OraText,
                                        dstsz: usize,
                                        src: *const OCIWchar,
                                        srcsz: usize,
                                        rsize: *mut usize)
                                        -> sword;
}
extern "C" {
    pub fn OCIWideCharIsAlnum(envhp: *mut ::std::os::raw::c_void, wc: OCIWchar) -> boolean;
}
extern "C" {
    pub fn OCIWideCharIsAlpha(envhp: *mut ::std::os::raw::c_void, wc: OCIWchar) -> boolean;
}
extern "C" {
    pub fn OCIWideCharIsCntrl(envhp: *mut ::std::os::raw::c_void, wc: OCIWchar) -> boolean;
}
extern "C" {
    pub fn OCIWideCharIsDigit(envhp: *mut ::std::os::raw::c_void, wc: OCIWchar) -> boolean;
}
extern "C" {
    pub fn OCIWideCharIsGraph(envhp: *mut ::std::os::raw::c_void, wc: OCIWchar) -> boolean;
}
extern "C" {
    pub fn OCIWideCharIsLower(envhp: *mut ::std::os::raw::c_void, wc: OCIWchar) -> boolean;
}
extern "C" {
    pub fn OCIWideCharIsPrint(envhp: *mut ::std::os::raw::c_void, wc: OCIWchar) -> boolean;
}
extern "C" {
    pub fn OCIWideCharIsPunct(envhp: *mut ::std::os::raw::c_void, wc: OCIWchar) -> boolean;
}
extern "C" {
    pub fn OCIWideCharIsSpace(envhp: *mut ::std::os::raw::c_void, wc: OCIWchar) -> boolean;
}
extern "C" {
    pub fn OCIWideCharIsUpper(envhp: *mut ::std::os::raw::c_void, wc: OCIWchar) -> boolean;
}
extern "C" {
    pub fn OCIWideCharIsXdigit(envhp: *mut ::std::os::raw::c_void, wc: OCIWchar) -> boolean;
}
extern "C" {
    pub fn OCIWideCharIsSingleByte(envhp: *mut ::std::os::raw::c_void, wc: OCIWchar) -> boolean;
}
extern "C" {
    pub fn OCIWideCharToLower(envhp: *mut ::std::os::raw::c_void, wc: OCIWchar) -> OCIWchar;
}
extern "C" {
    pub fn OCIWideCharToUpper(envhp: *mut ::std::os::raw::c_void, wc: OCIWchar) -> OCIWchar;
}
extern "C" {
    pub fn OCIWideCharStrcmp(envhp: *mut ::std::os::raw::c_void,
                             wstr1: *const OCIWchar,
                             wstr2: *const OCIWchar,
                             flag: ::std::os::raw::c_int)
                             -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OCIWideCharStrncmp(envhp: *mut ::std::os::raw::c_void,
                              wstr1: *const OCIWchar,
                              len1: usize,
                              wstr2: *const OCIWchar,
                              len2: usize,
                              flag: ::std::os::raw::c_int)
                              -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OCIWideCharStrcat(envhp: *mut ::std::os::raw::c_void,
                             wdststr: *mut OCIWchar,
                             wsrcstr: *const OCIWchar)
                             -> usize;
}
extern "C" {
    pub fn OCIWideCharStrchr(envhp: *mut ::std::os::raw::c_void,
                             wstr: *const OCIWchar,
                             wc: OCIWchar)
                             -> *mut OCIWchar;
}
extern "C" {
    pub fn OCIWideCharStrcpy(envhp: *mut ::std::os::raw::c_void,
                             wdststr: *mut OCIWchar,
                             wsrcstr: *const OCIWchar)
                             -> usize;
}
extern "C" {
    pub fn OCIWideCharStrlen(envhp: *mut ::std::os::raw::c_void, wstr: *const OCIWchar) -> usize;
}
extern "C" {
    pub fn OCIWideCharStrncat(envhp: *mut ::std::os::raw::c_void,
                              wdststr: *mut OCIWchar,
                              wsrcstr: *const OCIWchar,
                              n: usize)
                              -> usize;
}
extern "C" {
    pub fn OCIWideCharStrncpy(envhp: *mut ::std::os::raw::c_void,
                              wdststr: *mut OCIWchar,
                              wsrcstr: *const OCIWchar,
                              n: usize)
                              -> usize;
}
extern "C" {
    pub fn OCIWideCharStrrchr(envhp: *mut ::std::os::raw::c_void,
                              wstr: *const OCIWchar,
                              wc: OCIWchar)
                              -> *mut OCIWchar;
}
extern "C" {
    pub fn OCIWideCharStrCaseConversion(envhp: *mut ::std::os::raw::c_void,
                                        wdststr: *mut OCIWchar,
                                        wsrcstr: *const OCIWchar,
                                        flag: ub4)
                                        -> usize;
}
extern "C" {
    pub fn OCIWideCharDisplayLength(envhp: *mut ::std::os::raw::c_void, wc: OCIWchar) -> usize;
}
extern "C" {
    pub fn OCIWideCharMultiByteLength(envhp: *mut ::std::os::raw::c_void, wc: OCIWchar) -> usize;
}
extern "C" {
    pub fn OCIMultiByteStrcmp(envhp: *mut ::std::os::raw::c_void,
                              str1: *const OraText,
                              str2: *const OraText,
                              flag: ::std::os::raw::c_int)
                              -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OCIMultiByteStrncmp(envhp: *mut ::std::os::raw::c_void,
                               str1: *const OraText,
                               len1: usize,
                               str2: *mut OraText,
                               len2: usize,
                               flag: ::std::os::raw::c_int)
                               -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OCIMultiByteStrcat(envhp: *mut ::std::os::raw::c_void,
                              dststr: *mut OraText,
                              srcstr: *const OraText)
                              -> usize;
}
extern "C" {
    pub fn OCIMultiByteStrcpy(envhp: *mut ::std::os::raw::c_void,
                              dststr: *mut OraText,
                              srcstr: *const OraText)
                              -> usize;
}
extern "C" {
    pub fn OCIMultiByteStrlen(envhp: *mut ::std::os::raw::c_void, str: *const OraText) -> usize;
}
extern "C" {
    pub fn OCIMultiByteStrncat(envhp: *mut ::std::os::raw::c_void,
                               dststr: *mut OraText,
                               srcstr: *const OraText,
                               n: usize)
                               -> usize;
}
extern "C" {
    pub fn OCIMultiByteStrncpy(envhp: *mut ::std::os::raw::c_void,
                               dststr: *mut OraText,
                               srcstr: *const OraText,
                               n: usize)
                               -> usize;
}
extern "C" {
    pub fn OCIMultiByteStrnDisplayLength(envhp: *mut ::std::os::raw::c_void,
                                         str1: *const OraText,
                                         n: usize)
                                         -> usize;
}
extern "C" {
    pub fn OCIMultiByteStrCaseConversion(envhp: *mut ::std::os::raw::c_void,
                                         dststr: *mut OraText,
                                         srcstr: *const OraText,
                                         flag: ub4)
                                         -> usize;
}
extern "C" {
    pub fn OCICharSetToUnicode(envhp: *mut ::std::os::raw::c_void,
                               dst: *mut ub2,
                               dstlen: usize,
                               src: *const OraText,
                               srclen: usize,
                               rsize: *mut usize)
                               -> sword;
}
extern "C" {
    pub fn OCIUnicodeToCharSet(envhp: *mut ::std::os::raw::c_void,
                               dst: *mut OraText,
                               dstlen: usize,
                               src: *const ub2,
                               srclen: usize,
                               rsize: *mut usize)
                               -> sword;
}
extern "C" {
    pub fn OCINlsCharSetConvert(envhp: *mut ::std::os::raw::c_void,
                                errhp: *mut OCIError,
                                dstid: ub2,
                                dstp: *mut ::std::os::raw::c_void,
                                dstlen: usize,
                                srcid: ub2,
                                srcp: *const ::std::os::raw::c_void,
                                srclen: usize,
                                rsize: *mut usize)
                                -> sword;
}
extern "C" {
    pub fn OCICharSetConversionIsReplacementUsed(envhp: *mut ::std::os::raw::c_void) -> boolean;
}
extern "C" {
    pub fn OCINlsEnvironmentVariableGet(valp: *mut ::std::os::raw::c_void,
                                        size: usize,
                                        item: ub2,
                                        charset: ub2,
                                        rsize: *mut usize)
                                        -> sword;
}
extern "C" {
    pub fn OCIMessageOpen(envhp: *mut ::std::os::raw::c_void,
                          errhp: *mut OCIError,
                          msghp: *mut *mut OCIMsg,
                          product: *const OraText,
                          facility: *const OraText,
                          dur: OCIDuration)
                          -> sword;
}
extern "C" {
    pub fn OCIMessageGet(msgh: *mut OCIMsg,
                         msgno: ub4,
                         msgbuf: *mut OraText,
                         buflen: usize)
                         -> *mut OraText;
}
extern "C" {
    pub fn OCIMessageClose(envhp: *mut ::std::os::raw::c_void,
                           errhp: *mut OCIError,
                           msghp: *mut OCIMsg)
                           -> sword;
}
extern "C" {
    /// ACTUAL PROTOTYPE DECLARATIONS
    pub fn OCIThreadProcessInit();
}
extern "C" {
    pub fn OCIThreadInit(hndl: *mut ::std::os::raw::c_void, err: *mut OCIError) -> sword;
}
extern "C" {
    pub fn OCIThreadTerm(hndl: *mut ::std::os::raw::c_void, err: *mut OCIError) -> sword;
}
extern "C" {
    pub fn OCIThreadIsMulti() -> boolean;
}
extern "C" {
    pub fn OCIThreadMutexInit(hndl: *mut ::std::os::raw::c_void,
                              err: *mut OCIError,
                              mutex: *mut *mut OCIThreadMutex)
                              -> sword;
}
extern "C" {
    pub fn OCIThreadMutexDestroy(hndl: *mut ::std::os::raw::c_void,
                                 err: *mut OCIError,
                                 mutex: *mut *mut OCIThreadMutex)
                                 -> sword;
}
extern "C" {
    pub fn OCIThreadMutexAcquire(hndl: *mut ::std::os::raw::c_void,
                                 err: *mut OCIError,
                                 mutex: *mut OCIThreadMutex)
                                 -> sword;
}
extern "C" {
    pub fn OCIThreadMutexRelease(hndl: *mut ::std::os::raw::c_void,
                                 err: *mut OCIError,
                                 mutex: *mut OCIThreadMutex)
                                 -> sword;
}
extern "C" {
    pub fn OCIThreadKeyInit(hndl: *mut ::std::os::raw::c_void,
                            err: *mut OCIError,
                            key: *mut *mut OCIThreadKey,
                            destFn: OCIThreadKeyDestFunc)
                            -> sword;
}
extern "C" {
    pub fn OCIThreadKeyDestroy(hndl: *mut ::std::os::raw::c_void,
                               err: *mut OCIError,
                               key: *mut *mut OCIThreadKey)
                               -> sword;
}
extern "C" {
    pub fn OCIThreadKeyGet(hndl: *mut ::std::os::raw::c_void,
                           err: *mut OCIError,
                           key: *mut OCIThreadKey,
                           pValue: *mut *mut ::std::os::raw::c_void)
                           -> sword;
}
extern "C" {
    pub fn OCIThreadKeySet(hndl: *mut ::std::os::raw::c_void,
                           err: *mut OCIError,
                           key: *mut OCIThreadKey,
                           value: *mut ::std::os::raw::c_void)
                           -> sword;
}
extern "C" {
    pub fn OCIThreadIdInit(hndl: *mut ::std::os::raw::c_void,
                           err: *mut OCIError,
                           tid: *mut *mut OCIThreadId)
                           -> sword;
}
extern "C" {
    pub fn OCIThreadIdDestroy(hndl: *mut ::std::os::raw::c_void,
                              err: *mut OCIError,
                              tid: *mut *mut OCIThreadId)
                              -> sword;
}
extern "C" {
    pub fn OCIThreadIdSet(hndl: *mut ::std::os::raw::c_void,
                          err: *mut OCIError,
                          tidDest: *mut OCIThreadId,
                          tidSrc: *mut OCIThreadId)
                          -> sword;
}
extern "C" {
    pub fn OCIThreadIdSetNull(hndl: *mut ::std::os::raw::c_void,
                              err: *mut OCIError,
                              tid: *mut OCIThreadId)
                              -> sword;
}
extern "C" {
    pub fn OCIThreadIdGet(hndl: *mut ::std::os::raw::c_void,
                          err: *mut OCIError,
                          tid: *mut OCIThreadId)
                          -> sword;
}
extern "C" {
    pub fn OCIThreadIdSame(hndl: *mut ::std::os::raw::c_void,
                           err: *mut OCIError,
                           tid1: *mut OCIThreadId,
                           tid2: *mut OCIThreadId,
                           result: *mut boolean)
                           -> sword;
}
extern "C" {
    pub fn OCIThreadIdNull(hndl: *mut ::std::os::raw::c_void,
                           err: *mut OCIError,
                           tid: *mut OCIThreadId,
                           result: *mut boolean)
                           -> sword;
}
extern "C" {
    pub fn OCIThreadHndInit(hndl: *mut ::std::os::raw::c_void,
                            err: *mut OCIError,
                            thnd: *mut *mut OCIThreadHandle)
                            -> sword;
}
extern "C" {
    pub fn OCIThreadHndDestroy(hndl: *mut ::std::os::raw::c_void,
                               err: *mut OCIError,
                               thnd: *mut *mut OCIThreadHandle)
                               -> sword;
}
extern "C" {
    pub fn OCIThreadCreate(hndl: *mut ::std::os::raw::c_void,
                           err: *mut OCIError,
                           start:
                               ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                              *mut ::std::os::raw::c_void)>,
                           arg: *mut ::std::os::raw::c_void,
                           tid: *mut OCIThreadId, tHnd: *mut OCIThreadHandle)
-> sword;
}
extern "C" {
    pub fn OCIThreadJoin(hndl: *mut ::std::os::raw::c_void,
                         err: *mut OCIError,
                         tHnd: *mut OCIThreadHandle)
                         -> sword;
}
extern "C" {
    pub fn OCIThreadClose(hndl: *mut ::std::os::raw::c_void,
                          err: *mut OCIError,
                          tHnd: *mut OCIThreadHandle)
                          -> sword;
}
extern "C" {
    pub fn OCIThreadHandleGet(hndl: *mut ::std::os::raw::c_void,
                              err: *mut OCIError,
                              tHnd: *mut OCIThreadHandle)
                              -> sword;
}
pub type OCIBindRowCallback =
    ::std::option::Option<unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void) -> sword>;
pub type OCIFetchRowCallback =
    ::std::option::Option<unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void) -> sword>;
pub type OCISubscriptionNotify =
    ::std::option::Option<unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void,
                                               subscrhp: *mut OCISubscription,
                                               pay: *mut ::std::os::raw::c_void,
                                               payl: ub4,
                                               desc: *mut ::std::os::raw::c_void,
                                               mode: ub4)
                                               -> ub4>;
pub type OCISubscriptionFailure =
    ::std::option::Option<unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void,
                                               subscrhp: *mut OCISubscription,
                                               desc: *mut ::std::os::raw::c_void,
                                               errhp: *mut OCIError)
                                               -> ub4>;
extern "C" {
    pub fn OCISubscriptionRegister(svchp: *mut OCISvcCtx,
                                   subscrhpp: *mut *mut OCISubscription,
                                   count: ub2,
                                   errhp: *mut OCIError,
                                   mode: ub4)
                                   -> sword;
}
extern "C" {
    pub fn OCISubscriptionPost(svchp: *mut OCISvcCtx,
                               subscrhpp: *mut *mut OCISubscription,
                               count: ub2,
                               errhp: *mut OCIError,
                               mode: ub4)
                               -> sword;
}
extern "C" {
    pub fn OCISubscriptionUnRegister(svchp: *mut OCISvcCtx,
                                     subscrhp: *mut OCISubscription,
                                     errhp: *mut OCIError,
                                     mode: ub4)
                                     -> sword;
}
extern "C" {
    pub fn OCISubscriptionDisable(subscrhp: *mut OCISubscription,
                                  errhp: *mut OCIError,
                                  mode: ub4)
                                  -> sword;
}
extern "C" {
    pub fn OCISubscriptionEnable(subscrhp: *mut OCISubscription,
                                 errhp: *mut OCIError,
                                 mode: ub4)
                                 -> sword;
}
extern "C" {
    pub fn OCIDateTimeGetTime(hndl: *mut ::std::os::raw::c_void,
                              err: *mut OCIError,
                              datetime: *mut OCIDateTime,
                              hr: *mut ub1,
                              mm: *mut ub1,
                              ss: *mut ub1,
                              fsec: *mut ub4)
                              -> sword;
}
extern "C" {
    pub fn OCIDateTimeGetDate(hndl: *mut ::std::os::raw::c_void,
                              err: *mut OCIError,
                              date: *const OCIDateTime,
                              yr: *mut sb2,
                              mnth: *mut ub1,
                              dy: *mut ub1)
                              -> sword;
}
extern "C" {
    pub fn OCIDateTimeGetTimeZoneOffset(hndl: *mut ::std::os::raw::c_void,
                                        err: *mut OCIError,
                                        datetime: *const OCIDateTime,
                                        hr: *mut sb1,
                                        mm: *mut sb1)
                                        -> sword;
}
extern "C" {
    pub fn OCIDateTimeConstruct(hndl: *mut ::std::os::raw::c_void,
                                err: *mut OCIError,
                                datetime: *mut OCIDateTime,
                                yr: sb2,
                                mnth: ub1,
                                dy: ub1,
                                hr: ub1,
                                mm: ub1,
                                ss: ub1,
                                fsec: ub4,
                                timezone: *mut OraText,
                                timezone_length: usize)
                                -> sword;
}
extern "C" {
    pub fn OCIDateTimeSysTimeStamp(hndl: *mut ::std::os::raw::c_void,
                                   err: *mut OCIError,
                                   sys_date: *mut OCIDateTime)
                                   -> sword;
}
extern "C" {
    pub fn OCIDateTimeAssign(hndl: *mut ::std::os::raw::c_void,
                             err: *mut OCIError,
                             from: *const OCIDateTime,
                             to: *mut OCIDateTime)
                             -> sword;
}
extern "C" {
    pub fn OCIDateTimeToText(hndl: *mut ::std::os::raw::c_void,
                             err: *mut OCIError,
                             date: *const OCIDateTime,
                             fmt: *const OraText,
                             fmt_length: ub1,
                             fsprec: ub1,
                             lang_name: *const OraText,
                             lang_length: usize,
                             buf_size: *mut ub4,
                             buf: *mut OraText)
                             -> sword;
}
extern "C" {
    pub fn OCIDateTimeFromText(hndl: *mut ::std::os::raw::c_void,
                               err: *mut OCIError,
                               date_str: *const OraText,
                               dstr_length: usize,
                               fmt: *const OraText,
                               fmt_length: ub1,
                               lang_name: *const OraText,
                               lang_length: usize,
                               date: *mut OCIDateTime)
                               -> sword;
}
extern "C" {
    pub fn OCIDateTimeCompare(hndl: *mut ::std::os::raw::c_void,
                              err: *mut OCIError,
                              date1: *const OCIDateTime,
                              date2: *const OCIDateTime,
                              result: *mut sword)
                              -> sword;
}
extern "C" {
    pub fn OCIDateTimeCheck(hndl: *mut ::std::os::raw::c_void,
                            err: *mut OCIError,
                            date: *const OCIDateTime,
                            valid: *mut ub4)
                            -> sword;
}
extern "C" {
    pub fn OCIDateTimeConvert(hndl: *mut ::std::os::raw::c_void,
                              err: *mut OCIError,
                              indate: *mut OCIDateTime,
                              outdate: *mut OCIDateTime)
                              -> sword;
}
extern "C" {
    pub fn OCIDateTimeSubtract(hndl: *mut ::std::os::raw::c_void,
                               err: *mut OCIError,
                               indate1: *mut OCIDateTime,
                               indate2: *mut OCIDateTime,
                               inter: *mut OCIInterval)
                               -> sword;
}
extern "C" {
    pub fn OCIDateTimeIntervalAdd(hndl: *mut ::std::os::raw::c_void,
                                  err: *mut OCIError,
                                  datetime: *mut OCIDateTime,
                                  inter: *mut OCIInterval,
                                  outdatetime: *mut OCIDateTime)
                                  -> sword;
}
extern "C" {
    pub fn OCIDateTimeIntervalSub(hndl: *mut ::std::os::raw::c_void,
                                  err: *mut OCIError,
                                  datetime: *mut OCIDateTime,
                                  inter: *mut OCIInterval,
                                  outdatetime: *mut OCIDateTime)
                                  -> sword;
}
extern "C" {
    pub fn OCIIntervalSubtract(hndl: *mut ::std::os::raw::c_void,
                               err: *mut OCIError,
                               minuend: *mut OCIInterval,
                               subtrahend: *mut OCIInterval,
                               result: *mut OCIInterval)
                               -> sword;
}
extern "C" {
    pub fn OCIIntervalAdd(hndl: *mut ::std::os::raw::c_void,
                          err: *mut OCIError,
                          addend1: *mut OCIInterval,
                          addend2: *mut OCIInterval,
                          result: *mut OCIInterval)
                          -> sword;
}
extern "C" {
    pub fn OCIIntervalMultiply(hndl: *mut ::std::os::raw::c_void,
                               err: *mut OCIError,
                               inter: *const OCIInterval,
                               nfactor: *mut OCINumber,
                               result: *mut OCIInterval)
                               -> sword;
}
extern "C" {
    pub fn OCIIntervalDivide(hndl: *mut ::std::os::raw::c_void,
                             err: *mut OCIError,
                             dividend: *mut OCIInterval,
                             divisor: *mut OCINumber,
                             result: *mut OCIInterval)
                             -> sword;
}
extern "C" {
    pub fn OCIIntervalCompare(hndl: *mut ::std::os::raw::c_void,
                              err: *mut OCIError,
                              inter1: *mut OCIInterval,
                              inter2: *mut OCIInterval,
                              result: *mut sword)
                              -> sword;
}
extern "C" {
    pub fn OCIIntervalFromNumber(hndl: *mut ::std::os::raw::c_void,
                                 err: *mut OCIError,
                                 inter: *mut OCIInterval,
                                 number: *mut OCINumber)
                                 -> sword;
}
extern "C" {
    pub fn OCIIntervalFromText(hndl: *mut ::std::os::raw::c_void,
                               err: *mut OCIError,
                               inpstr: *const OraText,
                               str_len: usize,
                               result: *mut OCIInterval)
                               -> sword;
}
extern "C" {
    pub fn OCIIntervalToText(hndl: *mut ::std::os::raw::c_void,
                             err: *mut OCIError,
                             inter: *const OCIInterval,
                             lfprec: ub1,
                             fsprec: ub1,
                             buffer: *mut OraText,
                             buflen: usize,
                             resultlen: *mut usize)
                             -> sword;
}
extern "C" {
    pub fn OCIIntervalToNumber(hndl: *mut ::std::os::raw::c_void,
                               err: *mut OCIError,
                               inter: *const OCIInterval,
                               number: *mut OCINumber)
                               -> sword;
}
extern "C" {
    pub fn OCIIntervalCheck(hndl: *mut ::std::os::raw::c_void,
                            err: *mut OCIError,
                            interval: *const OCIInterval,
                            valid: *mut ub4)
                            -> sword;
}
extern "C" {
    pub fn OCIIntervalAssign(hndl: *mut ::std::os::raw::c_void,
                             err: *mut OCIError,
                             ininter: *const OCIInterval,
                             outinter: *mut OCIInterval)
                             -> sword;
}
extern "C" {
    pub fn OCIIntervalSetYearMonth(hndl: *mut ::std::os::raw::c_void,
                                   err: *mut OCIError,
                                   yr: sb4,
                                   mnth: sb4,
                                   result: *mut OCIInterval)
                                   -> sword;
}
extern "C" {
    pub fn OCIIntervalGetYearMonth(hndl: *mut ::std::os::raw::c_void,
                                   err: *mut OCIError,
                                   yr: *mut sb4,
                                   mnth: *mut sb4,
                                   result: *const OCIInterval)
                                   -> sword;
}
extern "C" {
    pub fn OCIIntervalSetDaySecond(hndl: *mut ::std::os::raw::c_void,
                                   err: *mut OCIError,
                                   dy: sb4,
                                   hr: sb4,
                                   mm: sb4,
                                   ss: sb4,
                                   fsec: sb4,
                                   result: *mut OCIInterval)
                                   -> sword;
}
extern "C" {
    pub fn OCIIntervalGetDaySecond(hndl: *mut ::std::os::raw::c_void,
                                   err: *mut OCIError,
                                   dy: *mut sb4,
                                   hr: *mut sb4,
                                   mm: *mut sb4,
                                   ss: *mut sb4,
                                   fsec: *mut sb4,
                                   result: *const OCIInterval)
                                   -> sword;
}
extern "C" {
    pub fn OCIDateTimeToArray(hndl: *mut ::std::os::raw::c_void,
                              err: *mut OCIError,
                              datetime: *const OCIDateTime,
                              reftz: *const OCIInterval,
                              outarray: *mut ub1,
                              len: *mut ub4,
                              fsprec: ub1)
                              -> sword;
}
extern "C" {
    pub fn OCIDateTimeFromArray(hndl: *mut ::std::os::raw::c_void,
                                err: *mut OCIError,
                                inarray: *mut ub1,
                                len: ub4,
                                type_: ub1,
                                datetime: *mut OCIDateTime,
                                reftz: *const OCIInterval,
                                fsprec: ub1)
                                -> sword;
}
extern "C" {
    pub fn OCIDateTimeGetTimeZoneName(hndl: *mut ::std::os::raw::c_void,
                                      err: *mut OCIError,
                                      datetime: *const OCIDateTime,
                                      buf: *mut ub1,
                                      buflen: *mut ub4)
                                      -> sword;
}
extern "C" {
    pub fn OCIIntervalFromTZ(hndl: *mut ::std::os::raw::c_void,
                             err: *mut OCIError,
                             inpstring: *const oratext,
                             str_len: usize,
                             result: *mut OCIInterval)
                             -> sword;
}
extern "C" {
    pub fn OCIConnectionPoolCreate(envhp: *mut OCIEnv,
                                   errhp: *mut OCIError,
                                   poolhp: *mut OCICPool,
                                   poolName: *mut *mut OraText,
                                   poolNameLen: *mut sb4,
                                   dblink: *const OraText,
                                   dblinkLen: sb4,
                                   connMin: ub4,
                                   connMax: ub4,
                                   connIncr: ub4,
                                   poolUserName: *const OraText,
                                   poolUserLen: sb4,
                                   poolPassword: *const OraText,
                                   poolPassLen: sb4,
                                   mode: ub4)
                                   -> sword;
}
extern "C" {
    pub fn OCIConnectionPoolDestroy(poolhp: *mut OCICPool,
                                    errhp: *mut OCIError,
                                    mode: ub4)
                                    -> sword;
}
extern "C" {
    pub fn OCISessionPoolCreate(envhp: *mut OCIEnv,
                                errhp: *mut OCIError,
                                spoolhp: *mut OCISPool,
                                poolName: *mut *mut OraText,
                                poolNameLen: *mut ub4,
                                connStr: *const OraText,
                                connStrLen: ub4,
                                sessMin: ub4,
                                sessMax: ub4,
                                sessIncr: ub4,
                                userid: *mut OraText,
                                useridLen: ub4,
                                password: *mut OraText,
                                passwordLen: ub4,
                                mode: ub4)
                                -> sword;
}
extern "C" {
    pub fn OCISessionPoolDestroy(spoolhp: *mut OCISPool, errhp: *mut OCIError, mode: ub4) -> sword;
}
extern "C" {
    pub fn OCISessionGet(envhp: *mut OCIEnv,
                         errhp: *mut OCIError,
                         svchp: *mut *mut OCISvcCtx,
                         authhp: *mut OCIAuthInfo,
                         poolName: *mut OraText,
                         poolName_len: ub4,
                         tagInfo: *const OraText,
                         tagInfo_len: ub4,
                         retTagInfo: *mut *mut OraText,
                         retTagInfo_len: *mut ub4,
                         found: *mut boolean,
                         mode: ub4)
                         -> sword;
}
extern "C" {
    pub fn OCISessionRelease(svchp: *mut OCISvcCtx,
                             errhp: *mut OCIError,
                             tag: *mut OraText,
                             tag_len: ub4,
                             mode: ub4)
                             -> sword;
}
extern "C" {
    pub fn OCIAppCtxSet(sesshndl: *mut ::std::os::raw::c_void,
                        nsptr: *mut ::std::os::raw::c_void,
                        nsptrlen: ub4,
                        attrptr: *mut ::std::os::raw::c_void,
                        attrptrlen: ub4,
                        valueptr: *mut ::std::os::raw::c_void,
                        valueptrlen: ub4,
                        errhp: *mut OCIError,
                        mode: ub4)
                        -> sword;
}
extern "C" {
    pub fn OCIAppCtxClearAll(sesshndl: *mut ::std::os::raw::c_void,
                             nsptr: *mut ::std::os::raw::c_void,
                             nsptrlen: ub4,
                             errhp: *mut OCIError,
                             mode: ub4)
                             -> sword;
}
extern "C" {
    pub fn OCIMemStats(hndlp: *mut ::std::os::raw::c_void,
                       errhp: *mut OCIError,
                       envhp: *mut *mut OCIEnv,
                       mode: ub4,
                       mode1: ub4,
                       tabname: *mut oratext)
                       -> sword;
}
extern "C" {
    pub fn OCIPing(svchp: *mut OCISvcCtx, errhp: *mut OCIError, mode: ub4) -> sword;
}
extern "C" {
    pub fn OCIKerbAttrSet(trgthndlp: *mut OCISession,
                          cred_use: ub4,
                          ftgt_ticket: *mut ub1,
                          ticket_len: ub4,
                          session_key: *mut ub1,
                          skey_len: ub4,
                          ftgt_keytype: ub2,
                          ftgt_ticket_flags: ub4,
                          ftgt_auth_time: sb4,
                          ftgt_start_time: sb4,
                          ftgt_end_time: sb4,
                          ftgt_renew_time: sb4,
                          ftgt_client_principal: *mut oratext,
                          ftgt_client_principal_len: ub4,
                          ftgt_client_realm: *mut oratext,
                          ftgt_client_realm_len: ub4,
                          errhp: *mut OCIError)
                          -> sword;
}
extern "C" {
    pub fn OCIDBStartup(svchp: *mut OCISvcCtx,
                        errhp: *mut OCIError,
                        admhp: *mut OCIAdmin,
                        mode: ub4,
                        flags: ub4)
                        -> sword;
}
extern "C" {
    pub fn OCIDBShutdown(svchp: *mut OCISvcCtx,
                         errhp: *mut OCIError,
                         admhp: *mut OCIAdmin,
                         mode: ub4)
                         -> sword;
}
extern "C" {
    pub fn OCIClientVersion(major_version: *mut sword,
                            minor_version: *mut sword,
                            update_num: *mut sword,
                            patch_num: *mut sword,
                            port_update_num: *mut sword);
}
extern "C" {
    pub fn OCIInitEventHandle(errhp: *mut OCIError,
                              event: *mut OCIEvent,
                              str: *mut text,
                              size: ub4)
                              -> sword;
}
extern "C" {
    pub fn OCITranslatedErrorGet(svchp: *mut OCISvcCtx,
                                 hndlp: *mut ::std::os::raw::c_void,
                                 recordno: ub4,
                                 sqlstate: *mut OraText,
                                 sqlstatesiz: ub4,
                                 errcodep: *mut sb4,
                                 type_: ub4)
                                 -> sword;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xmlctx {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct OCIXmlDiffBnd {
    pub bndnmp: *mut oratext,
    pub bndnml: ub1,
    pub bndpos: ub2,
    pub bndnum: ub2,
    pub bnddty: ub2,
    pub bndvalp: *mut ::std::os::raw::c_void,
    pub bndvallen: ub4,
    pub bndcsid: ub2,
    pub bndcsform: ub1,
}
#[test]
fn bindgen_test_layout_OCIXmlDiffBnd() {
    assert_eq!(::std::mem::size_of::<OCIXmlDiffBnd>(),
               32usize,
               concat!("Size of: ", stringify!(OCIXmlDiffBnd)));
    assert_eq!(::std::mem::align_of::<OCIXmlDiffBnd>(),
               8usize,
               concat!("Alignment of ", stringify!(OCIXmlDiffBnd)));
    assert_eq!(unsafe { &(*(0 as *const OCIXmlDiffBnd)).bndnmp as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(OCIXmlDiffBnd),
                       "::",
                       stringify!(bndnmp)));
    assert_eq!(unsafe { &(*(0 as *const OCIXmlDiffBnd)).bndnml as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(OCIXmlDiffBnd),
                       "::",
                       stringify!(bndnml)));
    assert_eq!(unsafe { &(*(0 as *const OCIXmlDiffBnd)).bndpos as *const _ as usize },
               10usize,
               concat!("Alignment of field: ",
                       stringify!(OCIXmlDiffBnd),
                       "::",
                       stringify!(bndpos)));
    assert_eq!(unsafe { &(*(0 as *const OCIXmlDiffBnd)).bndnum as *const _ as usize },
               12usize,
               concat!("Alignment of field: ",
                       stringify!(OCIXmlDiffBnd),
                       "::",
                       stringify!(bndnum)));
    assert_eq!(unsafe { &(*(0 as *const OCIXmlDiffBnd)).bnddty as *const _ as usize },
               14usize,
               concat!("Alignment of field: ",
                       stringify!(OCIXmlDiffBnd),
                       "::",
                       stringify!(bnddty)));
    assert_eq!(unsafe { &(*(0 as *const OCIXmlDiffBnd)).bndvalp as *const _ as usize },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(OCIXmlDiffBnd),
                       "::",
                       stringify!(bndvalp)));
    assert_eq!(unsafe { &(*(0 as *const OCIXmlDiffBnd)).bndvallen as *const _ as usize },
               24usize,
               concat!("Alignment of field: ",
                       stringify!(OCIXmlDiffBnd),
                       "::",
                       stringify!(bndvallen)));
    assert_eq!(unsafe { &(*(0 as *const OCIXmlDiffBnd)).bndcsid as *const _ as usize },
               28usize,
               concat!("Alignment of field: ",
                       stringify!(OCIXmlDiffBnd),
                       "::",
                       stringify!(bndcsid)));
    assert_eq!(unsafe { &(*(0 as *const OCIXmlDiffBnd)).bndcsform as *const _ as usize },
               30usize,
               concat!("Alignment of field: ",
                       stringify!(OCIXmlDiffBnd),
                       "::",
                       stringify!(bndcsform)));
}
impl Clone for OCIXmlDiffBnd {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xmldrctx {
    _unused: [u8; 0],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ocixmldbpname {
    XCTXINIT_OCIDUR = 1,
    XCTXINIT_ERRHDL = 2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ocixmldbparam {
    pub name_ocixmldbparam: ocixmldbpname,
    pub value_ocixmldbparam: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ocixmldbparam() {
    assert_eq!(::std::mem::size_of::<ocixmldbparam>(),
               16usize,
               concat!("Size of: ", stringify!(ocixmldbparam)));
    assert_eq!(::std::mem::align_of::<ocixmldbparam>(),
               8usize,
               concat!("Alignment of ", stringify!(ocixmldbparam)));
    assert_eq!(unsafe { &(*(0 as *const ocixmldbparam)).name_ocixmldbparam as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(ocixmldbparam),
                       "::",
                       stringify!(name_ocixmldbparam)));
    assert_eq!(unsafe { &(*(0 as *const ocixmldbparam)).value_ocixmldbparam as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(ocixmldbparam),
                       "::",
                       stringify!(value_ocixmldbparam)));
}
impl Clone for ocixmldbparam {
    fn clone(&self) -> Self {
        *self
    }
}
extern "C" {
    /// DESCRIPTION
    ///
    /// -----------------------------OCIXmlDbInitXmlCtx---------------------------------
    /// Name
    /// OCIXmlDbInitXmlCtx
    /// Purpose
    /// To get a xmlctx structure initialized with error-handler and XDB callbacks.
    /// Syntax
    /// struct xmlctx *OCIXmlDbInitXmlCtx (OCIEnv           *envhp,
    /// OCISvcCtx        *svchp,
    /// OCIError         *err,
    /// params_ocixmldb *params,
    /// int               num_params);
    /// Parameters
    /// envhp (IN) - The OCI environment handle
    /// svchp (IN) - The OCI service handle
    /// errhp (IN) - The OCI error handle
    /// params (IN)- This contains the following optional parameters :
    /// (a) OCIDuration dur (IN - The OCI Duration (Default: OCI_DURATION_SESSION)
    /// (b) void (*err_handler) (sword, (const oratext *) (IN) -
    /// Pointer to the error handling function (Default: null)
    /// num_params (IN) - Number of parameters to be read from parameter params.
    /// If the value of num_params exceeds the size of array
    /// "params", unexpected behavior will result.
    ///
    /// Returns
    /// A pointer to xmlctx structure, with xdb context, error handler and callbacks
    /// populated with appropriate values. This is later used for all API calls. NULL
    /// if no database connection available.
    ///
    /// -----------------------------OCIXmlDbFreeXmlCtx----------------------------
    /// Name
    /// OCIXmlDbFreeXmlCtx
    /// Pupose
    /// To free any allocations done during OCIXmlDbInitXmlCtx.
    /// Syntax
    /// void OCIXmlDbFreeXmlCtx (struct xmlctx *xctx)
    /// Parameters
    /// xctx (IN) - The xmlctx to terminate
    /// Returns
    /// -
    /// ------------------------OCIXmlDbOrastreamFromLob---------------------------
    /// Name
    /// OCIXmlDbOrastreamFromLob
    /// Pupose
    /// To create an orastream from a lob. This orastream can be used by functions like XMLLoadDom().
    /// Syntax
    /// sword OCIXmlDbOrastreamFromLob(OCIError *errhp, xmlctx *xctx,
    /// void **stream, OCILobLocator *lobloc)
    /// Parameters
    /// envhp  (IN)     - The OCI environment handle
    /// xctx   (IN)     - XML context
    /// stream (IN/OUT) - A pointer to orastream
    /// lobloc (IN)     - The OCI lob locator
    /// Returns
    /// The orastream created on top of the lob is returned in the parameter 'stream'.
    pub fn OCIXmlDbInitXmlCtx(arg1: *mut OCIEnv,
                              arg2: *mut OCISvcCtx,
                              arg3: *mut OCIError,
                              arg4: *mut ocixmldbparam,
                              arg5: ::std::os::raw::c_int)
                              -> *mut xmlctx;
}
extern "C" {
    pub fn OCIXmlDbFreeXmlCtx(xctx: *mut xmlctx);
}
extern "C" {
    pub fn OCIXmlDbStreamFromXMLType(errhp: *mut OCIError,
                                     stream: *mut *mut ::std::os::raw::c_void,
                                     doc: *mut OCIXMLType,
                                     mode: ub4)
                                     -> sword;
}
extern "C" {
    pub fn OCIXmlDbOrastreamFromLob(errhp: *mut OCIError,
                                    xctx: *mut xmlctx,
                                    stream: *mut *mut ::std::os::raw::c_void,
                                    lobloc: *mut OCILobLocator)
                                    -> sword;
}
extern "C" {
    pub fn OCIXmlDbStreamRead(errhp: *mut OCIError,
                              stream: *mut ::std::os::raw::c_void,
                              bufp: *mut ::std::os::raw::c_void,
                              len: *mut sb8,
                              mode: ub4)
                              -> sword;
}
extern "C" {
    pub fn OCIXmlDbStreamClose(errhp: *mut OCIError, stream: *mut ::std::os::raw::c_void) -> sword;
}
extern "C" {
    pub fn OCIXmlDbRewriteXMLDiff(envhp: *mut OCIEnv,
                                  errhp: *mut OCIError,
                                  svchp: *mut OCISvcCtx,
                                  xctx: *mut xmldrctx,
                                  colname: *mut oratext,
                                  colnamelen: ub4,
                                  xmldiff: *const ::std::os::raw::c_void,
                                  xmldifflen: ub4,
                                  xdiff_locator: *mut OCILobLocator,
                                  updstmt: *mut *mut oratext,
                                  binditerator: ub2,
                                  colvalbndcount: *mut ub2,
                                  bindlist: *mut *mut OCIXmlDiffBnd,
                                  obj_tab_prefix: *mut oratext,
                                  obj_tab_prefix_len: ub2)
                                  -> sword;
}
extern "C" {
    pub fn OCIXmlInitDRCtx(env: *mut OCIEnv,
                           svc: *mut OCISvcCtx,
                           err: *mut OCIError,
                           bindtyp: ub1)
                           -> *mut xmldrctx;
}
extern "C" {
    pub fn OCIXmlFreeDRCtx(xctx: *mut xmldrctx);
}
extern "C" {
    pub fn OCIXmlGetDiffBndVersion() -> ub1;
}
extern "C" {
    pub fn OCIXmlDbGetFullyQualifiedSchemaUrl(errhp: *mut OCIError,
                                              schema_url: *mut oratext,
                                              schema_url_len: ub2,
                                              schema_owner: *mut oratext,
                                              schema_owner_len: ub2,
                                              fq_schema_url: *mut *mut oratext,
                                              fs_schema_url_len: *mut ub4)
                                              -> sword;
}
extern "C" {
    pub fn OCIXmlDbMemCallback(ctx: *mut ::std::os::raw::c_void,
                               size: usize)
                               -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIDirPathCtx {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIDirPathFuncCtx {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIDirPathColArray {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIDirPathStream {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCIDirPathDesc {
    _unused: [u8; 0],
}
extern "C" {
    pub fn OCIDirPathAbort(dpctx: *mut OCIDirPathCtx, errhp: *mut OCIError) -> sword;
}
extern "C" {
    pub fn OCIDirPathDataSave(dpctx: *mut OCIDirPathCtx,
                              errhp: *mut OCIError,
                              action: ub4)
                              -> sword;
}
extern "C" {
    pub fn OCIDirPathFinish(dpctx: *mut OCIDirPathCtx, errhp: *mut OCIError) -> sword;
}
extern "C" {
    pub fn OCIDirPathFlushRow(dpctx: *mut OCIDirPathCtx, errhp: *mut OCIError) -> sword;
}
extern "C" {
    pub fn OCIDirPathPrepare(dpctx: *mut OCIDirPathCtx,
                             svchp: *mut OCISvcCtx,
                             errhp: *mut OCIError)
                             -> sword;
}
extern "C" {
    pub fn OCIDirPathLoadStream(dpctx: *mut OCIDirPathCtx,
                                dpstr: *mut OCIDirPathStream,
                                errhp: *mut OCIError)
                                -> sword;
}
extern "C" {
    pub fn OCIDirPathColArrayEntryGet(dpca: *mut OCIDirPathColArray,
                                      errhp: *mut OCIError,
                                      rownum: ub4,
                                      colIdx: ub2,
                                      cvalpp: *mut *mut ub1,
                                      clenp: *mut ub4,
                                      cflgp: *mut ub1)
                                      -> sword;
}
extern "C" {
    pub fn OCIDirPathColArrayEntrySet(dpca: *mut OCIDirPathColArray,
                                      errhp: *mut OCIError,
                                      rownum: ub4,
                                      colIdx: ub2,
                                      cvalp: *mut ub1,
                                      clen: ub4,
                                      cflg: ub1)
                                      -> sword;
}
extern "C" {
    pub fn OCIDirPathColArrayRowGet(dpca: *mut OCIDirPathColArray,
                                    errhp: *mut OCIError,
                                    rownum: ub4,
                                    cvalppp: *mut *mut *mut ub1,
                                    clenpp: *mut *mut ub4,
                                    cflgpp: *mut *mut ub1)
                                    -> sword;
}
extern "C" {
    pub fn OCIDirPathColArrayReset(dpca: *mut OCIDirPathColArray, errhp: *mut OCIError) -> sword;
}
extern "C" {
    pub fn OCIDirPathColArrayToStream(dpca: *mut OCIDirPathColArray,
                                      dpctx: *mut OCIDirPathCtx,
                                      dpstr: *mut OCIDirPathStream,
                                      errhp: *mut OCIError,
                                      rowcnt: ub4,
                                      rowoff: ub4)
                                      -> sword;
}
extern "C" {
    pub fn OCIDirPathStreamReset(dpstr: *mut OCIDirPathStream, errhp: *mut OCIError) -> sword;
}
extern "C" {
    pub fn OCILCRNew(svchp: *mut OCISvcCtx,
                     errhp: *mut OCIError,
                     duration: OCIDuration,
                     lcrtype: ub1,
                     lcrp: *mut *mut ::std::os::raw::c_void,
                     mode: ub4)
                     -> sword;
}
extern "C" {
    pub fn OCILCRFree(svchp: *mut OCISvcCtx,
                      errhp: *mut OCIError,
                      lcrp: *mut ::std::os::raw::c_void,
                      mode: ub4)
                      -> sword;
}
extern "C" {
    pub fn OCILCRHeaderSet(svchp: *mut OCISvcCtx,
                           errhp: *mut OCIError,
                           src_db_name: *mut oratext,
                           src_db_name_len: ub2,
                           cmd_type: *mut oratext,
                           cmd_type_len: ub2,
                           owner: *mut oratext,
                           owner_len: ub2,
                           oname: *mut oratext,
                           oname_len: ub2,
                           tag: *mut ub1,
                           tag_len: ub2,
                           txid: *mut oratext,
                           txid_len: ub2,
                           src_time: *mut OCIDate,
                           position: *mut ub1,
                           position_len: ub2,
                           flag: oraub8,
                           lcrp: *mut ::std::os::raw::c_void,
                           mode: ub4)
                           -> sword;
}
extern "C" {
    pub fn OCILCRHeaderGet(svchp: *mut OCISvcCtx,
                           errhp: *mut OCIError,
                           src_db_name: *mut *mut oratext,
                           src_db_name_len: *mut ub2,
                           cmd_type: *mut *mut oratext,
                           cmd_type_len: *mut ub2,
                           owner: *mut *mut oratext,
                           owner_len: *mut ub2,
                           oname: *mut *mut oratext,
                           oname_len: *mut ub2,
                           tag: *mut *mut ub1,
                           tag_len: *mut ub2,
                           txid: *mut *mut oratext,
                           txid_len: *mut ub2,
                           src_time: *mut OCIDate,
                           old_columns: *mut ub2,
                           new_columns: *mut ub2,
                           position: *mut *mut ub1,
                           position_len: *mut ub2,
                           flag: *mut oraub8,
                           lcrp: *mut ::std::os::raw::c_void,
                           mode: ub4)
                           -> sword;
}
extern "C" {
    pub fn OCILCRRowColumnInfoSet(svchp: *mut OCISvcCtx,
                                  errhp: *mut OCIError,
                                  column_value_type: ub2,
                                  num_columns: ub2,
                                  column_names: *mut *mut oratext,
                                  column_name_lens: *mut ub2,
                                  column_dtyp: *mut ub2,
                                  column_valuesp: *mut *mut ::std::os::raw::c_void,
                                  column_indp: *mut OCIInd,
                                  column_alensp: *mut ub2,
                                  column_csetfp: *mut ub1,
                                  column_flags: *mut oraub8,
                                  column_csid: *mut ub2,
                                  row_lcrp: *mut ::std::os::raw::c_void,
                                  mode: ub4)
                                  -> sword;
}
extern "C" {
    pub fn OCILCRRowColumnInfoGet(svchp: *mut OCISvcCtx,
                                  errhp: *mut OCIError,
                                  column_value_type: ub2,
                                  num_columns: *mut ub2,
                                  column_names: *mut *mut oratext,
                                  column_name_lens: *mut ub2,
                                  column_dtyp: *mut ub2,
                                  column_valuesp: *mut *mut ::std::os::raw::c_void,
                                  column_indp: *mut OCIInd,
                                  column_alensp: *mut ub2,
                                  column_csetfp: *mut ub1,
                                  column_flags: *mut oraub8,
                                  column_csid: *mut ub2,
                                  row_lcrp: *mut ::std::os::raw::c_void,
                                  array_size: ub2,
                                  mode: ub4)
                                  -> sword;
}
extern "C" {
    pub fn OCILCRDDLInfoSet(svchp: *mut OCISvcCtx,
                            errhp: *mut OCIError,
                            object_type: *mut oratext,
                            object_type_len: ub2,
                            ddl_text: *mut oratext,
                            ddl_text_len: ub4,
                            logon_user: *mut oratext,
                            logon_user_len: ub2,
                            current_schema: *mut oratext,
                            current_schema_len: ub2,
                            base_table_owner: *mut oratext,
                            base_table_owner_len: ub2,
                            base_table_name: *mut oratext,
                            base_table_name_len: ub2,
                            flag: oraub8,
                            ddl_lcrp: *mut ::std::os::raw::c_void,
                            mode: ub4)
                            -> sword;
}
extern "C" {
    pub fn OCILCRDDLInfoGet(svchp: *mut OCISvcCtx,
                            errhp: *mut OCIError,
                            object_type: *mut *mut oratext,
                            object_type_len: *mut ub2,
                            ddl_text: *mut *mut oratext,
                            ddl_text_len: *mut ub4,
                            logon_user: *mut *mut oratext,
                            logon_user_len: *mut ub2,
                            current_schema: *mut *mut oratext,
                            current_schema_len: *mut ub2,
                            base_table_owner: *mut *mut oratext,
                            base_table_owner_len: *mut ub2,
                            base_table_name: *mut *mut oratext,
                            base_table_name_len: *mut ub2,
                            flag: *mut oraub8,
                            ddl_lcrp: *mut ::std::os::raw::c_void,
                            mode: ub4)
                            -> sword;
}
extern "C" {
    pub fn OCILCRAttributesSet(svchp: *mut OCISvcCtx,
                               errhp: *mut OCIError,
                               num_attrs: ub2,
                               attr_names: *mut *mut oratext,
                               attr_name_lens: *mut ub2,
                               attr_dtyp: *mut ub2,
                               attr_valuesp: *mut *mut ::std::os::raw::c_void,
                               attr_indp: *mut OCIInd,
                               attr_alensp: *mut ub2,
                               lcrp: *mut ::std::os::raw::c_void,
                               mode: ub4)
                               -> sword;
}
extern "C" {
    pub fn OCILCRAttributesGet(svchp: *mut OCISvcCtx,
                               errhp: *mut OCIError,
                               num_attrs: *mut ub2,
                               attr_names: *mut *mut oratext,
                               attr_namesl: *mut ub2,
                               attr_dtyp: *mut ub2,
                               attr_valuesp: *mut *mut ::std::os::raw::c_void,
                               attr_indp: *mut OCIInd,
                               attr_alensp: *mut ub2,
                               lcrp: *mut ::std::os::raw::c_void,
                               array_size: ub2,
                               mode: ub4)
                               -> sword;
}
extern "C" {
    pub fn OCILCRWhereClauseGet(svchp: *mut OCISvcCtx,
                                errhp: *mut OCIError,
                                wc_stmt: *mut oratext,
                                wc_stmt_len: *mut ub4,
                                row_lcrp: *mut ::std::os::raw::c_void,
                                mode: ub4)
                                -> sword;
}
extern "C" {
    pub fn OCILCRRowStmtGet(svchp: *mut OCISvcCtx,
                            errhp: *mut OCIError,
                            row_stmt: *mut oratext,
                            row_stmt_len: *mut ub4,
                            row_lcrp: *mut ::std::os::raw::c_void,
                            mode: ub4)
                            -> sword;
}
extern "C" {
    pub fn OCILCRWhereClauseWithBindVarGet(svchp: *mut OCISvcCtx,
                                           errhp: *mut OCIError,
                                           wc_stmt: *mut oratext,
                                           wc_stmt_len: *mut ub4,
                                           num_bind_var: *mut ub2,
                                           bind_var_dtyp: *mut ub2,
                                           bind_var_valuesp: *mut *mut ::std::os::raw::c_void,
                                           bind_var_indp: *mut OCIInd,
                                           bind_var_alensp: *mut ub2,
                                           bind_var_csetidp: *mut ub2,
                                           bind_var_csetfp: *mut ub1,
                                           row_lcrp: *mut ::std::os::raw::c_void,
                                           array_size: ub2,
                                           bind_var_syntax: *mut oratext,
                                           mode: ub4)
                                           -> sword;
}
extern "C" {
    pub fn OCILCRRowStmtWithBindVarGet(svchp: *mut OCISvcCtx,
                                       errhp: *mut OCIError,
                                       row_stmt: *mut oratext,
                                       row_stmt_len: *mut ub4,
                                       num_bind_var: *mut ub2,
                                       bind_var_dtyp: *mut ub2,
                                       bind_var_valuesp: *mut *mut ::std::os::raw::c_void,
                                       bind_var_indp: *mut OCIInd,
                                       bind_var_alensp: *mut ub2,
                                       bind_var_csetidp: *mut ub2,
                                       bind_var_csetfp: *mut ub1,
                                       row_lcrp: *mut ::std::os::raw::c_void,
                                       chunk_column_names: *mut *mut oratext,
                                       chunk_column_namesl: *mut ub2,
                                       chunk_column_flags: *mut oraub8,
                                       array_size: ub2,
                                       bind_var_syntax: *mut oratext,
                                       mode: ub4)
                                       -> sword;
}
extern "C" {
    pub fn OCILCRSCNsFromPosition(svchp: *mut OCISvcCtx,
                                  errhp: *mut OCIError,
                                  position: *mut ub1,
                                  position_len: ub2,
                                  scn: *mut OCINumber,
                                  commit_scn: *mut OCINumber,
                                  mode: ub4)
                                  -> sword;
}
extern "C" {
    pub fn OCILCRSCNToPosition(svchp: *mut OCISvcCtx,
                               errhp: *mut OCIError,
                               position: *mut ub1,
                               position_len: *mut ub2,
                               scn: *mut OCINumber,
                               mode: ub4)
                               -> sword;
}
extern "C" {
    pub fn OCILCRLobInfoGet(svchp: *mut OCISvcCtx,
                            errhp: *mut OCIError,
                            column_name: *mut *mut oratext,
                            column_name_len: *mut ub2,
                            column_dty: *mut ub2,
                            column_flag: *mut oraub8,
                            offset: *mut ub4,
                            size: *mut ub4,
                            row_lcrp: *mut ::std::os::raw::c_void,
                            mode: ub4)
                            -> sword;
}
extern "C" {
    pub fn OCILCRLobInfoSet(svchp: *mut OCISvcCtx,
                            errhp: *mut OCIError,
                            column_name: *mut oratext,
                            column_name_len: ub2,
                            column_dty: ub2,
                            column_flag: oraub8,
                            offset: ub4,
                            size: ub4,
                            row_lcrp: *mut ::std::os::raw::c_void,
                            mode: ub4)
                            -> sword;
}
extern "C" {
    pub fn OCIXStreamOutAttach(svchp: *mut OCISvcCtx,
                               errhp: *mut OCIError,
                               server_name: *mut oratext,
                               server_name_len: ub2,
                               last_position: *mut ub1,
                               last_position_len: ub2,
                               mode: ub4)
                               -> sword;
}
extern "C" {
    pub fn OCIXStreamOutProcessedLWMSet(svchp: *mut OCISvcCtx,
                                        errhp: *mut OCIError,
                                        processed_low_position: *mut ub1,
                                        processed_low_position_len: ub2,
                                        mode: ub4)
                                        -> sword;
}
pub type OCICallbackXStreamOutLCRProcess =
    ::std::option::Option<unsafe extern "C" fn(usrctxp: *mut ::std::os::raw::c_void,
                                               lcrp: *mut ::std::os::raw::c_void,
                                               lcrtyp: ub1,
                                               flag: oraub8)
                                               -> sb4>;
pub type OCICallbackXStreamOutChunkProcess =
    ::std::option::Option<unsafe extern "C" fn(usrctxp: *mut ::std::os::raw::c_void,
                                               column_name: *mut oratext,
                                               column_name_len: ub2,
                                               column_dty: ub2,
                                               column_flag: oraub8,
                                               column_csid: ub2,
                                               chunk_bytes: ub4,
                                               chunk_data: *mut ub1,
                                               flag: oraub8)
                                               -> sb4>;
extern "C" {
    pub fn OCIXStreamOutLCRCallbackReceive(svchp: *mut OCISvcCtx,
                                           errhp: *mut OCIError,
                                           processlcr_cb: OCICallbackXStreamOutLCRProcess,
                                           processchunk_cb: OCICallbackXStreamOutChunkProcess,
                                           usrctxp: *mut ::std::os::raw::c_void,
                                           fetch_low_position: *mut ub1,
                                           fetch_low_position_len: *mut ub2,
                                           mode: ub4)
                                           -> sword;
}
extern "C" {
    pub fn OCIXStreamOutLCRReceive(svchp: *mut OCISvcCtx,
                                   errhp: *mut OCIError,
                                   lcrp: *mut *mut ::std::os::raw::c_void,
                                   lcrtype: *mut ub1,
                                   flag: *mut oraub8,
                                   fetch_low_position: *mut ub1,
                                   fetch_low_position_len: *mut ub2,
                                   mode: ub4)
                                   -> sword;
}
extern "C" {
    pub fn OCIXStreamOutChunkReceive(svchp: *mut OCISvcCtx,
                                     errhp: *mut OCIError,
                                     column_name: *mut *mut oratext,
                                     column_name_len: *mut ub2,
                                     column_dty: *mut ub2,
                                     column_flag: *mut oraub8,
                                     column_csid: *mut ub2,
                                     chunk_bytes: *mut ub4,
                                     chunk_data: *mut *mut ub1,
                                     flag: *mut oraub8,
                                     mode: ub4)
                                     -> sword;
}
extern "C" {
    pub fn OCIXStreamOutDetach(svchp: *mut OCISvcCtx, errhp: *mut OCIError, mode: ub4) -> sword;
}
extern "C" {
    pub fn OCIXStreamInAttach(svchp: *mut OCISvcCtx,
                              errhp: *mut OCIError,
                              server_name: *mut oratext,
                              server_name_len: ub2,
                              source_name: *mut oratext,
                              source_name_len: ub2,
                              last_position: *mut ub1,
                              last_position_len: *mut ub2,
                              mode: ub4)
                              -> sword;
}
pub type OCICallbackXStreamInLCRCreate =
    ::std::option::Option<unsafe extern "C" fn(usrctxp: *mut ::std::os::raw::c_void,
                                               lcrp: *mut *mut ::std::os::raw::c_void,
                                               lcrtyp: *mut ub1,
                                               flag: *mut oraub8)
                                               -> sb4>;
pub type OCICallbackXStreamInChunkCreate =
    ::std::option::Option<unsafe extern "C" fn(usrctxp: *mut ::std::os::raw::c_void,
                                               column_name: *mut *mut oratext,
                                               column_name_len: *mut ub2,
                                               column_dty: *mut ub2,
                                               column_flag: *mut oraub8,
                                               column_csid: *mut ub2,
                                               chunk_bytes: *mut ub4,
                                               chunk_data: *mut *mut ub1,
                                               flag: *mut oraub8)
                                               -> sb4>;
extern "C" {
    pub fn OCIXStreamInLCRCallbackSend(svchp: *mut OCISvcCtx,
                                       errhp: *mut OCIError,
                                       createlcr_cb: OCICallbackXStreamInLCRCreate,
                                       createchunk_cb: OCICallbackXStreamInChunkCreate,
                                       userctxp: *mut ::std::os::raw::c_void,
                                       mode: ub4)
                                       -> sword;
}
extern "C" {
    pub fn OCIXStreamInLCRSend(svchp: *mut OCISvcCtx,
                               errhp: *mut OCIError,
                               lcrp: *mut ::std::os::raw::c_void,
                               lcrtype: ub1,
                               flag: oraub8,
                               mode: ub4)
                               -> sword;
}
extern "C" {
    pub fn OCIXStreamInChunkSend(svchp: *mut OCISvcCtx,
                                 errhp: *mut OCIError,
                                 column_name: *mut oratext,
                                 column_name_len: ub2,
                                 column_dty: ub2,
                                 column_flag: oraub8,
                                 column_csid: ub2,
                                 chunk_bytes: ub4,
                                 chunk_data: *mut ub1,
                                 flag: oraub8,
                                 mode: ub4)
                                 -> sword;
}
extern "C" {
    pub fn OCIXStreamInDetach(svchp: *mut OCISvcCtx,
                              errhp: *mut OCIError,
                              processed_low_position: *mut ub1,
                              processed_low_position_len: *mut ub2,
                              mode: ub4)
                              -> sword;
}
extern "C" {
    pub fn OCIXStreamInProcessedLWMGet(svchp: *mut OCISvcCtx,
                                       errhp: *mut OCIError,
                                       processed_low_position: *mut ub1,
                                       processed_low_position_len: *mut ub2,
                                       mode: ub4)
                                       -> sword;
}
extern "C" {
    pub fn OCIXStreamInFlush(svchp: *mut OCISvcCtx, errhp: *mut OCIError, mode: ub4) -> sword;
}
extern "C" {
    pub fn OCIXStreamInCommit(svchp: *mut OCISvcCtx,
                              errhp: *mut OCIError,
                              lcrp: *mut ::std::os::raw::c_void,
                              mode: ub4)
                              -> sword;
}
extern "C" {
    pub fn OCIXStreamInErrorGet(svchp: *mut OCISvcCtx,
                                errhp: *mut OCIError,
                                errcodep: *mut sb4,
                                msgbuf: *mut oratext,
                                msg_bufsize: ub2,
                                msg_len: *mut ub2,
                                txn_id: *mut oratext,
                                txn_id_bufsize: ub2,
                                txn_id_len: *mut ub2)
                                -> sword;
}
extern "C" {
    pub fn OCIXStreamOutSessionSet(svchp: *mut OCISvcCtx,
                                   errhp: *mut OCIError,
                                   attribute_name: *mut oratext,
                                   attribute_name_len: ub2,
                                   attribute_value: *mut ::std::os::raw::c_void,
                                   attribute_value_len: ub2,
                                   attribute_dty: ub2,
                                   mode: ub4)
                                   -> sword;
}
extern "C" {
    pub fn OCIXStreamInSessionSet(svchp: *mut OCISvcCtx,
                                  errhp: *mut OCIError,
                                  attribute_name: *mut oratext,
                                  attribute_name_len: ub2,
                                  attribute_value: *mut ::std::os::raw::c_void,
                                  attribute_value_len: ub2,
                                  attribute_dty: ub2,
                                  mode: ub4)
                                  -> sword;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(::std::mem::size_of::<__va_list_tag>(),
               24usize,
               concat!("Size of: ", stringify!(__va_list_tag)));
    assert_eq!(::std::mem::align_of::<__va_list_tag>(),
               8usize,
               concat!("Alignment of ", stringify!(__va_list_tag)));
    assert_eq!(unsafe { &(*(0 as *const __va_list_tag)).gp_offset as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(__va_list_tag),
                       "::",
                       stringify!(gp_offset)));
    assert_eq!(unsafe { &(*(0 as *const __va_list_tag)).fp_offset as *const _ as usize },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(__va_list_tag),
                       "::",
                       stringify!(fp_offset)));
    assert_eq!(unsafe { &(*(0 as *const __va_list_tag)).overflow_arg_area as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(__va_list_tag),
                       "::",
                       stringify!(overflow_arg_area)));
    assert_eq!(unsafe { &(*(0 as *const __va_list_tag)).reg_save_area as *const _ as usize },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(__va_list_tag),
                       "::",
                       stringify!(reg_save_area)));
}
impl Clone for __va_list_tag {
    fn clone(&self) -> Self {
        *self
    }
}
